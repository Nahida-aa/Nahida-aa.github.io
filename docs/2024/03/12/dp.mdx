---
title: dp
description: "**动态规划(Dynamic Programming)** 是一种将复杂问题分解成更小的子问题的方法, 通过保存子问题的结果来避免重复计算"
created_at: 2024-03-12T16:22:16Z
updated_at: 2025-04-03T16:22:16Z
tags: [alg,dp]
---

## leetCode 70 爬楼梯

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例1:**
> 输入：`n = 2`<br/>
> 输出：`2`<br/>
> 解释: 有两种方法可以爬到楼顶
> 1. 1 阶 + 1 阶
> 2. 2 阶

**示例2:**
> 输入：`n = 3`<br/>
> 输出：`3`<br/>
> 解释: 有三种方法可以爬到楼顶
> 1. 1 阶 + 1 阶 + 1 阶
> 2. 1 阶 + 2 阶
> 3. 2 阶 + 1 阶

**提示:**
- $1 \leq n \leq 45$

### 分析
1. 爬 3 阶, 从 2 阶上来是一种方法, 从 1 阶上来是另外一种方法
2. 因此爬 3 阶的方法数 = 爬 2 阶的方法数 + 爬 1 阶的方法数
3. 也就是 `f(n) = f(n-1) + f(n-2)`, 发现此递推公式符合斐波那契数列
### 解法1: 递归
```py
def dfs(n: int) -> int:
    if n <= 2:
        return n # f(1)=1, f(2)=2
    return dfs(n - 1) + dfs(n - 2)
```
**复杂度分析:**
- 时间复杂度: $O(2^n)$, 这个递归解法相当于搜索一个课高为 `n` 的二叉树
- 空间复杂度: $O(n)$, 递归栈的深度为 `n`

例如 n=7
```mermaid
graph TD
    7((7)) --> 6.6((6))
    7 --> 6.5((5))
    6.6 --> 5.5((5))
    6.6 --> 5.4((4))
    6.5 --> 5.4.2((4))
    6.5 --> 5.3((3))
    5.5 --> 4.4((4))
    5.5 --> 4.3((3))
    5.4 --> 4.3.2((3))
    5.4 --> 4.2((2))
    5.4.2 --> 4.3.3((3))
    5.4.2 --> 4.2.2((2))
    5.3 --> 4.2.1((2))
    5.3 --> 4.1((1))
    4.4 --> 3.3((3))
    4.4 --> 3.2((2))
    4.3 --> 3.2.2((2))
    4.3 --> 3.1((1))
    4.3.2 --> 3.2.3((2))
    4.3.2 --> 3.1.2((1))
    4.2 --> 3.1.3((1))
    4.3.3 --> 3.2.4((2))
    4.3.3 --> 3.1.4((1))
    4.2.2 --> 3.1.5((1))
    3.3 --> 2.2((2))
    3.3 --> 2.1((1))
```
> [!warning]
> 发现计算了过多的重复子问题
### 解法2: 递归 + 记录返回值 = 记忆化搜索
> [!note]
> 可以存储已经计算过的值, 以避免重复计算, 例如可以使用 array or hash_map 来存储<br/>
> 不过 python 中内置了, `functools.lru_cache{:py}` 装饰器, 可以直接用于这个需求
```py
from functools import lru_cache

@lru_cache(maxsize=None)
def dfs(n: int) -> int:
    if n <= 2:
        return n # f(1)=1, f(2)=2
    return dfs(n - 1) + dfs(n - 2)
```
使用记忆化搜索后的复杂度是$O(n)$, 只需要计算每个子问题一次, 递归栈的深度为 `n`, 所以空间复杂度也是 $O(n)$<br/>
图示如下:
```mermaid
graph LR
    7((7)) --> 6((6))
    6 --> 5((5))
    5 --> 4((4))
    4 --> 3((3))
    3 --> 2((2))
    2 --> 1((1))
```
### 解法3: 动态规划
> [!note]
> **动态规划(Dynamic Programming, DP)** 可以被看作是将**递归问题**转化为**迭代问题**的一种算法，但它的核心思想不仅仅是简单的转化，而是通过 **分解问题** 和 **存储子问题的解** 来优化计算过程
```py
def climbStairs(n: int) -> int:
    if n <= 2:
        return n
    dp = [0] * (n + 1)
    dp[1], dp[2] = 1, 2
    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]
```
### 解法4: DP + 状态压缩
- 在这个 解法3 中, `dp[i]` 的值只依赖于 `dp[i-1]` 和 `dp[i-2]`
- 因此，我们不需要存储整个 `dp` 数组，只需要用两个变量来保存最近的两个状态即可
- 状态压缩的时间复杂度与普通动态规划相同，但它的 空间复杂度更低，从 $O(n)$ 降到了 $O(1)$
- 在实际运行中，减少内存分配和访问的开销会使程序运行得更快
```py
def climbStairs(n: int) -> int:
    if n <= 2:
        return n
    prev, curr = 1, 2  # 初始化 f(1) 和 f(2)
    for i in range(3, n + 1):
        prev, curr = curr, prev + curr  # 更新状态
    return curr
```
### 解法5: 解通项公式
```math
\begin{align*}
&f(n) = f(n-1) + f(n-2) \\
&\rightarrow f(n) = \frac{1}{\sqrt{5}}(\phi^n - \psi^n) \\
&\phi = \frac{1 + \sqrt{5}}{2} \quad （黄金比例） \\
&\psi = \frac{1 - \sqrt{5}}{2} \\
\end{align*}
```
```py
from math import sqrt
def climbStairs(n: int) -> int:
    sqrt5 = math.sqrt(5)
    phi = (1 + sqrt5) / 2
    return round((phi**n - (1 - phi)**n) / sqrt5)
```
> [!note]
> 这个解法的时间复杂度是 $O(1)$, 但是由于浮点数精度问题, 当 `n` 较大时可能会出现误差
#### 证明
```math
f(n) = f(n-1) + f(n-2)
```
这是一个 **线性递推关系**, 并且它的系数是常数 (即 `1` 和 `1`) 。对于这种递推关, Binet's Formula 提供了一种通用的解法，可以直接推导出数列的通项公式

##### 待定系数法 推导

**1. 递推关系:**
```math
f(n) = f(n-1) + f(n-2)
```
这是一个二阶线性递推关系

**2. 特征方程:**

为了求解这个递推关系, 我们假设通解的形式为
```math
f(n) = x^n
```
- 将其代入递推关系中, 得到:
```math
x^n = x^{n-1} + x^{n-2}
```
- 除以 $x^{n-2}$ (假设 $x \neq 0$), 得到:
```math
x^2 = x + 1
```
这就是斐波那契数列的 **特征方程**

**3. 求解特征方程:**

- 解这个方程可以得到两个根:
```math
\begin{align*}
&x_1 = \frac{1 + \sqrt{5}}{2} \quad (黄金比例) \quad\quad
&x_2 = \frac{1 - \sqrt{5}}{2}
\end{align*}
```
**4. 通解的形式:**

根据线性递推关系，通解可以表示为特征根的线性组合：
```math
f(n) = A \cdot x_1^n + B \cdot x_2^n
```
**5. 确定系数:**
- 通过初始条件来确定系数 `A` 和 `B`
```math
\begin{aligned}
&\left\{
\begin{aligned}
f(0) &= A \cdot x_1^0 + B \cdot x_2^0 = 0, \\
f(1) &= A \cdot x_1 + B \cdot x_2 = 1, \\
f(2) &= A \cdot x_1^2 + B \cdot x_2^2 = 2.
\end{aligned}
\right. 
\\
&\left\{
\begin{aligned}
A + B &= 0, \\
A \cdot x_1 + B \cdot x_2 &= 1.
\end{aligned}
\right.
\end{aligned}
```
```math
A \cdot \frac{1 + \sqrt{5}}{2} + (-A) \cdot \frac{1 - \sqrt{5}}{2} = 1 
```
解得
```math
\left\{
\begin{aligned}
&A \cdot \sqrt{5} = 1, \\
&A = \frac{1}{\sqrt{5}}, \\
&B = -\frac{1}{\sqrt{5}}.
\end{aligned}
\right.
```
- 斐波那契数列的通项公式为:
```math
f(n) = \frac{1}{\sqrt{5}}(x_1^n - x_2^n)
```
### 总结: 不同解法对比
| 解法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
|------|------------|------------|------|------|
| 递归 | $O(2^n)$   | $O(n)$     | 简单易懂 | 重复计算, 效率低 |
| 记忆化搜索 | $O(n)$   | $O(n)$     | 避免重复计算 | 需要额外的存储空间 |
| 动态规划(数组) | $O(n)$   | $O(n)$     | 直观易懂 | 需要额外的数组存储空间 |
| 动态规划(状态压缩) | $O(n)$   | $O(1)$     | 节省空间 | 代码稍复杂 |
| 数学解法(斐波那契公式) | $O(1)$   | $O(1)$     | 理论最快，常数时间复杂度 | 浮点运算可能导致精度问题 |