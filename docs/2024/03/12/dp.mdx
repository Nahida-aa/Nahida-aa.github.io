---
title: dp
description: "**动态规划(Dynamic Programming)** 是一种将复杂问题分解成更小的子问题的方法, 通过保存子问题的结果来避免重复计算"
created_at: 2024-03-12T16:22:16Z
updated_at: 2025-04-03T16:22:16Z
tags: [alg,dp]
---

## leetCode 70 爬楼梯

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例1:**
> 输入：`n = 2`<br/>
> 输出：`2`<br/>
> 解释: 有两种方法可以爬到楼顶
> 1. 1 阶 + 1 阶
> 2. 2 阶

**示例2:**
> 输入：`n = 3`<br/>
> 输出：`3`<br/>
> 解释: 有三种方法可以爬到楼顶
> 1. 1 阶 + 1 阶 + 1 阶
> 2. 1 阶 + 2 阶
> 3. 2 阶 + 1 阶

**提示:**
- $1 \leq n \leq 45$

### 分析
1. 爬 3 阶, 从 2 阶上来是一种方法, 从 1 阶上来是另外一种方法
2. 因此爬 3 阶的方法数 = 爬 2 阶的方法数 + 爬 1 阶的方法数
3. 也就是 `f(n) = f(n-1) + f(n-2)`, 发现此递推公式符合斐波那契数列
### 解法1: 递归
```py
def dfs(n: int) -> int:
    if n <= 2:
        return n # f(1)=1, f(2)=2
    return dfs(n - 1) + dfs(n - 2)
```
**复杂度分析:**
- 时间复杂度: $O(2^n)$, 这个递归解法相当于搜索一个课高为 `n` 的二叉树
- 空间复杂度: $O(n)$, 递归栈的深度为 `n`

例如 n=7
```mermaid
graph TD
    7((7)) --> 6.6((6))
    7 --> 6.5((5))
    6.6 --> 5.5((5))
    6.6 --> 5.4((4))
    6.5 --> 5.4.2((4))
    6.5 --> 5.3((3))
    5.5 --> 4.4((4))
    5.5 --> 4.3((3))
    5.4 --> 4.3.2((3))
    5.4 --> 4.2((2))
    5.4.2 --> 4.3.3((3))
    5.4.2 --> 4.2.2((2))
    5.3 --> 4.2.1((2))
    5.3 --> 4.1((1))
    4.4 --> 3.3((3))
    4.4 --> 3.2((2))
    4.3 --> 3.2.2((2))
    4.3 --> 3.1((1))
    4.3.2 --> 3.2.3((2))
    4.3.2 --> 3.1.2((1))
    4.2 --> 3.1.3((1))
    4.3.3 --> 3.2.4((2))
    4.3.3 --> 3.1.4((1))
    4.2.2 --> 3.1.5((1))
    3.3 --> 2.2((2))
    3.3 --> 2.1((1))
```
> [!warning]
> 发现计算了过多的重复子问题
### 解法2: 递归 + 记录返回值 = 记忆化搜索
> [!note]
> 可以存储已经计算过的值, 以避免重复计算, 例如可以使用 array or hash_map 来存储<br/>
> 不过 python 中内置了, `functools.lru_cache{:py}` 装饰器, 可以直接用于这个需求
```py
from functools import lru_cache

@lru_cache(maxsize=None)
def dfs(n: int) -> int:
    if n <= 2:
        return n # f(1)=1, f(2)=2
    return dfs(n - 1) + dfs(n - 2)
```
使用记忆化搜索后的复杂度是$O(n)$, 只需要计算每个子问题一次, 递归栈的深度为 `n`, 所以空间复杂度也是 $O(n)$<br/>
图示如下:
```mermaid
graph LR
    7((7)) --> 6((6))
    6 --> 5((5))
    5 --> 4((4))
    4 --> 3((3))
    3 --> 2((2))
    2 --> 1((1))
```
### 解法3: 动态规划
> [!note]
> **动态规划(Dynamic Programming, DP)** 可以被看作是将**递归问题**转化为**迭代问题**的一种算法，但它的核心思想不仅仅是简单的转化，而是通过 **分解问题** 和 **存储子问题的解** 来优化计算过程
```py
def climbStairs(n: int) -> int:
    if n <= 2:
        return n
    dp = [0] * (n + 1)
    dp[1], dp[2] = 1, 2
    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]
```
### 解法4: DP + 状态压缩(滚动数组)
- 在这个 解法3 中, `dp[i]` 的值只依赖于 `dp[i-1]` 和 `dp[i-2]`
- 因此，我们不需要存储整个 `dp` 数组，只需要用两个变量来保存最近的两个状态即可
- 状态压缩的时间复杂度与普通动态规划相同，但它的 空间复杂度更低，从 $O(n)$ 降到了 $O(1)$
- 在实际运行中，减少内存分配和访问的开销会使程序运行得更快
```py
def climbStairs(n: int) -> int:
    if n <= 2:
        return n
    prev, curr = 1, 2  # 初始化 f(1) 和 f(2)
    for i in range(3, n + 1):
        prev, curr = curr, prev + curr  # 更新状态
    return curr
```
### 解法5: 解通项公式
```math
\begin{align*}
&f(n) = f(n-1) + f(n-2) \\
&\rightarrow f(n) = \frac{1}{\sqrt{5}}(\phi^n - \psi^n) \\
&\phi = \frac{1 + \sqrt{5}}{2} \quad （黄金比例） \\
&\psi = \frac{1 - \sqrt{5}}{2} \\
\end{align*}
```
```py
from math import sqrt
def climbStairs(n: int) -> int:
    sqrt5 = sqrt(5)
    phi = (1 + sqrt5) / 2
    n += 1 # 注意这题求的是 f(n+1)
    return round((phi**n - (1 - phi)**n) / sqrt5)
```
> [!note]
> 这个解法的时间复杂度是 $O(1)$, 但是由于浮点数精度问题, 当 `n` 较大时可能会出现误差
#### 证明
```math
f(n) = f(n-1) + f(n-2)
```
这是一个 **线性递推关系**, 并且它的系数是常数 (即 `1` 和 `1`) 。对于这种递推关, Binet's Formula 提供了一种通用的解法，可以直接推导出数列的通项公式

##### 待定系数法 推导

**1. 递推关系:**
```math
f(n) = f(n-1) + f(n-2)
```
这是一个二阶线性递推关系

**2. 特征方程:**

为了求解这个递推关系, 我们假设通解的形式为
```math
f(n) = x^n
```
- 将其代入递推关系中, 得到:
```math
x^n = x^{n-1} + x^{n-2}
```
- 除以 $x^{n-2}$ (假设 $x \neq 0$), 得到:
```math
x^2 = x + 1
```
这就是斐波那契数列的 **特征方程**

**3. 求解特征方程:**

- 解这个方程可以得到两个根:
```math
\begin{align*}
&x_1 = \frac{1 + \sqrt{5}}{2} \quad (黄金比例) \quad\quad
&x_2 = \frac{1 - \sqrt{5}}{2}
\end{align*}
```
**4. 通解的形式:**

根据线性递推关系，通解可以表示为特征根的线性组合：
```math
f(n) = A \cdot x_1^n + B \cdot x_2^n
```
**5. 确定系数:**
- 通过初始条件来确定系数 `A` 和 `B`
```math
\begin{aligned}
&\left\{
\begin{aligned}
f(0) &= A \cdot x_1^0 + B \cdot x_2^0 = 0, \\
f(1) &= A \cdot x_1 + B \cdot x_2 = 1, \\
f(2) &= A \cdot x_1^2 + B \cdot x_2^2 = 2.
\end{aligned}
\right. 
\\
&\left\{
\begin{aligned}
A + B &= 0, \\
A \cdot x_1 + B \cdot x_2 &= 1.
\end{aligned}
\right.
\end{aligned}
```
```math
A \cdot \frac{1 + \sqrt{5}}{2} + (-A) \cdot \frac{1 - \sqrt{5}}{2} = 1 
```
解得
```math
\left\{
\begin{aligned}
&A \cdot \sqrt{5} = 1, \\
&A = \frac{1}{\sqrt{5}}, \\
&B = -\frac{1}{\sqrt{5}}.
\end{aligned}
\right.
```
- 斐波那契数列的通项公式为:
```math
f(n) = \frac{1}{\sqrt{5}}(x_1^n - x_2^n)
```
### 总结: 不同解法对比
| 解法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
|------|------------|------------|------|------|
| 递归 | $O(2^n)$   | $O(n)$     | 简单易懂 | 重复计算, 效率低 |
| 记忆化搜索 | $O(n)$   | $O(n)$     | 避免重复计算 | 需要额外的存储空间 |
| 动态规划(数组) | $O(n)$   | $O(n)$     | 直观易懂 | 需要额外的数组存储空间 |
| 动态规划(状态压缩) | $O(n)$   | $O(1)$     | 节省空间 | 代码稍复杂 |
| 数学解法(斐波那契公式) | $O(1)$   | $O(1)$     | 理论最快，常数时间复杂度 | 浮点运算可能导致精度问题 |

## leetCode 198 打家劫舍
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

**示例1:**
> 输入：`nums = [1,2,3,1]`<br/>
> 输出：`4`<br/>
> 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3) 。偷窃到的最高金额 = 1 + 3 = 4 。

**示例2:**
> 输入：`nums = [2,7,9,3,1]`<br/>
> 输出：`12`<br/>
> 解释：偷窃 1 号房屋 (金额 = 2)，然后偷窃 3 号房屋 (金额 = 9)，最后偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12 。

**提示:**
- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

```py
def rob(self, nums: List[int]) -> int:
    n = len(nums)
    if n == 0:
        return 0
    if n == 1:
        return nums[0]
    dp = [0] * n
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])
    for i in range(2, n):
        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
    return dp[-1]
```
易懂解法
```py
def rob(self, nums: List[int]) -> int:
    n = len(nums)
    if n == 0:
        return 0
    if n == 1:
        return nums[0]
    dp = [[0, 0] for _ in range(n)]
    dp[0][0] = 0
    dp[0][1] = nums[0]
    for i in range(1, n):
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])
        dp[i][1] = dp[i - 1][0] + nums[i]
    return max(dp[-1][0], dp[-1][1])
```

## 背包问题

$N$ 个物品, 价值为 $v_i$, 重量为 $w_i$, 背包总容量为 $W$, 找到背包能装下的最大价值
- 0-1背包问题: 每个物品只能选择 0 或 1 次
- 完全背包问题: 每个物品可以选择多次
- 多重背包问题: 每个物品最多选择 $s_i$ 次
- 分组背包问题: 物品分为若干组, 每组只能选择 0 或 1 次

### 0-1背包问题
状态表示: `dp[i][j]{:py}` 表示前 `i` 个物品, 背包容量为 `j` 时的最大价值

那么 `dp[N][W]{:py}` 就是我们要求的最大价值

从 `i-1` 到 `i` 这个过程, 有两种情况, 即选第 `i` 个物品和不选第 `i` 个物品:
- 如果不选第 `i` 个物品, 那么最大价值就是前 `i-1` 个物品的最大价值, 即 `dp[i-1][j]{:py}`
- 如果选第 `i` 个物品, 那么最大价值就是前 `i-1` 个物品的最大价值加上第 `i` 个物品的价值, 即 `dp[i-1][j-w_i] + v_i{:py}`

> [!note]
> 这里需要注意, 如果选第 `i` 个物品, 那么背包的容量就要减去第 `i` 个物品的重量, 即 `j-w_i`<br/>
> 因此 `dp[i][j]{:py}` 就是 `dp[i-1][j]{:py}` 和 `dp[i-1][j-w_i] + v_i{:py}` 的最大值<br/>
> 注意: 需要判断 `j` 是否大于等于 `w_i`, 如果小于 `w_i`, 那么就不能选第 `i` 个物品, 也就是 `dp[i][j] = dp[i-1][j]{:py}`

状态转移方程:
```math
dp[i][j] = \left\{
\begin{aligned}
&dp[i-1][j] & j < w_i \\
&max(dp[i-1][j], dp[i-1][j-w_i] + v_i) & j \geq w_i
\end{aligned}
\right.
```
graph