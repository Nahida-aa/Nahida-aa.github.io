[
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/i18n",
    "slug": "i18n",
    "segments": [
      "i18n"
    ],
    "filePath": "docs/zh/i18n.mdx",
    "meta": {
      "title": "i18 国际化",
      "description": null,
      "created_at": "2025-03-17T20:14:57.000Z",
      "updated_at": "2025-03-17T20:14:57.000Z",
      "tags": []
    },
    "order": 99,
    "content": "\n```sh\npnpm add i18next react-i18next i18next-resources-to-backend next-i18n-router\n```\n",
    "toc": []
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/dev/contentlayer",
    "slug": "dev/contentlayer",
    "segments": [
      "dev",
      "contentlayer"
    ],
    "filePath": "docs/zh/dev/contentlayer.mdx",
    "meta": {},
    "order": 99,
    "content": "# contentlayer\n",
    "toc": [
      {
        "depth": 1,
        "value": "contentlayer",
        "slug": "contentlayer"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/learn",
    "slug": "learn",
    "segments": [
      "learn"
    ],
    "filePath": "docs/zh/learn.mdx",
    "meta": {
      "title": "学习",
      "description": null,
      "created_at": "2025-03-23T14:55:10.000Z",
      "updated_at": "2025-03-23T14:55:10.000Z",
      "tags": []
    },
    "order": 99,
    "content": "\n## 站点地图\n\n\n```mermaid caption=\"拓扑图 1. AI \\ CS \\ ES 学科笔记\"\nflowchart LR\n    程序设计(程序设计)\n    数字逻辑电路(数字逻辑电路)\n    数据结构(数据结构)\n    算法(算法)\n    计算机系统基础(计算机系统基础)\n    数据库(数据库)\n    操作系统(操作系统)\n    计算机组成(计算机组成)\n    计算机网络(计算机网络)\n\n    程序设计 --> 数据结构 & 算法 --> 计算机系统基础\n    数字逻辑电路 --> 计算机系统基础 --> 数据库 & 操作系统 & 计算机组成\n    计算机组成 & 操作系统 --> 计算机网络\n\n    Python高级应用(Python 高级应用)\n    数字图像处理(数字图像处理)\n    机器学习(机器学习)\n    深度学习(深度学习)\n    数据挖掘(数据挖掘)\n    自然语言处理(自然语言处理)\n    计算机视觉(计算机视觉)\n    数字信号处理(数字信号处理)\n    智慧教育(智慧教育)\n\n    Python高级应用 --> 数字图像处理 & 数字信号处理 & 机器学习\n    机器学习 --> 深度学习 & 数据挖掘\n    深度学习 --> 自然语言处理 & 计算机视觉 --> 智慧教育\n    数字图像处理 --> 计算机视觉\n\n    微积分(微积分)\n    矩阵(矩阵)\n    概率论(概率论)\n    最优化方法(最优化方法)\n    微积分 & 矩阵 & 概率论 --> 最优化方法 --> 机器学习\n    程序设计 --> Python高级应用\n\n    %% 跳转链接\n    click 微积分 \"./base/advanced-math/\"\n    click 矩阵 \"./base/linear-algebra/\"\n    click 概率论 \"./base/probability-and-statistics/\"\n    click 最优化方法 \"./base/optimization-method/\"\n\n    click 程序设计 \"./base/object-oriented-programming/\"\n    click 数字逻辑电路 \"./base/digital-logic-circuit/\"\n    click 计算机系统基础 \"./base/computer-system-basic/\"\n    click 数据库 \"./base/database/\"\n    click 数据结构与算法 \"./ds-and-algo/\"\n    click 操作系统 \"./base/operating-system/\"\n    click 计算机组成 \"./base/computer-organization/\"\n    click 计算机网络 \"./base/computer-network/\"\n\n    click Python高级应用 \"./base/python-application/\"\n    click 数字图像处理 \"./base/digital-image-processing/\"\n    click 机器学习 \"./base/machine-learning/\"\n    click 深度学习 \"./base/deep-learning/\"\n    click 数据挖掘 \"./base/data-mining/\"\n    click 自然语言处理 \"./base/natural-language-processing/\"\n    click 计算机视觉 \"./base/computer-vision/\"\n    click 数字信号处理 \"./base/digital-signal-processing/\"\n    click 智慧教育 \"./base/intelligent-education/\"\n```\n<table>\n<caption> 拓扑图 1. AI \\ CS \\ ES 学科笔记 </caption>\n</table>\n\n```mermaid \ngraph LR\n  %% 实体定义\n  algo(数据结构与算法专栏)\n  dev_tools(开发工具专栏)\n  fe(前端开发专栏)\n  be(后端开发专栏)\n  dev_ops(运维开发专栏)\n  \n  %% 关系定义\n  algo --> be\n  dev_tools --> fe & be & dev_ops\n  \n  %% 跳转链接\n  click algo \"./ds-and-algo/\"\n  click dev_tools \"./dev-tools/\"\n  click fe \"./front-end/\"\n  click be \"./back-end/\"\n  click dev_ops \"./operation/\"\n```\n<table>\n<caption> 拓扑图 2. 开发技术文章 </caption>\n</table>\n\n```py {1}\n# fib\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n```",
    "toc": [
      {
        "depth": 2,
        "value": "站点地图",
        "slug": "站点地图"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/dev",
    "slug": "dev",
    "segments": [
      "dev"
    ],
    "filePath": "docs/zh/dev/index.mdx",
    "meta": {
      "title": "dev",
      "description": null,
      "created_at": "2025-03-21T09:48:56.000Z",
      "updated_at": "2025-03-21T09:48:56.000Z",
      "tags": [
        "dev"
      ]
    },
    "order": 99,
    "content": "\n## 常用框架\\库\\module\n\n- [Next.js](https://nextjs.org/)\n- [Hono.js](https://hono.dev/)\n- [FastApi](https://fastapi.tiangolo.com/)\n- [Pytorch](https://pytorch.org/)\n- [Tensorflow](https://www.tensorflow.org/)\n\n## 常用工具\n\n- [github copilot](https://copilot.github.com/)\n- [git](./git)\n",
    "toc": [
      {
        "depth": 2,
        "value": "常用框架\\库\\module",
        "slug": "常用框架\\库\\module"
      },
      {
        "depth": 2,
        "value": "常用工具",
        "slug": "常用工具"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/dev/search",
    "slug": "dev/search",
    "segments": [
      "dev",
      "search"
    ],
    "filePath": "docs/zh/dev/search.mdx",
    "meta": {
      "title": "增添搜索引擎",
      "description": "增加搜索功能, 支持全部内容搜索",
      "created_at": "2025-03-19T17:49:42.000Z",
      "updated_at": "2025-03-19T17:49:42.000Z",
      "tags": [
        "search",
        "web"
      ]
    },
    "order": 99,
    "content": "\n## 结构选择\n\n| type | description |\n| --- | --- |\n| arr | 数组 |\n| arrTree | 数组树 |\n| kvArr | 键值数组 |\n| kvTree | 键值树 |\n\n### 需求\n\n- [ ] 搜索\n  - [ ] 支持全文搜索\n  - [ ] 支持搜索结果高亮\n  - [ ] 支持搜索结果分页\n  - [ ] 支持搜索结果排序\n- [ ] 详情页面\n- [ ] 树状侧边导航栏\n\n### 解析 标题\n\n## 搜索引擎\n\n**Fuse.js** 是一个轻量级的 JavaScript 模糊搜索库，专门用于在小型数据集（如数组或对象列表）中快速执行模糊搜索。它非常适合在前端应用中实现搜索功能，尤其是当你需要对非精确匹配的结果进行排序时。\n\n---\n\n### 核心功能\n1. **模糊搜索**：\n   - 支持对字符串进行模糊匹配，例如输入 \"appl\" 可以匹配到 \"apple\"。\n   \n2. **权重配置**：\n   - 可以为对象的不同字段设置权重，影响搜索结果的排序。\n\n3. **高性能**：\n   - 适合小型到中型数据集，搜索速度非常快。\n\n4. **灵活性**：\n   - 支持多字段搜索、阈值调整、结果高亮等功能。\n\n---\n\n### 安装\n你可以通过 npm 或 yarn 安装 Fuse.js：\n\n```bash\nnpm install fuse.js\n```\n\n或者使用 yarn：\n\n```bash\nyarn add fuse.js\n```\n\n---\n\n### 基本用法\n\n#### 示例数据\n假设你有以下数据：\n\n```javascript\nconst books = [\n  { title: \"The Great Gatsby\", author: \"F. Scott Fitzgerald\" },\n  { title: \"To Kill a Mockingbird\", author: \"Harper Lee\" },\n  { title: \"1984\", author: \"George Orwell\" },\n  { title: \"The Catcher in the Rye\", author: \"J.D. Salinger\" },\n  { title: \"The Hobbit\", author: \"J.R.R. Tolkien\" }\n];\n```\n\n#### 创建 Fuse 实例\n```javascript\nimport Fuse from \"fuse.js\";\n\nconst options = {\n  keys: [\"title\", \"author\"], // 搜索的字段\n  threshold: 0.3, // 匹配的模糊程度，0 完全匹配，1 匹配最宽松\n};\n\nconst fuse = new Fuse(books, options);\n```\n\n#### 执行搜索\n```javascript\nconst result = fuse.search(\"hobbit\");\nconsole.log(result);\n```\n\n#### 输出结果\n```javascript\n[\n  {\n    item: { title: \"The Hobbit\", author: \"J.R.R. Tolkien\" },\n    refIndex: 4\n  }\n]\n```\n\n---\n\n### 配置选项\n\n#### 常用选项\n- **`keys`**：\n  - 指定要搜索的字段（适用于对象数组）。\n  - 示例：`keys: [\"title\", \"author\"]`。\n\n- **`threshold`**：\n  - 控制模糊匹配的程度，范围是 `0` 到 `1`。\n  - `0` 表示完全匹配，`1` 表示最宽松的匹配。\n\n- **`includeScore`**：\n  - 是否在结果中包含匹配的分数（`score`）。\n  - 示例：`includeScore: true`。\n\n- **`includeMatches`**：\n  - 是否在结果中包含匹配的详细信息（如匹配的字段和位置）。\n  - 示例：`includeMatches: true`。\n\n- **`minMatchCharLength`**：\n  - 设置最小匹配字符长度。\n  - 示例：`minMatchCharLength: 3`。\n\n- **`distance`**：\n  - 控制模糊匹配时的字符距离，默认值为 `100`。\n\n---\n\n### 高级用法\n\n#### 多字段搜索\n如果你的数据是对象数组，可以指定多个字段进行搜索：\n\n```javascript\nconst options = {\n  keys: [\"title\", \"author\"],\n  threshold: 0.4,\n};\n\nconst fuse = new Fuse(books, options);\nconst result = fuse.search(\"George\");\nconsole.log(result);\n```\n\n#### 权重配置\n可以为不同字段设置权重，影响搜索结果的排序：\n\n```javascript\nconst options = {\n  keys: [\n    { name: \"title\", weight: 0.7 },\n    { name: \"author\", weight: 0.3 },\n  ],\n};\n\nconst fuse = new Fuse(books, options);\nconst result = fuse.search(\"George\");\nconsole.log(result);\n```\n\n#### 高亮匹配\n启用 `includeMatches` 选项，可以获取匹配的详细信息（如匹配的字段和位置）：\n\n```javascript\nconst options = {\n  keys: [\"title\", \"author\"],\n  includeMatches: true,\n};\n\nconst fuse = new Fuse(books, options);\nconst result = fuse.search(\"hobbit\");\nconsole.log(result);\n```\n\n输出结果：\n```javascript\n[\n  {\n    item: { title: \"The Hobbit\", author: \"J.R.R. Tolkien\" },\n    matches: [\n      {\n        indices: [[0, 5]], // 匹配的位置\n        key: \"title\", // 匹配的字段\n        value: \"The Hobbit\" // 匹配的值\n      }\n    ]\n  }\n]\n```\n\n---\n\n### 使用场景\n1. **前端搜索框**：\n   - 在前端实现实时搜索功能，例如搜索博客文章、商品列表等。\n\n2. **多字段搜索**：\n   - 在对象数组中搜索多个字段，例如标题、描述、标签等。\n\n3. **模糊匹配**：\n   - 允许用户输入不完全正确的关键词，仍然能找到相关结果。\n\n4. **结果排序**：\n   - 根据匹配的分数对结果进行排序，优先显示最相关的结果。\n\n---\n\n### 优势和限制\n\n#### 优势\n- **轻量级**：库本身非常小，适合前端使用。\n- **易用性**：API 简单，配置灵活。\n- **模糊匹配**：支持宽松的匹配规则，用户体验更好。\n\n#### 限制\n- **适合小型数据集**：对于大型数据集（如几万条记录），性能可能会下降。\n- **不支持全文搜索**：不适合需要全文索引的大型搜索场景（如 Elasticsearch）。\n\n---\n\n### 总结\n**Fuse.js** 是一个强大且易用的模糊搜索库，适合在前端实现小型数据集的模糊搜索功能。如果你的数据量较小且需要灵活的模糊匹配，Fuse.js 是一个非常好的选择。\n\n如果你有更复杂的搜索需求（如全文搜索或大规模数据），可以考虑使用更强大的工具，如 Elasticsearch 或 Algolia。\n",
    "toc": [
      {
        "depth": 2,
        "value": "结构选择",
        "slug": "结构选择"
      },
      {
        "depth": 3,
        "value": "需求",
        "slug": "需求"
      },
      {
        "depth": 3,
        "value": "解析 标题",
        "slug": "解析-标题"
      },
      {
        "depth": 2,
        "value": "搜索引擎",
        "slug": "搜索引擎"
      },
      {
        "depth": 3,
        "value": "核心功能",
        "slug": "核心功能"
      },
      {
        "depth": 3,
        "value": "安装",
        "slug": "安装"
      },
      {
        "depth": 3,
        "value": "基本用法",
        "slug": "基本用法"
      },
      {
        "depth": 4,
        "value": "示例数据",
        "slug": "示例数据"
      },
      {
        "depth": 4,
        "value": "创建 Fuse 实例",
        "slug": "创建-fuse-实例"
      },
      {
        "depth": 4,
        "value": "执行搜索",
        "slug": "执行搜索"
      },
      {
        "depth": 4,
        "value": "输出结果",
        "slug": "输出结果"
      },
      {
        "depth": 3,
        "value": "配置选项",
        "slug": "配置选项"
      },
      {
        "depth": 4,
        "value": "常用选项",
        "slug": "常用选项"
      },
      {
        "depth": 3,
        "value": "高级用法",
        "slug": "高级用法"
      },
      {
        "depth": 4,
        "value": "多字段搜索",
        "slug": "多字段搜索"
      },
      {
        "depth": 4,
        "value": "权重配置",
        "slug": "权重配置"
      },
      {
        "depth": 4,
        "value": "高亮匹配",
        "slug": "高亮匹配"
      },
      {
        "depth": 3,
        "value": "使用场景",
        "slug": "使用场景"
      },
      {
        "depth": 3,
        "value": "优势和限制",
        "slug": "优势和限制"
      },
      {
        "depth": 4,
        "value": "优势",
        "slug": "优势"
      },
      {
        "depth": 4,
        "value": "限制",
        "slug": "限制"
      },
      {
        "depth": 3,
        "value": "总结",
        "slug": "总结"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/about",
    "slug": "about",
    "segments": [
      "about"
    ],
    "filePath": "docs/zh/about/index.mdx",
    "meta": {
      "title": "关于",
      "description": "关于本软件的开发",
      "created_at": "2025-03-21T13:49:29.000Z",
      "updated_at": "2025-03-21T13:49:29.000Z",
      "tags": [
        "about"
      ]
    },
    "order": 99,
    "content": "\n## 本仓库内的文件监视功能\n\n`contentlayer` 会监视本仓库内的文件变化，当文件变化时，会自动更新数据层。这意味着你可以在本地编辑 Markdown 文件，然后在浏览器中查看更改。 但是 对于 `turbopack` 可能无效\n\n`next-mdx-remote` 貌似也不行, 同时为了降低本地的内存和计算资源的占用，采取使用 next 直接支持的 `@next/mdx`\n\n```math\ny= x^2\n```",
    "toc": [
      {
        "depth": 2,
        "value": "本仓库内的文件监视功能",
        "slug": "本仓库内的文件监视功能"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/dev/test",
    "slug": "dev/test",
    "segments": [
      "dev",
      "test"
    ],
    "filePath": "docs/zh/dev/test.mdx",
    "meta": {
      "title": "测试",
      "description": "用于测试 mdx",
      "created_at": "2025-03-22T00:42:34.000Z",
      "updated_at": "2025-03-22T00:42:34.000Z",
      "tags": [
        "test"
      ]
    },
    "order": 99,
    "content": "\n> [!NOTE] 提示\n> 本来页面用户测试显示效果\n\n## markdown\n\n### 标题\n\n#### 四级标题1\n\n### 三级 标题\n\n#### 四级 标题2\n\n##### 五级 标题\n\n###### 六级 标题\n\n## GitHub flavored markdown (GFM)\n\n### 三级标题\n\n## 代码块\n\n## 图表\n",
    "toc": [
      {
        "depth": 2,
        "value": "markdown",
        "slug": "markdown"
      },
      {
        "depth": 3,
        "value": "标题",
        "slug": "标题"
      },
      {
        "depth": 4,
        "value": "四级标题1",
        "slug": "四级标题1"
      },
      {
        "depth": 3,
        "value": "三级 标题",
        "slug": "三级-标题"
      },
      {
        "depth": 4,
        "value": "四级 标题2",
        "slug": "四级-标题2"
      },
      {
        "depth": 5,
        "value": "五级 标题",
        "slug": "五级-标题"
      },
      {
        "depth": 6,
        "value": "六级 标题",
        "slug": "六级-标题"
      },
      {
        "depth": 2,
        "value": "GitHub flavored markdown (GFM)",
        "slug": "github-flavored-markdown-(gfm)"
      },
      {
        "depth": 3,
        "value": "三级标题",
        "slug": "三级标题"
      },
      {
        "depth": 2,
        "value": "代码块",
        "slug": "代码块"
      },
      {
        "depth": 2,
        "value": "图表",
        "slug": "图表"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/dev/x",
    "slug": "dev/x",
    "segments": [
      "dev",
      "x"
    ],
    "filePath": "docs/zh/dev/x.mdx",
    "meta": {
      "title": "x",
      "description": "x",
      "created_at": "2025-03-22T19:57:35.000Z",
      "updated_at": "2025-03-22T19:57:35.000Z",
      "tags": []
    },
    "order": 99,
    "content": "\nedu注册\nhttps://cmsweb.csun.edu/psp/CNRPRD/EMPLOYEE/SA/c/NR_SSS_LAUNCH_MENU.NR_SSS_QKADMIT_CMP.GBL?\n学生登录\nhttps://shibboleth.csun.edu/idp/profile/SAML2/Redirect/SSO?execution=e1s2\n.me域名注册\nhttps://nc.me/\nnamecheap登录页面\nhttps://www.namecheap.com/myaccount/login/?ReturnUrl=%2F",
    "toc": []
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/dev/todo",
    "slug": "dev/todo",
    "segments": [
      "dev",
      "todo"
    ],
    "filePath": "docs/zh/dev/todo.mdx",
    "meta": {
      "title": "todo",
      "description": "todo next-mdx-remote",
      "created_at": "2025-03-18T15:19:34Z",
      "updated_at": "2025-03-18T15:19:34Z",
      "tags": [
        "todo",
        "mdx"
      ]
    },
    "order": 99,
    "content": "\n## 基本 \n\n### remark-breaks\n\nremark-breaks\\\nvdvd\n\n### This is a heading\n \nThis is a list in markdown:\n \n- One\n- Two\n- Three\n\n### code block\n\nThis is an array `[1, 2, 3]{:js}` of numbers 1 through 3.\n\nThe name of the function is `getStringLength{:.entity.name.function}`.\n\nThe name of the function is `getStringLength{:.fn}`.\n\n`console{:.var}`, `Mdx{:.cls}`, `JSON{:ts}`\n\n这是 `行内代码块` 示例。\n\n> [!WARNING]\n> 给 codeblock or pre 设置 switcher 属性可能是不太合理的方案\n\n```ts filename=\"x.ts\" {2}#a {3}#b switcher /fibonacci/2-3 title=\"title.ts\"\nimport { useFloating } from \"@floating-ui/react\";\n\n// 斐波那契\nconst fibonacci = (n: number): number => {\n  if (n <= 1) return n\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\nconsole.log(fibonacci(10))\n```\n\n```js  {3,5-7} showLineNumbers switcher caption=\"caption.ts\" /hello/ {10}#g {11}#r\nclass Name {\n  constructor(parameters) {\n    \n  }\n}\n// hello world\nconst hello = async (output:type) => { //这代码怎么不长呀\n  console.log(output)\n}\nconst main = async () => {\n  await hello('hello world')\n}\n\ntry {\n+ await main()\n- main()\n} catch (error) {\n  console.error(error)\n}\n```\n\n```sh {2}#g {3}#r\n# command line\n+pnpm install\n-npm install\n```\n\n### math code block\n\n$y=f(x)$\n\n$$\n\\begin{aligned}\n\\dot{x} & = \\sigma(y-x) \\\\\n\\dot{y} & = \\rho x - y - xz \\\\\n\\dot{z} & = -\\beta z + xy\n\\end{aligned}\n$$\n\n```math\n% 编写公式\n2+2=4\n2\\times 2=4\n```\n\n## github\n\n### Autolink literals\n\nwww.example.com, https://example.com, and contact@example.com.\n\n### Footnote\n\nA note[^1]\n\n[^1]: Big note.\n\n## Strikethrough\n\n~one~ or ~~two~~ tildes.\n\n## Table\n\n**Table**\n\n| 默认 | 左对齐  |  右对齐 |  居中  |\n| - | :- | -: | :-: |\n| 1 | 2 | 3 | 4 |\n|再来 | 一行 | $y=f(x)$ | `dd` |\n\n## Tasklist\n\n> Checkboxes\n\n* [ ] to do\n* [x] done\n\n## Alerts\n\n> [!bug] rehype-callouts bug\n> 换行无效\n\n\n### github\n> [!NOTE]\n> github note \n\n> [!TIP]\n> github tip\n\n> [!IMPORTANT]\n> github important.\n\n> [!WARNING]\n> github a warning.\n\n> [!CAUTION]\n> github caution.\n\n### obsidian\n\nhttps://help.obsidian.md/callouts\n\n> [!INFO]\n> Here's a callout block.\n\n> [!NOTE]- 笔记\n> This is a note.\n\n> [!todo]\n> Lorem ipsum dolor sit amet\n\n> [!tip]- 一个提示\n> This is a **collapsible** callout  \n> To preserve your formatting within a list, make sure to indent non-fenced code blocks by eight spaces.\n\n> [!abstract] obsidian 摘要\n> Lorem ipsum dolor sit amet\n\n> [!faq]\n> obsidian faq  \n> Yes! In a foldable callout, the contents are hidden when the callout is collapsed.  \n> Aliases: `question`, `help`\n\n> [!question] Can callouts be nested?\n> > [!todo] Yes!, they can.\n> > > [!example]  You can even use multiple layers of nesting.\n\n> [!help]\n> Lorem ipsum dolor sit amet\n\n> [!warning]\n> Lorem ipsum dolor sit amet\n>\n> Aliases: `caution`, `attention`\n\n> [!success]-\n> ```md\n> > [!success]\n> > Lorem ipsum dolor sit amet\n> ```\n\n> [!failure]\n> Lorem ipsum dolor sit amet  \n> Aliases: `fail`, `missing`\n\n> [!danger]\n> Lorem ipsum dolor sit amet  \n> Aliases: `error`\n\n> [!bug]\n> Lorem ipsum dolor sit amet\n\n> [!quote]\n> Lorem ipsum dolor sit amet<br/>\n> Aliases: `cite`\n\n> It supports **Markdown**, [[Internal link|Wikilinks]], and [[Embed files|embeds]]!\n> ![[Engelbart.jpg]]\n\n## next\n\n> **Good to know**: This is a single line note.\n \n> **Good to know**:\n>\n> - We also use this format for multi-line notes.\n> - There are sometimes multiple items worth knowing or keeping in mind.\n",
    "toc": [
      {
        "depth": 2,
        "value": "基本",
        "slug": "基本"
      },
      {
        "depth": 3,
        "value": "remark-breaks",
        "slug": "remark-breaks"
      },
      {
        "depth": 3,
        "value": "This is a heading",
        "slug": "this-is-a-heading"
      },
      {
        "depth": 3,
        "value": "code block",
        "slug": "code-block"
      },
      {
        "depth": 3,
        "value": "math code block",
        "slug": "math-code-block"
      },
      {
        "depth": 2,
        "value": "github",
        "slug": "github"
      },
      {
        "depth": 3,
        "value": "Autolink literals",
        "slug": "autolink-literals"
      },
      {
        "depth": 3,
        "value": "Footnote",
        "slug": "footnote"
      },
      {
        "depth": 2,
        "value": "Strikethrough",
        "slug": "strikethrough"
      },
      {
        "depth": 2,
        "value": "Table",
        "slug": "table"
      },
      {
        "depth": 2,
        "value": "Tasklist",
        "slug": "tasklist"
      },
      {
        "depth": 2,
        "value": "Alerts",
        "slug": "alerts"
      },
      {
        "depth": 3,
        "value": "github",
        "slug": "github"
      },
      {
        "depth": 3,
        "value": "obsidian",
        "slug": "obsidian"
      },
      {
        "depth": 2,
        "value": "next",
        "slug": "next"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/dev/data",
    "slug": "dev/data",
    "segments": [
      "dev",
      "data"
    ],
    "filePath": "docs/zh/dev/data.mdx",
    "meta": {
      "title": "数据存储",
      "description": null,
      "created_at": "2025-03-23T14:03:34.000Z",
      "updated_at": "2025-03-23T14:03:34.000Z",
      "tags": [
        "data"
      ]
    },
    "order": 99,
    "content": "以下是使用 Markdown 的 Mermaid 绘图来讲解各种数据存储方式（块存储、文件存储、对象存储）的结构和特点。通过图示化的方式，可以更直观地理解它们的区别和应用场景。\n\n### 块存储（Block Storage）\n\n块存储将数据分成固定大小的块，每个块都有唯一的地址。它不关心数据的内容或文件结构，通常需要文件系统或应用程序来管理数据。\n\n```mermaid\ngraph TD\n    A[块存储] --> B[块1]\n    A --> C[块2]\n    A --> D[块3]\n    A --> E[块4]\n    F[文件系统] -->|组织块| A\n    G[应用程序] -->|访问| F\n```\n\n#### **特点**：\n- 数据以块为单位存储。\n- 需要文件系统（如 NTFS、EXT4, btrfs）来组织数据。\n- 高性能，适合随机读写。\n- 应用场景：数据库、虚拟机磁盘。\n\n### 文件存储（File Storage）\n\n文件存储以文件和目录的形式组织数据，用户通过文件路径访问数据。它是最常见的存储方式，适合需要共享文件的场景。\n\n```mermaid\ngraph TD\n    A[文件存储] --> B[文件1]\n    A --> C[文件2]\n    A --> D[文件3]\n    B -->|存储在| E[块1]\n    B -->|存储在| F[块2]\n    C -->|存储在| G[块3]\n    D -->|存储在| H[块4]\n    I[用户] -->|通过路径访问| A\n```\n\n#### 特点\n- 数据以文件和目录的形式存储。\n- 用户通过文件路径访问数据。\n- 适合文件共享和协作。\n- 应用场景：文件服务器、文档存储。\n\n---\n\n###  对象存储（Object Storage）\n\n对象存储将数据存储为对象，每个对象包含数据本身、元数据和唯一的标识符。用户通过 API 或 URL 访问对象。\n\n```mermaid\ngraph TD\n    A[对象存储] --> B[对象1]\n    A --> C[对象2]\n    A --> D[对象3]\n    B -->|包含| E[数据]\n    B -->|包含| F[元数据]\n    B -->|包含| G[唯一标识符]\n    H[用户] -->|通过 API 或 URL 访问| A\n```\n\n#### 特点\n- 数据以对象的形式存储，每个对象包含数据、元数据和唯一标识符。\n- 用户通过 REST API 或 SDK 访问数据。\n- 高扩展性，适合大规模数据存储。\n- 应用场景：图片、视频、备份数据。\n\n---\n\n### 数据存储方式对比\n\n```mermaid\ngraph TB\n    A[数据存储方式]\n    A --> B[块存储]\n    A --> C[文件存储]\n    A --> D[对象存储]\n\n    B --> E[以块为单位存储]\n    B --> F[需要文件系统管理]\n    B --> G[高性能，适合随机读写]\n    B --> H[应用：数据库、虚拟机磁盘]\n\n    C --> I[以文件和目录形式存储]\n    C --> J[通过路径访问]\n    C --> K[适合文件共享]\n    C --> L[应用：文件服务器、文档存储]\n\n    D --> M[以对象形式存储]\n    D --> N[包含数据、元数据和标识符]\n    D --> O[通过 API 或 URL 访问]\n    D --> P[高扩展性，适合大规模数据]\n    D --> Q[应用：图片、视频、备份]\n```\n\n---\n\n### 总结\n\n| 特性               | 块存储                          | 文件存储                          | 对象存储                          |\n|--------------------|----------------------------------|------------------------------------|------------------------------------|\n| **存储单位**       | 块                              | 文件和目录                        | 对象                              |\n| **访问方式**       | 块号                            | 文件路径                          | API 或 URL                        |\n| **管理方式**       | 需要文件系统                    | 文件系统直接管理                  | 元数据和标识符                    |\n| **性能**           | 高性能，适合随机读写            | 性能较低，适合顺序读写            | 高扩展性，适合大规模数据存储       |\n| **应用场景**       | 数据库、虚拟机磁盘              | 文件共享、文档存储                | 图片、视频、备份数据              |\n\n",
    "toc": [
      {
        "depth": 3,
        "value": "块存储（Block Storage）",
        "slug": "块存储（block-storage）"
      },
      {
        "depth": 4,
        "value": "特点：",
        "slug": "特点："
      },
      {
        "depth": 3,
        "value": "文件存储（File Storage）",
        "slug": "文件存储（file-storage）"
      },
      {
        "depth": 4,
        "value": "特点",
        "slug": "特点"
      },
      {
        "depth": 3,
        "value": "对象存储（Object Storage）",
        "slug": "对象存储（object-storage）"
      },
      {
        "depth": 4,
        "value": "特点",
        "slug": "特点"
      },
      {
        "depth": 3,
        "value": "数据存储方式对比",
        "slug": "数据存储方式对比"
      },
      {
        "depth": 3,
        "value": "总结",
        "slug": "总结"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/html",
    "slug": "html",
    "segments": [
      "html"
    ],
    "filePath": "docs/zh/html/index.mdx",
    "meta": {
      "title": "html",
      "description": "全称 HyperText Markup Language，是一种用于创建网页的标准标记语言, 用于描述网页的结构和内容。",
      "created_at": "2025-03-22T02:26:21.000Z",
      "updated_at": "2025-03-22T02:26:21.000Z",
      "tags": [
        "html"
      ]
    },
    "order": 99,
    "content": "\n## list\n\nhttps://www.heroui.com/docs/components/listbox\n\n```tsx /items={toc}/ /(item) =>/\nimport {\n  Listbox,\n  ListboxSection,\n  ListboxItem\n} from \"@heroui/listbox\";\n\n<Listbox className='gap-2' aria-label=\"Dynamic Actions\" items={toc} onAction={(key) => {}}>\n{(item) => (\n  <ListboxItem\n    key={item.slug}\n    className={`${item.depth===3 ?'pl-3':''} ${item.depth===4 ?'pl-6':''} ${item.depth===5 ?'pl-9':''} ${item.depth===6 ?'pl-12':''} h-5 !bg-transparent `}\n  >\n    <motion.a className={clsx(\n      \"text-muted-foreground hover:text-primary-foreground\",\n      {\n        \"text-primary font-bold\": isClient && activeSlug === item.slug,\n      }\n    )}\n      href={`#${item.slug}`}\n    >\n          {item.value}\n    </motion.a>\n  </ListboxItem>\n  )}\n</Listbox>\n```\n\n可能有一些优化机制导致不适合做文章的 TOC，因为不方便实现自动监视滚动位置来修改 list 中元素 的样式\n\n改用 `Array.map(){:ts}` 来遍历比较合适\n\n```tsx {2}#b\n<ul>\n  {toc.map((item, index) => <li key={index}>\n    <Link className={clsx(\n      `text-muted-foreground hover:text-primary-foreground ${item.depth===3 ?'pl-3':''} ${item.depth===4 ?'pl-6':''} ${item.depth===5 ?'pl-9':''} ${item.depth===6 ?'pl-12':''} h-5 `,\n      {\n        \"text-primary font-bold\": isClient && activeSlug === item.slug,\n      }\n    )}\n      href={`#${item.slug}`}\n    >\n      item.value}\n    </Link>\n  </li>)}\n</ul>\n```",
    "toc": [
      {
        "depth": 2,
        "value": "list",
        "slug": "list"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/alg/blog",
    "slug": "alg/blog",
    "segments": [
      "alg",
      "blog"
    ],
    "filePath": "docs/zh/alg/blog.mdx",
    "meta": {
      "title": "日志",
      "description": null,
      "created_at": "2025-03-22T06:07:24.000Z",
      "updated_at": "2025-03-22T06:07:24.000Z",
      "tags": [
        "alg",
        "log",
        "blog"
      ]
    },
    "order": 99,
    "content": "\n### 1. **算法文档（`docs`）**\n- **内容**：\n  - 详细描述算法的原理、实现步骤、复杂度分析等。\n  - 适合作为参考资料或学习材料。\n  - 结构化、系统化，便于长期维护和扩展。\n\n- **适合放入 `docs` 的内容**：\n  - 算法的理论基础（如动态规划、贪心算法、分治法等）。\n  - 算法的实现细节（如伪代码、代码示例）。\n  - 算法的时间复杂度和空间复杂度分析。\n  - 常见问题和解决方案。\n\n- **示例目录结构**：\n  ```\n  docs/\n  ├── sorting/\n  │   ├── bubble-sort.md\n  │   ├── quick-sort.md\n  │   └── merge-sort.md\n  ├── graph/\n  │   ├── dijkstra.md\n  │   ├── floyd-warshall.md\n  │   └── kruskal.md\n  └── dynamic-programming/\n      ├── knapsack.md\n      ├── longest-common-subsequence.md\n      └── matrix-chain-multiplication.md\n  ```\n\n---\n\n### 2. **算法日志（`blog`）**\n- **内容**：\n  - 记录你在学习、实现或优化算法过程中的思考、问题和解决方案。\n  - 更加个人化，适合分享经验和心得。\n  - 可能包含一些非正式的内容，如调试过程、踩坑记录等。\n\n- **适合放入 `blog` 的内容**：\n  - 学习某个算法时的心得体会。\n  - 实现算法时遇到的困难和解决方法。\n  - 对某个算法的优化过程。\n  - 算法在实际项目中的应用案例。\n\n- **示例目录结构**：\n  ```\n  blog/\n  ├── 2025-03-22-why-i-love-dijkstra.md\n  ├── 2025-03-15-optimizing-quick-sort.md\n  ├── 2025-03-10-debugging-knapsack.md\n  └── 2025-03-05-how-i-learned-dynamic-programming.md\n  ```\n\n---\n\n### 3. **两者的区别**\n| **方面**       | **算法文档（`docs`）**                          | **算法日志（`blog`）**                          |\n|----------------|-----------------------------------------------|-----------------------------------------------|\n| **目的**       | 系统化记录算法知识，作为参考资料。               | 记录个人学习和实践过程，分享经验和心得。         |\n| **风格**       | 正式、结构化、面向读者。                        | 非正式、个人化、面向分享。                     |\n| **内容**       | 理论、实现、复杂度分析等。                       | 学习过程、调试记录、优化心得等。                |\n| **读者**       | 需要学习或参考算法的开发者。                     | 对你的学习过程或经验感兴趣的读者。              |\n\n---\n\n### 4. **如何结合使用**\n- 在 `docs` 中提供系统化的算法知识。\n- 在 `blog` 中分享你在学习或实现这些算法时的个人经验。\n- 可以在 `blog` 中链接到相关的 `docs`，为读者提供更深入的参考资料。\n\n---\n\n### 5. **工具推荐**\n如果你使用静态网站生成器（如 [Docusaurus](https://docusaurus.io/) 或 [Hugo](https://gohugo.io/)），可以轻松地将 `docs` 和 `blog` 分开管理：\n- `docs` 用于存放文档。\n- `blog` 用于存放日志。\n\n---\n\n### 总结\n- **算法文档**：放到 `docs` 中，作为系统化的参考资料。\n- **算法日志**：放到 `blog` 中，记录个人学习和实践过程。\n\n这种组织方式清晰且易于维护，适合长期使用。如果你有更多需求或问题，请随时告诉我！",
    "toc": [
      {
        "depth": 3,
        "value": "1. 算法文档（docs）",
        "slug": "1.-算法文档（docs）"
      },
      {
        "depth": 3,
        "value": "2. 算法日志（blog）",
        "slug": "2.-算法日志（blog）"
      },
      {
        "depth": 3,
        "value": "3. 两者的区别",
        "slug": "3.-两者的区别"
      },
      {
        "depth": 3,
        "value": "4. 如何结合使用",
        "slug": "4.-如何结合使用"
      },
      {
        "depth": 3,
        "value": "5. 工具推荐",
        "slug": "5.-工具推荐"
      },
      {
        "depth": 3,
        "value": "总结",
        "slug": "总结"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/alg",
    "slug": "alg",
    "segments": [
      "alg"
    ],
    "filePath": "docs/zh/alg/index.mdx",
    "meta": {
      "title": "算法",
      "description": "alg 即 algorithm",
      "created_at": "2025-03-22T05:35:44.000Z",
      "updated_at": "2025-03-22T05:35:44.000Z",
      "tags": [
        "alg"
      ]
    },
    "order": 99,
    "content": "\n## 基础: 算法入门\n\n[LeetCode 1. 两数之和](https://leetcode-cn.com/problems/two-sum/description/) 是一个非常经典的问题，也是算法学习的入门题目。这个问题可以通过暴力枚举、哈希表等多种方法解决，是一个很好的起点。\n\n> [!NOTE]- LeetCode 1. 两数之和 题目详情\n> 给定一个整数数组 `nums` 和一个整数目标值 `target` ,请你在该数组中找出 和为目标值 `target`  的那 两个 整数，并返回它们的数组下标。 <br/>\n> 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。<br/>\n> 你可以按任意顺序返回答案。<br/>\n>\n> **示例 1:**<br/>\n> **输入:** `nums = [2,7,11,15], target = 9{:py}`<br/>\n> **输出:** `[0,1]{:py}`<br/>\n> **解释:** 因为 `nums[0] + nums[1] == 9{:py}` ，返回 `[0, 1]{:py}` 。<br/>\n>\n> **示例 2:**<br/>\n> **输入:** `nums = [3,2,4], target = 6{:py}`<br/>\n> **输出:** `[1,2]{:py}`<br/>\n>\n> **示例 3:**<br/>\n> **输入:** `nums = [3,3], target = 6{:py}`<br/>\n> **输出:** `[0,1]{:py}`<br/>\n>\n> **提示:**\n> - $2 \\leq nums.length \\leq 10^4$\n> - $-10^9 \\leq nums[i] \\leq 10^9$\n> - $-10^9 \\leq target \\leq 10^9$\n> - 只会存在一个有效答案<br/>\n>\n> **进阶:** 你可以想出一个时间复杂度小于 $O(n^2)$ 的算法吗？\n><br/>\n> 如果不会解决这个问题，可以查看 [穷举法#例题](./alg/enum#例题) 中的解法。\n\n### 数组和穷举\n- 掌握[数组](./alg/array)的基本操作（遍历、插入、删除）\n- 学习[穷举法](./alg/enum)解决问题\n\n### 基础数据结构\n\n- **目标**: 理解常见数据结构的基本操作和应用场景\n- **学习内容**:\n  1. 数组和链表:\n    - 动态数组, 单链表, 双链表\n    - 常见操作: 插入、删除、查找\n    - [穷举法](/alg/enum) (Brute Force)\n  2. 栈和队列:\n    - 栈 (Stack) (LIFO) 先进后出\n    - 队列 (Queue) (FIFO) 先进先出\n    - 双端队列 (Deque)\n  3. 哈希表:\n    - 哈希函数, 哈希冲突\n    - `dict`, `set`\n  4. 字符串:\n    - 字符串基本操作\n    - 字符串匹配问题\n- 推荐题目:\n  - [LeetCode 1. 两数之和](https://leetcode-cn.com/problems/two-sum/description/) (哈希表， 穷举)\n  - [LeetCode 21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/description/) (链表)\n  - [LeetCode 206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/description/) (链表)\n  - [LeetCode 217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/description/) (哈希表)\n  - [LeetCode 242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/description/) (哈希表, 计数)\n  - [LeetCode 215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/) (堆)\n  - [LeetCode 20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/description/) (栈)\n  - [LeetCode 232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/description/) (栈, 队列)\n  - [LeetCode 155. 最小栈](https://leetcode-cn.com/problems/min-stack/description/) (栈)\n  - [LeetCode 641. 设计循环双端队列](https://leetcode-cn.com/problems/design-circular-deque/description/) (双端队列)\n  - [LeetCode 344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/description/) (字符串)\n\n### 排序\n- **目标**: 掌握常见排序算法的思想和实现\n- **学习内容**:\n  1. 冒泡排序, 选择排序, 插入排序 (O(n^2))\n  2. 快速排序, 归并排序, 堆排序 (O(nlogn))\n  3. 计数排序, 基数排序, 桶排序 (O(n))\n- **推荐题目**:\n  - [LeetCode 912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/description/) (排序)\n  - [LeetCode 56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/description/) (排序)\n  - [LeetCode 75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/description/) (双指针, 排序思想)\n  - [LeetCode 179. 最大数](https://leetcode-cn.com/problems/largest-number/description/) (排序)\n  - [LeetCode 215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/) (排序)\n\n## 进阶: 算法思想与应用\n\n### 贪心算法\n- **目标**: 理解贪心算法的思想和应用场景\n- **学习内容**:\n  1. 贪心算法基本思想\n  2. 贪心选择性质和最优子结构\n  3. 贪心算法的正确性证明\n  4. 贪心算法的应用: 区间调度, 活动选择, 最优装载, 最小生成树(Kruskal 算法)\n- **推荐题目**:\n  - [LeetCode 406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/description/) (贪心, 插入排序思想)\n  - [LeetCode 435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/description/) (贪心, 区间调度)\n  - [LeetCode 452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/description/) (贪心, 区间问题)\n  - [LeetCode 763. 划分字母区间](https://leetcode-cn.com/problems/partition-labels/description/) (贪心)\n  - [LeetCode 134. 加油站](https://leetcode-cn.com/problems/gas-station/description/) (贪心)\n\n### 二分查找\n- **目标**: 掌握二分查找的思想和变种\n- **学习内容**:\n  1. 标准二分查找\n  2. 二分查找的变种（如查找左边界、右边界）, 二分查找变形问题\n  3. 二分查找的应用: 有序数组查找, 最优解的范围搜索, 查找边界, 旋转数组查找\n- **推荐题目**:\n  - [LeetCode 704. 二分查找](https://leetcode-cn.com/problems/binary-search/description/) (基础二分查找)\n  - [LeetCode 69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/description/) (二分查找)\n  - [LeetCode 34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/) (变种二分)\n  - [LeetCode 153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/) (二分查找)\n  - [LeetCode 33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/) (二分查找)\n  - [LeetCode 4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/description/) (二分查找)\n\n### 前缀和与差分\n- **目标**: 掌握前缀和和差分的思想, 解决区间和问题\n- **学习内容**:\n  1. 前缀和的构建与应用\n  2. 差分数组的构建与应用\n  3. 二维前缀和\n- **推荐题目**:\n  - [LeetCode 560. 和为 K 的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/description/) (前缀和, 哈希)\n  - [LeetCode 238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/descriptqinzhuijiaon/) (前缀积)\n  - [LeetCode 724. 寻找数组的中心索引](https://leetcode-cn.com/problems/find-pivot-index/description/) (前缀和)\n  - [LeetCode 974. 和可被 K 整除的子数组](https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/description/) (前缀和)\n  - [LeetCode 525. 连续数组](https://leetcode-cn.com/problems/contiguous-array/description/) (前缀和)\n  - [LeetCode 303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/description/) (前缀和)\n  - [LeetCode 304. 二维区域和检索 - 矩阵不可变](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/description/) (二维前缀和)\n\n### 双指针与滑动窗口\n- **目标**: 掌握双指针和滑动窗口的思想, 解决区间和问题\n- **学习内容**:\n  1. 双指针的基本思想\n  2. 滑动窗口的扩展与收缩\n  3. 双指针和滑动窗口的应用: 两数之和, 三数之和, 最长无重复子串, 最小覆盖子串\n- **推荐题目**:\n\n  - [LeetCode 3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/) (滑动窗口)\n  - [LeetCode 344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/description/) (双指针)\n  - [LeetCode 167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/) (双指针)\n  - [LeetCode 15. 三数之和](https://leetcode-cn.com/problems/3sum/description/) (双指针)\n  - [LeetCode 11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/description/) (双指针)\n  - [LeetCode 76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/description/) (滑动窗口)\n  - [LeetCode 209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/description/) (滑动窗口)\n  - [LeetCode 438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/description/) (滑动窗口)\n  - [LeetCode 567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/description/) (滑动窗口)\n  - [LeetCode 904. 水果成篮](https://leetcode-cn.com/problems/fruit-into-baskets/description/) (滑动窗口)\n### 动态规划 (DP)\n- **目标**: 掌握动态规划的思想和常见问题\n- **学习内容**:\n  1. 动态规划的基本思想\n  2. 动态规划的状态定义和状态转移方程\n  3. 一维 DP: 斐波那契数列, 背包问题, 最长递增子序列\n  4. 二维 DP: 最长公共子序列, 编辑距离, 最大正方形\n  5. 状态压缩 DP\n- **推荐题目**:\n  - [LeetCode 70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/description/) (基础 DP, 斐波那契数列)\n  - [LeetCode 322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/description/) (完全背包)\n  - [LeetCode 198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/description/) (背包问题)\n  - [LeetCode 300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/description/) (最长递增子序列)\n  - [LeetCode 1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/description/) (二维 DP)\n  - [LeetCode 72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/description/) (编辑距离)\n  - [LeetCode 221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/description/) (最大正方形)\n  - [LeetCode 516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/description/) (最长回文子序列)\n  - [LeetCode 647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/description/) (回文子串)\n  - [LeetCode 10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/description/) (正则表达式)\n  - [LeetCode 44. 通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/description/) (通配符)\n  - [LeetCode 221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/description/) (最大正方形)\n  - [LeetCode 85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/description/) (最大矩形)\n  - [LeetCode 516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/description/) (最长回文子序列)\n## 高级: 复杂算法与优化\n### 分治与递归\n- **目标**: 掌握分治和递归的思想\n- **学习内容**:\n  1. 分治的基本思想\n  2. 分治的应用: 归并排序, 快速排序, 汉诺塔\n  3. 递归的实现与优化（如尾递归）\n  4. 递归的应用: 斐波那契数列, 汉诺塔, 二叉树遍历\n- **推荐题目**:\n  - [LeetCode 53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/description/) (分治)\n  - [LeetCode 169. 多数元素](https://leetcode-cn.com/problems/majority-element/description/) (分治)\n  - [LeetCode 50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/description/) (分治)\n  - [LeetCode 241. 为运算表达式设计优先级](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/description/) (分治)\n  - [LeetCode 95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/description/) (递归)\n  - [LeetCode 98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/description/) (递归)\n  - [LeetCode 104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/) (递归)\n  - [LeetCode 236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/description/) (递归)\n  - [LeetCode 297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/description/) (递归)\n  - [LeetCode 226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/description/) (递归)\n  - [LeetCode 114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/description/) (递归)\n  - [LeetCode 654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/description/) (递归)\n  - [LeetCode 105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/) (递归)\n  - [LeetCode 106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/) (递归)\n  - [LeetCode 889. 根据前序和后序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/description/) (递归)\n\n### 图论算法\n- **目标**: 掌握图的表示和常见算法\n- **学习内容**:\n  1. 图的表示: 邻接矩阵, 邻接表\n  2. 图的遍历: 深度优先搜索 (DFS), 广度优先搜索 (BFS)\n  3. 最短路径: Dijkstra 算法, Floyd 算法\n  4. 最小生成树: Prim 算法, Kruskal 算法\n  5. 拓扑排序: Kahn 算法, DFS 算法\n- **推荐题目**:\n  - [LeetCode 130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/description/) (DFS)\n  - [LeetCode 127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/description/) (BFS)\n  - [LeetCode 133. 克隆图](https://leetcode-cn.com/problems/clone-graph/description/) (图的遍历)\n  - [LeetCode 207. 课程表](https://leetcode-cn.com/problems/course-schedule/description/) (拓扑排序)\n  - [LeetCode 210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/description/) (拓扑排序)\n  - [LeetCode 399. 除法求值](https://leetcode-cn.com/problems/evaluate-division/description/) (DFS)\n  - [LeetCode 785. 判断二分图](https://leetcode-cn.com/problems/is-graph-bipartite/description/) (图的染色, DFS)\n  - [LeetCode 743. 网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/description/) (最短路径, Dijkstra)\n  - [LeetCode 787. K 站中转内最便宜的航班](https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/description/) (Dijkstra)\n### 高级数据结构\n- **目标**: 掌握高级数据结构的思想和应用\n- **学习内容**:\n  1. 并查集 (Union Find)\n  2. 堆 (Heap)\n  3. 线段树 (Segment Tree)\n  4. 树状数组 (Fenwick Tree)\n  5. 字典树 (Trie)\n- **推荐题目**:\n  - [LeetCode 200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/description/) (并查集)\n  - [LeetCode 305. 岛屿数量 II](https://leetcode-cn.com/problems/number-of-islands-ii/description/) (并查集)\n  - [LeetCode 307. 区域和检索 - 数组可修改](https://leetcode-cn.com/problems/range-sum-query-mutable/description/) (树状数组\\线段树)\n  - [LeetCode 399. 除法求值](https://leetcode-cn.com/problems/evaluate-division/description/) (并查集)\n  - [LeetCode 547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/description/) (并查集)\n\n",
    "toc": [
      {
        "depth": 2,
        "value": "基础: 算法入门",
        "slug": "基础:-算法入门"
      },
      {
        "depth": 3,
        "value": "数组和穷举",
        "slug": "数组和穷举"
      },
      {
        "depth": 3,
        "value": "基础数据结构",
        "slug": "基础数据结构"
      },
      {
        "depth": 3,
        "value": "排序",
        "slug": "排序"
      },
      {
        "depth": 2,
        "value": "进阶: 算法思想与应用",
        "slug": "进阶:-算法思想与应用"
      },
      {
        "depth": 3,
        "value": "贪心算法",
        "slug": "贪心算法"
      },
      {
        "depth": 3,
        "value": "二分查找",
        "slug": "二分查找"
      },
      {
        "depth": 3,
        "value": "前缀和与差分",
        "slug": "前缀和与差分"
      },
      {
        "depth": 3,
        "value": "双指针与滑动窗口",
        "slug": "双指针与滑动窗口"
      },
      {
        "depth": 3,
        "value": "动态规划 (DP)",
        "slug": "动态规划-(dp)"
      },
      {
        "depth": 2,
        "value": "高级: 复杂算法与优化",
        "slug": "高级:-复杂算法与优化"
      },
      {
        "depth": 3,
        "value": "分治与递归",
        "slug": "分治与递归"
      },
      {
        "depth": 3,
        "value": "图论算法",
        "slug": "图论算法"
      },
      {
        "depth": 3,
        "value": "高级数据结构",
        "slug": "高级数据结构"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/alg/todo",
    "slug": "alg/todo",
    "segments": [
      "alg",
      "todo"
    ],
    "filePath": "docs/zh/alg/todo.mdx",
    "meta": {
      "title": "todo",
      "description": null,
      "created_at": "2025-03-25T07:41:55.000Z",
      "updated_at": "2025-03-25T07:41:55.000Z",
      "tags": []
    },
    "order": 99,
    "content": "### 问题描述\n\n小蓝有一张支票，上面记录了一些数字。小蓝不小心打翻了墨水导致了支票上的一个数字被污染了，现在小蓝想通过剩下的数字来推断出那个被污染的数字。\n\n设支票上被污染的数字为 x ，没有被污染的数字共有 nn 个（设为 d1,d2,…,dn），小蓝知道支票如果没有错误的话，上面没有被污染的数字应当是 x 除了 1 和 x 之外的其他所有因数，但是他无法确定支票是否错误。支票错误的情况有以下几种：\n\n- 支票没有被污染的数字中混入了不是 x 的因数的数字；\n- 支票没有被污染的数字中缺失或重复 x 的部分因数。\n\n小蓝想请你帮助他判断支票是否没有错误，若没有错误，小蓝希望你能帮他求出支票上被污染的数字。\n### 输入格式\n\n第一行包含一个整数 n ，表示没有被污染的数字的个数。\n\n第二行包含 n 个整数 d1,d2,…,dn​ ，表示支票上的数字。\n### 输出格式\n若支票没有错误，那么输出支票上被污染的数字；反之，若支票错误，被污染的数字不存在，则输出 −1 。\n### 样例输入\n```\n8\n8 2 12 6 4 24 16 3\n```\n### 样例输出\n```\n48\n```\n### 评测数据规模\n\n对于所有评测数据， $1≤n≤300$ , $2≤d_i≤10^6$\n### 运行限制\n|语言 |\t最大运行时间 |\t最大运行内存 |\n|---|---|---|\n|C |\t4s |\t256M |\n|C++ |\t4s |\t256M |\n|Python3 |\t6s |\t256M |\n|Java |\t5s |\t256M |\n|PyPy3 |\t6s |\t256M |\n|Go |\t6s |\t256M |\n|JavaScript |\t6s |\t256M |\n\n难度: 简单   标签: 思维, 数学",
    "toc": [
      {
        "depth": 3,
        "value": "问题描述",
        "slug": "问题描述"
      },
      {
        "depth": 3,
        "value": "输入格式",
        "slug": "输入格式"
      },
      {
        "depth": 3,
        "value": "输出格式",
        "slug": "输出格式"
      },
      {
        "depth": 3,
        "value": "样例输入",
        "slug": "样例输入"
      },
      {
        "depth": 3,
        "value": "样例输出",
        "slug": "样例输出"
      },
      {
        "depth": 3,
        "value": "评测数据规模",
        "slug": "评测数据规模"
      },
      {
        "depth": 3,
        "value": "运行限制",
        "slug": "运行限制"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/alg/array",
    "slug": "alg/array",
    "segments": [
      "alg",
      "array"
    ],
    "filePath": "docs/zh/alg/array.mdx",
    "meta": {
      "title": "线性结构",
      "description": null,
      "created_at": "2025-03-22T15:50:04.000Z",
      "updated_at": "2025-03-22T15:50:04.000Z",
      "tags": [
        "Array"
      ]
    },
    "order": 99,
    "content": "\n\n| 操作  | 动态数组  | 链表  | 栈   | 队列  | 双端队列 |\n|------|----------|------|------|------|---------|\n| 随机访问 | O(1) | O(n) | 不支持 | 不支持 | 不支持  |\n| 末尾插入/删除 | O(1)* | O(1) | O(1) | O(1), 仅插入 | O(1) |\n| 队首插入/删除 | O(n) | O(1)| 不支持| O(1), 仅删除  | O(1) |\n| 两端插入/删除 | O(n) | O(1) | 不支持 | 不支持 | O(1) |\n\n> [!tip] 动态数组和链表是通用的数据结构，而栈、队列和双端队列是针对特定场景优化的抽象。\n\n```py\n# 可迭代对象: 容器, 生成器, 迭代器\n# 容器可以这样判空, 不过生成器和迭代器不能这样判空\nif not container:\n   print('empty')\n```\n\n## 数组 Array\n\n**Python 的 `list` 是动态数组**。虽然在 Python 中我们通常将 `list` 视为一个通用的容器，但其底层实现实际上是基于 **动态数组** 的。以下是详细的解释：\n\n### 什么是动态数组？\n动态数组是一种可以在运行时动态调整大小的数组。与静态数组不同，动态数组的容量可以根据需要扩展或收缩。\n\n- **特点**：\n  - 支持随机访问（时间复杂度 O(1)）。\n  - 当容量不足时，会分配更大的内存空间，并将现有元素复制到新数组中。\n  - 插入和删除操作的时间复杂度取决于位置：\n    - 在末尾插入：摊销时间复杂度为 O(1)。\n    - 在中间或开头插入/删除：时间复杂度为 O(n)。\n\n### Python `list`\nPython 的 `list` 是基于 **动态数组** 实现的，其底层使用了 C 语言的数组（在 [CPython](https://github.com/python/cpython) 中实现）。\n\n#### 特点\n1. **动态扩展**：\n   - 当 `list` 的容量不足时，Python 会自动分配更大的内存空间。\n   - 新的容量通常是当前容量的 **1.125 倍**（即增长因子为 9/8），以减少频繁的内存分配操作。\n\n2. **连续内存**：\n   - Python 的 `list` 在内存中是连续存储的，因此支持快速的随机访问（O(1)）。\n\n3. **支持多种数据类型**：\n   - Python 的 `list` 是一个通用容器，可以存储任意类型的对象（包括混合类型）。\n\n4. **插入和删除**：\n   - 在末尾插入元素效率最高（摊销 O(1)）。\n   - 在中间或开头插入/删除元素需要移动其他元素，时间复杂度为 O(n)。\n\n### 动态扩展的示例\n\n以下代码展示了 Python `list` 的动态扩展行为：\n\n```python\nimport sys\n\n# 创建一个空列表\nlst = []\nprint(f\"初始容量: {sys.getsizeof(lst)} 字节\")\n\n# 不断添加元素，观察内存变化\nfor i in range(20):\n    lst.append(i)\n    print(f\"添加元素 {i} 后，容量: {sys.getsizeof(lst)} 字节\")\n```\n\n#### **输出示例**：\n```plaintext\n初始容量: 56 字节\n添加元素 0 后，容量: 88 字节\n添加元素 1 后，容量: 88 字节\n添加元素 2 后，容量: 88 字节\n添加元素 3 后，容量: 88 字节\n添加元素 4 后，容量: 120 字节\n添加元素 5 后，容量: 120 字节\n添加元素 6 后，容量: 120 字节\n添加元素 7 后，容量: 120 字节\n添加元素 8 后，容量: 184 字节\n...\n```\n\n可以看到，`list` 的容量会在需要时动态扩展，而不是每次添加元素都重新分配内存。\n\n\n### Python `list` 的操作复杂度\n\n| 操作                | 时间复杂度 | 说明                                                                 |\n|---------------------|------------|----------------------------------------------------------------------|\n| 随机访问（`lst[i]`） | O(1)       | 由于底层是连续内存，支持快速随机访问。                               |\n| 末尾插入（`append`） | O(1)*      | 摊销时间复杂度为 O(1)，扩展时需要重新分配内存，代价较高。             |\n| 中间插入/删除        | O(n)       | 需要移动其他元素。                                                   |\n| 遍历  | O(n)       | 遍历所有元素的时间复杂度为 O(n)。                                    |\n| 查找元素（`in`） | O(n)       | 需要遍历整个列表，最坏情况下时间复杂度为 O(n)。                       |\n\n### 动态数组与链表的对比\n\n| 特性               | 动态数组（Python `list`） | 链表（`LinkedList`）          |\n|--------------------|---------------------------|--------------------------------|\n| 内存分配           | 连续内存                  | 非连续内存                     |\n| 随机访问           | O(1)                      | O(n)                          |\n| 插入/删除（末尾）   | O(1)*                     | O(1)                          |\n| 插入/删除（中间）   | O(n)                      | O(1)                          |\n| 内存使用效率       | 高                        | 较低（需要额外存储指针）       |\n\n### 总结\n\n- **Python 的 `list` 是动态数组**，底层基于连续内存实现，支持快速随机访问和动态扩展。\n- **动态扩展**：\n  - 当容量不足时，`list` 会分配更大的内存空间，并将现有元素复制到新数组中。\n  - 这种扩展机制使得 `list.append` 的摊销时间复杂度为 O(1)。\n- **适用场景**：\n  - 如果需要频繁随机访问或在末尾插入元素，`list` 是一个高效的选择。\n  - 如果需要频繁在中间或开头插入/删除元素，可以考虑使用链表（`LinkedList`）。\n\n```py\n# 翻转\narr = [1, 2, 3, 4]\narr[::-1]  # [4, 3, 2, 1]\n```\n\n### 素数\n\n- 素数的定义：大于 1 且只能被 1 和自身整除的整数。\n- 非素数（合数）的定义。\n\n\n#### 生成素数\n\n##### 埃拉托色尼筛法：\n标记一定范围内的所有非素数，剩下的就是素数。\n\n代码示例：\n\n```py\ndef sieve_of_eratosthenes(n):\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1): # i*i <= n\n        if is_prime[i]: # e.g if 2 是素数\n            for j in range(i * i, n + 1, i): # 那么 2*2, 2*3, 2*4... 都不是素数\n                is_prime[j] = False\n    return [x for x in range(2, n + 1) if is_prime[x]] # 这里从 0开始也行, 因为我们把索引为素数的位置标记为了 True\nprimes = sieve_of_eratosthenes(20)\nprint(primes)  # [2, 3, 5, 7, 11, 13, 17, 19]\n```\n\n###### 时间复杂度\n\n```math\nO(\\sum_{k=1}^{\\pi(n)} \\frac{n}{p_k}) = O(n\\sum_{k=1}^{\\pi(n)} \\frac{1}{p_k}) = O(n \\log \\log n) \\quad (Mertens第二定理)\n```\n切片优化\n```py\ndef sieve_of_eratosthenes(n):\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1): # i*i <= n\n        if is_prime[i]: # e.g if 2 是素数\n            is_prime[i*i:n+1:i] = [False] * len(is_prime[i*i:n+1:i]) # 那么 2*2, 2*3, 2*4... 都不是素数\n    return [x for x in range(2, n + 1) if is_prime[x]] # 这里从 0开始也行, 因为我们把索引为素数的位置标记为了 True\n# 一行实现, 不用看\ndef sieve_of_eratosthenes(n):\n    return [x for x in range(2, n + 1) if all(x % i != 0 for i in range(2, int(x**0.5) + 1))]\n```\n下面这两个东西相等吗?\n$$\n\\left\\lfloor\\frac{n+1- i^2}{i}\\right\\rfloor =  \\left\\lfloor \\frac{n-i^2}{i+1}  \\right\\rfloor \\quad ???\n$$\n因为我看到有人写\n```py\ndef sieve_of_eratosthenes(n):\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1): # i*i <= n\n        if is_prime[i]: # e.g if 2 是素数\n            is_prime[i*i::i] = [False] * ((n - i*i) // i + 1)\n    return [x for x in range(2, n + 1) if is_prime[x]] \n```\n\ngreedyAlgorithms\n\n## 链表 Linked List\n\n## 栈 Stack\n\n后进先出 (LIFO) 的数据结构，表示一种“递归”或“回溯”的逻辑.  \n- **函数调用栈**：每次函数调用都会将当前函数的状态压入栈，函数返回时从栈中弹出。\n- **括号匹配**：使用栈来检查括号是否匹配。\n- **深度优先搜索 (DFS)**：使用栈来模拟递归过程。\n- **表达式求值**：如中缀表达式转后缀表达式、后缀表达式求值。\n\npython 没有专门提供 `stack` , 建议用 `list` 来模拟栈的操作, 因为需要的操作的时间复杂度差不多\n\n```py\n# 创建栈\nstack = []\nstack.append(1)  # 栈变为 [1]\nstack.append(2)  # 栈变为 [1, 2]\nx = stack.pop()  # 弹出栈顶元素 2，栈变为 [1], x = 2\n# 获取栈顶元素\nprint(stack[-1])  # 输出 1\n```\n\n### 队列 Queue\n先进先出 (FIFO) 的数据结构, 表示一种 “排队” 或 “顺序处理” 的逻辑. \\\n- **任务调度**：如操作系统中的任务队列。\n- **广度优先搜索 (BFS)**：使用队列来按层次遍历图或树。\n- **数据流处理**：按顺序处理数据流中的元素。\n\npython 提供了 `collections.deque` , 这是一个双端队列 将其当作队列使用即可\n\n```py\nfrom collections import deque\n\n# 创建队列\nqueue = deque()\n\n# 尾部插入\nqueue.append(1)  # 队列变为 [1]\nqueue.append(2)  # 队列变为 [1, 2]\n# 头部插入\nqueue.appendleft(3)  # 队列变为 [3, 1, 2]\n\n# 头部删除\nqueue.popleft()  # 删除队首元素，队列变为 [1, 2]\n# 尾部删除\nqueue.pop()  # 删除队尾元素，队列变为 [1]\n# 长度\nprint(len(queue))  # 输出 1\n```\n\n### 双端队列 Deque\n支持两端插入和删除，表示一种“灵活的队列”. \\\n- **滑动窗口问题**：在固定大小的窗口内高效地找到最大值或最小值。\n- **双端任务调度**：如同时处理高优先级和低优先级任务。\n- **回文检查**：从两端同时检查字符串是否为回文。\n\n\n",
    "toc": [
      {
        "depth": 2,
        "value": "数组 Array",
        "slug": "数组-array"
      },
      {
        "depth": 3,
        "value": "什么是动态数组？",
        "slug": "什么是动态数组？"
      },
      {
        "depth": 3,
        "value": "Python list",
        "slug": "python-list"
      },
      {
        "depth": 4,
        "value": "特点",
        "slug": "特点"
      },
      {
        "depth": 3,
        "value": "动态扩展的示例",
        "slug": "动态扩展的示例"
      },
      {
        "depth": 4,
        "value": "输出示例：",
        "slug": "输出示例："
      },
      {
        "depth": 3,
        "value": "Python list 的操作复杂度",
        "slug": "python-list-的操作复杂度"
      },
      {
        "depth": 3,
        "value": "动态数组与链表的对比",
        "slug": "动态数组与链表的对比"
      },
      {
        "depth": 3,
        "value": "总结",
        "slug": "总结"
      },
      {
        "depth": 3,
        "value": "素数",
        "slug": "素数"
      },
      {
        "depth": 4,
        "value": "生成素数",
        "slug": "生成素数"
      },
      {
        "depth": 5,
        "value": "埃拉托色尼筛法：",
        "slug": "埃拉托色尼筛法："
      },
      {
        "depth": 6,
        "value": "时间复杂度",
        "slug": "时间复杂度"
      },
      {
        "depth": 2,
        "value": "链表 Linked List",
        "slug": "链表-linked-list"
      },
      {
        "depth": 2,
        "value": "栈 Stack",
        "slug": "栈-stack"
      },
      {
        "depth": 3,
        "value": "队列 Queue",
        "slug": "队列-queue"
      },
      {
        "depth": 3,
        "value": "双端队列 Deque",
        "slug": "双端队列-deque"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/alg/python",
    "slug": "alg/python",
    "segments": [
      "alg",
      "python"
    ],
    "filePath": "docs/zh/alg/python.mdx",
    "meta": {
      "title": "python",
      "description": null,
      "created_at": "2025-03-22T06:13:49.000Z",
      "updated_at": "2025-03-22T06:13:49.000Z",
      "tags": [
        "alg",
        "python"
      ]
    },
    "order": 99,
    "content": "\n- 编程环境: Python 3.8.6\n- 编辑器: IDLE (python 自带编辑器)\n\n```sh\n# 启动虚拟环境中的 IDLE 编辑器\npython -m idlelib\n```\n\n## 迭代\n\n### 列表推导式\n\n`[expression for item in iterable if condition]{:py}`\n\n等效语法:\n```py\nlst = []\nfor item in iterable:\n    if condition:\n        lst.append(expression)\n```\n\n示例:\n```py\n# 1. 生成 1 到 10 的平方\n[i**2 for i in range(1,11)]\n# [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n# 2. 生成 1 ~ 20 的偶数\n[i for i in range(1,21) if i%2==0]\n[i for i in range(2,21,2)]\nlist(range(2,21,2))\n# [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\n# 3. 将 输入的 1 2 3 4 转化为 list[int]\n[int(i) for i in input().split()]\n# [1, 2, 3, 4]\n\n# 4. n*m 的 0 矩阵\nn, m = map(int, input().split()) | [2, 3]\nzero_matrix = [[0 for i in range(m)] for i in range(n)]\nzero_matrix1 = [[0]*m for i in range(n)]\nzero_matrix2 = [[0]*m]*n\n# [[0, 0, 0], [0, 0, 0]]\n\n# 5. 斐波那契数列\nn = int(input())\nfib = [0, 1]\n[fib.append(fib[-1]+fib[-2]) for i in range(2, n)]\n# [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597]\n\n# 6. 将二维表展开为一维表\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nflatten = [item for row in matrix for item in row]\n# 相当于:\nflatten = []\nfor row in matrix:\n    for item in row:\n        flatten.append(item)\n```\n\n### 字典推导式\n\n`{key: value for item in iterable if condition}{:py}`\n\n等效语法:\n```py\ndct = {}\nfor item in iterable:\n    if condition:\n        dct[key] = value\n```\n示例:\n```py\n# 统计字符串中每个字符出现的次数\ns = \"hello\"\n{char: s.count(char) for char in set(s)}\n# {'h': 1, 'e': 1, 'l': 2, 'o': 1}\n```\n\n### `range{:py}`\n\n`range(){:py}` 返回的是一个 `range{:py}` 对象, 是一个惰性序列(计算到对应位置时才会去计算对应的值), 节省内存. 如果需要 `list{:py}`, 可以用 `list(){:py}`\n\n`range(start, stop, step){:py}`\n- `start`: 起始值(包含), default: 0\n- `stop`: 结束值(不包含)\n- `step`: 步长, default: 1\n\n即左闭着右开(python 中统一使用左闭右开区间)\n\n```py\n# 1. 生成 1 到 10 的序列\nseq = range(1, 11)\nlist(seq) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n# 2. 生成 1 到 10 的奇数\nodd = range(1, 11, 2)\nlist(odd) # [1, 3, 5, 7, 9]\n\n# 3. 生成 10 到 1 的序列\nseq = range(10, 0, -1)\nlist(seq) # [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n\n# 4. 生成 0 1 2 3 4 0 1 2 3 4 0 1 2 3 4\nT = 5\nn = 3\nfor i in range(T*n):\n    a_i = i % T\n    print(a_i, end=' ')\n\n# 5. 生成二维网格坐标列表\nrow_count, col_count = 2, 3\ncoordinate_ls = [(i, j) for i in range(row_count) for j in range(col_count)]\n# [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2)]\n```\n",
    "toc": [
      {
        "depth": 2,
        "value": "迭代",
        "slug": "迭代"
      },
      {
        "depth": 3,
        "value": "列表推导式",
        "slug": "列表推导式"
      },
      {
        "depth": 3,
        "value": "字典推导式",
        "slug": "字典推导式"
      },
      {
        "depth": 3,
        "value": "range{:py}",
        "slug": "range{:py}"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/linux/systemd-timesyncd",
    "slug": "linux/systemd-timesyncd",
    "segments": [
      "linux",
      "systemd-timesyncd"
    ],
    "filePath": "docs/zh/linux/systemd-timesyncd.mdx",
    "meta": {
      "title": "systemd-timesyncd",
      "description": "systemd-timesyncd 是一个用于跨网络同步系统时钟的守护服务。它实现了一个 SNTP 客户端。与 chrony 或 NTP 参考服务器等 NTP 实现相比，这个服务仅做了客户端实现，摒弃了完整 NTP 实现的复杂性。它只专注于从远程服务器查询然后同步到本地时钟。除非你打算为网络客户端提供 NTP 服务或者连接本地硬件时钟，否则这个简单的 NTP 客户端应该更适合大多数人。守护进程运行只需要最小特权，并且会跟网络服务 networkd 挂钩，仅在网络连接可用时才工作。每次收到一个新的 NTP 同步请求或每 60 秒时，后台服务就把当前时间保存到磁盘，并尽可能在系统启动时修正系统时间，这样处理的目的是为了适应像 Raspberry Pi 和嵌入式设备这种缺少 RTC 的系统，并确保这些系统时单点处理（即使它并不是总是正确的）。如果要使用这个守护进程，需要在安装系统时创建一个新的系统用户和组“systemd-timesync”。",
      "created_at": "2025-03-22T03:16:43.000Z",
      "updated_at": "2025-03-22T03:16:43.000Z",
      "tags": []
    },
    "order": 99,
    "content": "",
    "toc": []
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/next",
    "slug": "next",
    "segments": [
      "next"
    ],
    "filePath": "docs/zh/next/index.mdx",
    "meta": {
      "title": "Nextjs",
      "description": "The React Framework for the Web, Used by some of the world's largest companies, Next.js enables you to create high-quality web applications with the power of React components.",
      "created_at": "2025-03-22T05:21:31.000Z",
      "updated_at": "2025-03-22T05:21:31.000Z",
      "tags": [
        "next",
        "ts",
        "react",
        "web"
      ]
    },
    "order": 99,
    "content": "\noh\n",
    "toc": []
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/alg/struct",
    "slug": "alg/struct",
    "segments": [
      "alg",
      "struct"
    ],
    "filePath": "docs/zh/alg/struct.mdx",
    "meta": {
      "title": "数据结构",
      "description": "数据结构是算法的基础，而算法是操作数据结构的具体方法",
      "created_at": "2025-03-22T18:11:12.000Z",
      "updated_at": "2025-03-22T18:11:12.000Z",
      "tags": [
        "alg",
        "data-structure"
      ]
    },
    "order": 99,
    "content": "\nhttps://explorer-dong.github.io\n\n学习数据结构是编程和算法的基础，它为解决复杂问题提供了高效的工具和方法。以下是学习数据结构时需要掌握的主要内容，以及每种数据结构的用途和学习建议。\n\n## 基础数据结构\n\n### 数组（Array）\n- **特点**：\n  - 连续的内存空间，支持快速随机访问（时间复杂度 O(1)）。\n  - 插入和删除操作效率较低（需要移动元素）, 时间复杂度 O(n), 但在末尾插入和删除效率高（时间复杂度 O(1)）。\n- **用途**：\n  - 存储固定大小的元素集合。\n  - 常用于实现其他数据结构（如栈、队列）。\n- **学习内容**：\n  - 一维数组、多维数组。\n  - 常见操作：遍历、插入、删除、查找。\n- **代码示例**（Python）：python 中的 list 是动态数组\n  ```python\n  # \n  arr = [1, 2, 3, 4]\n  arr.append(5)  # 插入\n  arr.remove(2)  # 删除\n  print(arr[1])  # 随机访问\n  ```\n\n### 链表（Linked List）\n- **特点**：\n  - 由节点组成，每个节点包含数据和指向下一个节点的指针。\n  - 插入和删除操作效率高（时间复杂度 O(1)），但随机访问效率低（时间复杂度 O(n)）。\n- **类型**：\n  - 单链表、双向链表、循环链表。\n- **用途**：\n  - 动态存储数据，适合频繁插入和删除的场景。\n  - 用于实现栈、队列等数据结构。\n- **学习内容**：\n  - 单链表、双向链表的实现。\n  - 常见操作：插入、删除、查找、反转链表。\n- **代码示例**（单链表）：\n  ```python\n  class Node:\n      def __init__(self, data):\n          self.data = data\n          self.next = None\n\n  class LinkedList:\n      def __init__(self):\n          self.head = None\n\n      def append(self, data):\n          new_node = Node(data)\n          if not self.head:\n              self.head = new_node\n              return\n          current = self.head\n          while current.next:\n              current = current.next\n          current.next = new_node\n  ```\n\n---\n\n### 栈 Stack\n- **特点**：\n  - 后进先出（LIFO）。\n  - 只允许在一端（栈顶）进行插入和删除操作。\n- **用途**：\n  - 用于递归调用、括号匹配、表达式求值等。\n- **学习内容**：\n  - 栈的实现（基于数组或链表）。\n  - 常见操作：`push`（入栈）、`pop`（出栈）、`peek`（查看栈顶元素）。\n- **代码示例**：\n  ```python\n  stack = []\n  stack.append(1)  # 入栈\n  stack.append(2)\n  print(stack.pop())  # 出栈\n  ```\n\n---\n\n### **1.4 队列（Queue）**\n- **特点**：\n  - 先进先出（FIFO）。\n  - 插入操作在队尾，删除操作在队首。\n- **类型**：\n  - 普通队列、双端队列（Deque）、优先队列。\n- **用途**：\n  - 用于任务调度、广度优先搜索（BFS）等。\n- **学习内容**：\n  - 队列的实现（基于数组或链表）。\n  - 双端队列的实现。\n- **代码示例**：\n  ```python\n  from collections import deque\n  queue = deque()\n  queue.append(1)  # 入队\n  queue.append(2)\n  print(queue.popleft())  # 出队\n  ```\n\n---\n\n## **2. 树和图**\n\n### **2.1 树（Tree）**\n- **特点**：\n  - 层次结构，每个节点有一个父节点和多个子节点。\n  - 特殊类型：二叉树、二叉搜索树（BST）、平衡二叉树（如 AVL 树）、堆（Heap）。\n- **用途**：\n  - 用于表示层级关系（如文件系统、DOM 树）。\n  - 二叉搜索树用于快速查找、插入和删除。\n- **学习内容**：\n  - 二叉树的遍历（前序、中序、后序、层序）。\n  - 二叉搜索树的插入、删除、查找。\n  - 堆的实现（最大堆、最小堆）。\n- **代码示例**（二叉树的遍历）：\n  ```python\n  class TreeNode:\n      def __init__(self, val=0, left=None, right=None):\n          self.val = val\n          self.left = left\n          self.right = right\n\n  def inorder_traversal(root):\n      if not root:\n          return []\n      return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right)\n  ```\n\n---\n\n### **2.2 图（Graph）**\n- **特点**：\n  - 由节点（顶点）和边组成，可以是有向图或无向图。\n  - 表示复杂的关系（如社交网络、地图）。\n- **表示方法**：\n  - 邻接矩阵、邻接表。\n- **用途**：\n  - 用于路径规划（如最短路径）、网络流、拓扑排序等。\n- **学习内容**：\n  - 图的表示方法。\n  - 图的遍历（深度优先搜索 DFS、广度优先搜索 BFS）。\n  - 最短路径算法（Dijkstra、Floyd-Warshall）。\n- **代码示例**（BFS）：\n  ```python\n  from collections import deque\n\n  def bfs(graph, start):\n      visited = set()\n      queue = deque([start])\n      while queue:\n          node = queue.popleft()\n          if node not in visited:\n              visited.add(node)\n              print(node)\n              queue.extend(graph[node] - visited)\n  ```\n\n---\n\n## **3. 高级数据结构**\n\n### **3.1 哈希表（Hash Table）**\n- **特点**：\n  - 通过哈希函数将键映射到值，支持快速查找、插入和删除（平均时间复杂度 O(1)）。\n- **用途**：\n  - 用于实现字典、集合。\n  - 常用于查找问题（如两数之和）。\n- **学习内容**：\n  - 哈希函数的设计。\n  - 解决哈希冲突的方法（如链地址法、开放地址法）。\n- **代码示例**：\n  ```python\n  hash_table = {}\n  hash_table[\"key\"] = \"value\"\n  print(hash_table[\"key\"])\n  ```\n\n---\n\n### **3.2 字典树（Trie）**\n- **特点**：\n  - 一种树形结构，用于高效存储和查找字符串集合。\n- **用途**：\n  - 用于实现自动补全、前缀匹配。\n- **学习内容**：\n  - 插入、查找字符串。\n- **代码示例**：\n  ```python\n  class TrieNode:\n      def __init__(self):\n          self.children = {}\n          self.is_end = False\n\n  class Trie:\n      def __init__(self):\n          self.root = TrieNode()\n\n      def insert(self, word):\n          node = self.root\n          for char in word:\n              if char not in node.children:\n                  node.children[char] = TrieNode()\n              node = node.children[char]\n          node.is_end = True\n  ```\n\n---\n\n### **并查集（Union-Find）**\n- **特点**：\n  - 用于处理动态连通性问题。\n- **用途**：\n  - 用于解决图的连通性问题（如最小生成树 Kruskal 算法）。\n- **学习内容**：\n  - 路径压缩、按秩合并。\n- **代码示例**：\n  ```python\n  class UnionFind:\n      def __init__(self, n):\n          self.parent = list(range(n))\n\n      def find(self, x):\n          if self.parent[x] != x:\n              self.parent[x] = self.find(self.parent[x])\n          return self.parent[x]\n\n      def union(self, x, y):\n          root_x = self.find(x)\n          root_y = self.find(y)\n          if root_x != root_y:\n              self.parent[root_x] = root_y\n  ```\n\n---\n\n## **学习建议**\n\n1. **从基础到高级**：\n   - 先掌握数组、链表、栈、队列等基础数据结构。\n   - 再学习树、图等复杂数据结构。\n\n2. **结合算法学习**：\n   - 数据结构和算法密不可分，学习数据结构时可以结合经典算法（如排序、搜索、动态规划）。\n\n3. **多练习**：\n   - 在 LeetCode、Codeforces 等平台上刷题，巩固数据结构的应用。\n\n4. **参考书籍**：\n   - 《数据结构与算法分析》（C语言版/Java版）—— Mark Allen Weiss\n   - 《算法导论》（Introduction to Algorithms）—— Thomas H. Cormen\n\n",
    "toc": [
      {
        "depth": 2,
        "value": "基础数据结构",
        "slug": "基础数据结构"
      },
      {
        "depth": 3,
        "value": "数组（Array）",
        "slug": "数组（array）"
      },
      {
        "depth": 3,
        "value": "链表（Linked List）",
        "slug": "链表（linked-list）"
      },
      {
        "depth": 3,
        "value": "栈 Stack",
        "slug": "栈-stack"
      },
      {
        "depth": 3,
        "value": "1.4 队列（Queue）",
        "slug": "1.4-队列（queue）"
      },
      {
        "depth": 2,
        "value": "2. 树和图",
        "slug": "2.-树和图"
      },
      {
        "depth": 3,
        "value": "2.1 树（Tree）",
        "slug": "2.1-树（tree）"
      },
      {
        "depth": 3,
        "value": "2.2 图（Graph）",
        "slug": "2.2-图（graph）"
      },
      {
        "depth": 2,
        "value": "3. 高级数据结构",
        "slug": "3.-高级数据结构"
      },
      {
        "depth": 3,
        "value": "3.1 哈希表（Hash Table）",
        "slug": "3.1-哈希表（hash-table）"
      },
      {
        "depth": 3,
        "value": "3.2 字典树（Trie）",
        "slug": "3.2-字典树（trie）"
      },
      {
        "depth": 3,
        "value": "并查集（Union-Find）",
        "slug": "并查集（union-find）"
      },
      {
        "depth": 2,
        "value": "学习建议",
        "slug": "学习建议"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/next/15",
    "slug": "next/15",
    "segments": [
      "next",
      "15"
    ],
    "filePath": "docs/zh/next/15.mdx",
    "meta": {
      "title": 15,
      "description": null,
      "created_at": "2025-03-26T00:56:58.000Z",
      "updated_at": "2025-03-26T00:56:58.000Z",
      "tags": []
    },
    "order": 99,
    "content": "\n## 原生支持 pwa\n\n如果你已经有使用 `next-pwa` 的项目，它仍然是有效的解决方案，但对于新项目，你可以考虑使用 Next.js 的原生功能结合 Serwist（如果需要完整的离线支持）",
    "toc": [
      {
        "depth": 2,
        "value": "原生支持 pwa",
        "slug": "原生支持-pwa"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/linux",
    "slug": "linux",
    "segments": [
      "linux"
    ],
    "filePath": "docs/zh/linux/index.mdx",
    "meta": {
      "title": "linux",
      "description": "linux 简介",
      "created_at": "2025-03-22T05:22:44.000Z",
      "updated_at": "2025-03-22T05:22:44.000Z",
      "tags": [
        "linux"
      ]
    },
    "order": 99,
    "content": "",
    "toc": []
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/paper",
    "slug": "paper",
    "segments": [
      "paper"
    ],
    "filePath": "docs/zh/paper/index.mdx",
    "meta": {
      "title": "论文",
      "description": "论文",
      "created_at": "2025-03-22T05:31:40.000Z",
      "updated_at": "2025-03-22T05:31:40.000Z",
      "tags": [
        "math， paper"
      ]
    },
    "order": 99,
    "content": "\n## 数据集\n\n中国老年人健康数据\n",
    "toc": [
      {
        "depth": 2,
        "value": "数据集",
        "slug": "数据集"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/ts/async",
    "slug": "ts/async",
    "segments": [
      "ts",
      "async"
    ],
    "filePath": "docs/zh/ts/async.mdx",
    "meta": {
      "title": "async",
      "description": null,
      "created_at": "2025-03-26T00:50:16.000Z",
      "updated_at": "2025-03-26T00:50:16.000Z",
      "tags": [
        "ts",
        "async"
      ]
    },
    "order": 99,
    "content": "\n\n```ts filename=main.ts\nimport u, { learnAsync1 } from \"./utils.ts\";\n\nconst main = async () => {\n  // const message = await learnAsync();\n  // const message2 = await u();\n  await Promise.all([learnAsync1(), u()]);\n}\nmain();\n```\n\n```ts filename=utils.ts\nexport const learnAsync1 = () => {\n  const learnAsyncRet = new Promise<string>((resolve, reject) => {\n    setTimeout(() => {\n      const success = Math.random() > 0.1; // 10% 的概率成功\n      if (success) {\n        // console.log('learnAsync1: I have learned async!');\n        console.log('learnAsync1: 3秒');\n        resolve('learnAsync1: I have learned async!');\n      } else {\n        reject('Failed to learn async.');\n      }\n    }, 3000);\n  });\n  return learnAsyncRet\n}\n\nconst learnAsync2 = async () => {\n  // 延时一秒, 后打印 已延时一秒\n  await new Promise((resolve) => {\n    setTimeout(() => {\n      console.log('learnAsync2: 已延时一秒');\n      resolve(\"learnAsync2: Promise: OK\");\n    }, 1000);\n  });\n  // 延时3秒, 后打印 已延时1+3秒\n  setTimeout(() => {\n      console.log('learnAsync2: 已延时1+3秒');\n  }, 3000);\n  const ret = \"learnAsync2, 共花费4秒\"\n  return ret\n};\nexport default learnAsync2\n```\n",
    "toc": []
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/linux/system_time",
    "slug": "linux/system_time",
    "segments": [
      "linux",
      "system_time"
    ],
    "filePath": "docs/zh/linux/system_time.mdx",
    "meta": {
      "title": "系统时间",
      "description": "在操作系统中，时间（时钟）取决于三个部分：时间值（本地时间或 UTC 等）、时区及夏令时（DST，需要时应用，在中国已废止）。本文将分别介绍各个部分的定义及如何设置和读取它们。系统中也存在两种时钟：硬件时钟和系统时钟，下文也将进行详细描述。",
      "created_at": "2025-03-22T03:26:09.000Z",
      "updated_at": "2025-03-22T03:26:09.000Z",
      "tags": [
        "linux",
        "os",
        "time"
      ]
    },
    "order": 99,
    "content": "大部分操作系统的时间管理包括如下方面：\n\n- 启动时根据硬件时钟设置系统时间\n- 保持系统时钟准确，细节请参考#时钟同步\n- 关机时根据系统时钟设置硬件时钟",
    "toc": []
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/dev/deploy",
    "slug": "dev/deploy",
    "segments": [
      "dev",
      "deploy"
    ],
    "filePath": "docs/zh/dev/deploy/index.mdx",
    "meta": {
      "title": "部署",
      "description": null,
      "created_at": "2025-03-24T13:15:49.000Z",
      "updated_at": "2025-03-24T13:15:49.000Z",
      "tags": [
        "dev",
        "deploy"
      ]
    },
    "order": 99,
    "content": "",
    "toc": []
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/ts",
    "slug": "ts",
    "segments": [
      "ts"
    ],
    "filePath": "docs/zh/ts/index.mdx",
    "meta": {
      "title": "TypeScript",
      "description": "TypeScript 是 JavaScript 的超集，可以编译成纯 JavaScript 代码, 也可以直接使用 deno, ts-node, bun 等运行",
      "created_at": "2025-03-22T05:20:06.000Z",
      "updated_at": "2025-03-22T05:20:06.000Z",
      "tags": [
        "ts"
      ]
    },
    "order": 99,
    "content": "",
    "toc": []
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/dev/md/docs",
    "slug": "dev/md/docs",
    "segments": [
      "dev",
      "md",
      "docs"
    ],
    "filePath": "docs/zh/dev/md/docs.mdx",
    "meta": {},
    "order": 99,
    "content": "",
    "toc": []
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/dev/md/github",
    "slug": "dev/md/github",
    "segments": [
      "dev",
      "md",
      "github"
    ],
    "filePath": "docs/zh/dev/md/github.mdx",
    "meta": {
      "title": "GitHub",
      "description": "GitHub flavored markdown (GFM)",
      "created_at": "2025-03-17T14:44:46.000Z",
      "updated_at": "2025-03-17T14:55:01.000Z",
      "tags": [
        "markdown",
        "github"
      ]
    },
    "order": 99,
    "content": "## Autolink literals\n\nwww.example.com, https://example.com, and contact@example.com.\n\n## Footnote\n\nA note[^1]\n\n[^1]: Big note.\n\n## Strikethrough\n\n~one~ or ~~two~~ tildes.\n\n## Table\n\n| a | b  |  c |  d  |\n| - | :- | -: | :-: |\n\n## Tasklist\n\n> Checkboxes\n\n* [ ] to do\n* [x] done\n\n## Alerts\n> [!NOTE]\n> Hello, world!\n\n> [!TIP]\n> To preserve your formatting within a list, make sure to indent non-fenced code blocks by eight spaces.\n\n> [!IMPORTANT]\n> This is important.\n\n> [!WARNING]\n> This is a warning.\n\n\n> [!CAUTION]\n> This is caution.",
    "toc": [
      {
        "depth": 2,
        "value": "Autolink literals",
        "slug": "autolink-literals"
      },
      {
        "depth": 2,
        "value": "Footnote",
        "slug": "footnote"
      },
      {
        "depth": 2,
        "value": "Strikethrough",
        "slug": "strikethrough"
      },
      {
        "depth": 2,
        "value": "Table",
        "slug": "table"
      },
      {
        "depth": 2,
        "value": "Tasklist",
        "slug": "tasklist"
      },
      {
        "depth": 2,
        "value": "Alerts",
        "slug": "alerts"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/ts/tsconfig",
    "slug": "ts/tsconfig",
    "segments": [
      "ts",
      "tsconfig"
    ],
    "filePath": "docs/zh/ts/tsconfig.mdx",
    "meta": {},
    "order": 99,
    "content": "# tsconfig\n\n```jsonc filename=\"tsconfig.json\"\n{\n  \"compilerOptions\": {\n    // 在 TypeScript 中，moduleResolution 选项用于指定模块解析策略。不同的模块解析策略会影响 TypeScript 如何查找和解析模块。常见的模块解析策略包括 node 和 bundler。\n    \"moduleResolution\": \"bundler\"\n  }\n}\n```\n\n## compilerOptions\n\n### moduleResolution\n\n在 TypeScript `中，moduleResolution` 选项用于指定模块解析策略。不同的模块解析策略会影响 TypeScript 如何查找和解析模块。常见的模块解析策略包括 `node` 和 `bundler`, `classic`, `nodenext`, `node10`, `node16`\n\n#### `moduleResolution: node`\n\n`node` 模块解析策略模拟了 Node.js 的模块解析逻辑。这是 TypeScript 的默认解析策略，适用于大多数 Node.js 项目。\n\n##### 特点\n\n1. **Node.js 风格的模块解析**：\n   - TypeScript 会按照 Node.js 的方式查找模块，包括查找 node_modules 目录和解析文件扩展名（如 `.js`、`.ts`、`.json` 等）。\n   \n2. **支持 package.json 中的 `main` 字段**：\n   - TypeScript 会读取 package.json 文件中的 `main` 字段，以确定模块的入口文件。\n\n3. **支持相对路径和绝对路径**：\n   - TypeScript 支持使用相对路径（如 `./module`）和绝对路径（如 `/module`）来导入模块。\n\n#### `moduleResolution: bundler`\n\n`bundler` 模块解析策略是为现代打包工具（如 Webpack、Rollup、Vite 等）设计的。它与 `node` 模块解析策略类似，但在某些方面进行了优化，以更好地支持这些打包工具。\n\n##### 特点\n\n1. **优化的模块解析**：\n   - `bundler` 策略在解析模块时会考虑打包工具的特性，可能会更高效地处理模块解析。\n\n2. **支持 `exports` 和 `imports` 字段**：\n   - `bundler` 策略支持 package.json 文件中的 `exports` 和 `imports` 字段，这些字段是现代打包工具用来定义模块入口和导入路径的。\n\n3. **更好的兼容性**：\n   - `bundler` 策略可能会更好地兼容现代打包工具的模块解析逻辑，减少与打包工具的冲突。\n",
    "toc": [
      {
        "depth": 1,
        "value": "tsconfig",
        "slug": "tsconfig"
      },
      {
        "depth": 2,
        "value": "compilerOptions",
        "slug": "compileroptions"
      },
      {
        "depth": 3,
        "value": "moduleResolution",
        "slug": "moduleresolution"
      },
      {
        "depth": 4,
        "value": "moduleResolution: node",
        "slug": "moduleresolution:-node"
      },
      {
        "depth": 5,
        "value": "特点",
        "slug": "特点"
      },
      {
        "depth": 4,
        "value": "moduleResolution: bundler",
        "slug": "moduleresolution:-bundler"
      },
      {
        "depth": 5,
        "value": "特点",
        "slug": "特点"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/dev/md/mdx",
    "slug": "dev/md/mdx",
    "segments": [
      "dev",
      "md",
      "mdx"
    ],
    "filePath": "docs/zh/dev/md/mdx.mdx",
    "meta": {},
    "order": 99,
    "content": "",
    "toc": []
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/dev/md/slug",
    "slug": "dev/md/slug",
    "segments": [
      "dev",
      "md",
      "slug"
    ],
    "filePath": "docs/zh/dev/md/slug.mdx",
    "meta": {
      "title": "md slug",
      "description": null,
      "created_at": "2025-03-17T18:03:47.000Z",
      "updated_at": "2025-03-17T18:03:47.000Z",
      "tags": [
        "markdown",
        "slug",
        "url"
      ]
    },
    "order": 99,
    "content": "\n我们的文件来自与 各处: 本地\\远程\\数据库\\文件系统\\等等\n\n我们的文件名包括文件夹名，可能是\n```yml\n- prefix/\n  - index.mdx\n  - 01-start.mdx\n  - 02-install.mdx\n  - 03-usage/\n    - index.mdx\n    - 01-contribution-guide.mdx\n    - 02-advanced.mdx\n```\n\n\n```tsx  showLineNumbers fileame=\"src/app/docs/[...slug]/page.tsx\"\nexport const generateStaticParams = async() => {\n  return [{ slug: ['a', '1'] }, { slug: ['b'] }, { slug: ['c', '3'] }, { slug: ['d', '4', 'c'] }]\n}\n\nexport default async function Page ({\n  params,\n}: {\n  params: Promise<{ slug: string[] }>,\n}) {\n  const { slug } = await params\n  \n  return <Suspense fallback={<LoadingS />}>\n    <h1>Page</h1>\n    <p>This is the Page page.</p>\n  </Suspense>\n}\n```",
    "toc": []
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/alg/enum/g",
    "slug": "alg/enum/g",
    "segments": [
      "alg",
      "enum",
      "g"
    ],
    "filePath": "docs/zh/alg/enum/g.mdx",
    "meta": {
      "title": "g",
      "description": null,
      "created_at": "2025-03-25T07:43:08.000Z",
      "updated_at": "2025-03-25T07:43:08.000Z",
      "tags": []
    },
    "order": 99,
    "content": "```mermaid\nflowchart LR\n    A[\"穷举法 (Brute Force)\"] --> B[核心思想]\n    B --> C[尝试所有可能的解]\n    B --> D[逐一验证每个解是否满足条件]\n    B --> E[返回满足条件的解或最优解]\n\n    A --> F[特点]\n    F --> G[简单直接]\n    F --> H[适合解空间有限的问题]\n    F --> I[通常效率较低，时间复杂度较高]\n\n    A --> J[应用场景]\n    J --> K[\"组合问题 (如子集、排列、组合)\"]\n    J --> L[\"搜索问题 (如迷宫、棋盘问题)\"]\n    J --> M[\"验证问题 (如密码破解、暴力匹配)\"]\n```",
    "toc": []
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/alg/bisect",
    "slug": "alg/bisect",
    "segments": [
      "alg",
      "bisect"
    ],
    "filePath": "docs/zh/alg/bisect/index.mdx",
    "meta": {
      "title": "bisect",
      "description": "二分查找是一种高效的查找算法，适用于有序数组或列表。它的核心思想是通过比较中间元素和目标值的大小，缩小查找范围，直到找到目标值或范围为空。",
      "created_at": "2025-03-25T04:40:00.000Z",
      "updated_at": "2025-03-25T04:40:00.000Z",
      "tags": [
        "alg",
        "bisect"
      ]
    },
    "order": 99,
    "content": "\n- **目标**: 掌握二分查找的思想和变种\n- **学习内容**:\n  1. 标准二分查找\n  2. 二分查找的变种（如查找左边界、右边界）, 二分查找变形问题\n  3. 二分查找的应用: 有序数组查找, 最优解的范围搜索, 查找边界, 旋转数组查找\n- **推荐题目**:\n  - [LeetCode 704. 二分查找](https://leetcode-cn.com/problems/binary-search/description/) (基础二分查找)\n  - [LeetCode 69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/description/) (二分查找)\n  - [LeetCode 34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/) (变种二分)\n  - [LeetCode 153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/) (二分查找)\n  - [LeetCode 33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/) (二分查找)\n  - [LeetCode 4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/description/) (二分查找)\n\n## python 自带的二分查找库\n```py\ndef bisect( \n    a, # 给定一个升序数组\n    x, # 目标值\n    lo:int=0,\n    hi:int | None = None\n  ): # 返回第一个大于目标值的索引 在 a[lo:hi] 里\n  ...\n# 时间复杂度: O(logn)\nfrom bisect import bisect\n\na = [1,9,9,9,200,500]\nprint(bisect(a, 3)) # 1，a[1] = 9\nprint(bisect(a, 9)) # 4，a[4] = 200\nprint(bisect(a, -1)) # 0，a[0] = 1\nprint(bisect(a, 1000)) # 6，a[6]: error\n\na.reverse() # [500, 200, 9, 9, 9, 1]\n# 找到第一个小于 x 的索引\na_rev_ = [-i for i in a] # [-500, -200, -9, -9, -9, -1]\nprint(bisect(a_rev_, -3)) # 5，a_[5] = -1\nprint(bisect(a_rev_, -9)) # 5，a_[5] = -1\nprint(bisect(a_rev_, -1)) # 6，a_[6]: err\nprint(bisect(a_rev_, -1000)) # 0，a_[0] = -500\n```\n\n## 例题\n\n[洛谷 P2249 【深基13.例1】查找](https://www.luogu.com.cn/problem/P2249)\n\n### 题目描述\n\n输入 $n$ 个不超过 $10^9$ 的单调不减的（就是后面的数字不小于前面的数字）非负整数 $a_1,a_2,\\dots,a_{n}$，然后进行 $m$ 次询问。对于每次询问，给出一个整数 $q$，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出 $-1$ 。\n\n### 输入格式\n\n第一行 $2$ 个整数 $n$ 和 $m$，表示数字个数和询问次数。\n\n第二行 $n$ 个整数，表示这些待查询的数字。\n\n第三行 $m$ 个整数，表示询问这些数字的编号，从 $1$ 开始编号。\n\n### 输出格式\n\n输出一行，$m$ 个整数，以空格隔开，表示答案。\n\n### 输入输出样例\n\n#### 输入\n\n```\n11 3\n1 3 3 3 5 7 9 11 13 15 15\n1 3 6\n```\n\n#### 输出\n\n```\n1 2 -1\n```\n\n### 说明/提示\n\n数据保证，$1 \\leq n \\leq 10^6$，$0 \\leq a_i,q \\leq 10^9$，$1 \\leq m \\leq 10^5$\n\n本题输入输出量较大，请使用较快的 IO 方式。\n\n### 题解\n\n#### 获得输入\n```py\nimport sys\ninput = lambda: sys.stdin.readline().strip()\nn, m = map(int, input().split())\na_ls = list(map(int, input().split()))\nq_ls = list(map(int, input().split()))\n```\n\n#### 方法一: 二分查找\n```py\nfrom bisect import bisect\nfrom typing import List\ndef m1(n:int, m:int, a_ls:List[int], q_ls:List[int]) -> List[int]:\n  s = set(a_ls)\n  res = []\n  for q in q_ls:\n    if q in s:\n      res.append(bisect(a_ls, q-1)+1)# + 1是因为题目的输出是从1开始编号\n    else:\n      res.append(-1)\n  return res\nprint(*m1(n, m, a_ls, q_ls))\n```\n\n## 实战题:2563\n\n[LeetCode 2563. 统计公平对数目](https://leetcode-cn.com/problems/count-the-number-of-fair-pairs/description/)\n\n给你一个下标从 0 开始、长度为 `n` 的整数数组 `nums` 和两个整数 `lower` 和 `upper`, 返回**公平数对的数目**。\n如果 `(i, j)` 满足以下情况, 则认为它是一个**公平数对**:\n- `0 <= i < j < n`且\n- `lower <= nums[i] + nums[j] <= upper`\n**示例 1:**\n> 输入: nums = [0,1,7,4,4,5], lower = 3, upper = 6\n> 输出: 6\n> 解释: 共计 6 个公平数对: (0,3), (0,4), (0,5), (1,3), (1,4), (1,5)。\n**示例 2:**\n> 输入: nums = [1,7,9,2,5], lower = 11, upper = 11\n> 输出: 1\n> 解释: 共计 1 个公平数对: (2,3)。\n**提示:**\n- `1 <= nums.length <= 10^5`\n- `nums.length == n`\n- `-10^9 <= nums[i] <= 10^9`\n- `-10^9 <= lower <= upper <= 10^9`\n\n### 方法一: 枚举\n```py\ndef countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\n  res = 0\n  for i in range(len(nums)):\n    for j in range(i+1, len(nums)):\n      if lower <= nums[i] + nums[j] <= upper:\n        res += 1\n  return res\n```\n### 方法二: 二分查找\n- 注意到排序不影响结果(总数)\n- 对 `lower <= nums[i] + nums[j] <= upper` 进行变形，得到 `lower - nums[i] <= nums[j] <= upper - nums[i]`，\n- 即对于每个 `i`，找到 `nums[j]` 在 `[lower - nums[i], upper - nums[i]]` 之间的个数。\n- `j` 的范围是 `[i+1, n)`，所以可以对 `nums` 进行排序，然后对于每个 `i`, 在 `j`的范围中，找到 `lower - nums[i]` 和 `upper - nums[i]` 的位置，然后计算这两个位置之间的个数。\n```py\nfrom bisect import bisect\n\ndef countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\n  res = 0\n  nums.sort()\n  for i in range(len(nums)):\n    L = bisect(nums, lower - nums[i]-1, i+1)\n    R = bisect(nums, upper - nums[i], i+1)-1\n    res += R - L + 1 # 索引做差+1 得到之间的个数, 对于前后都是闭区间\n  return res\n```\n\n## 自己实现二分查找\npython3.12 给 `bisect` 增加了 参数 `key: func`, 但是 python3.8 只有4个参数: `a, x, lo=0, hi=None`,\n\n因此需要学会自己实现二分查找, 以应对更多的情况\n\n**实现思路:**\n1. 对于区间 `[lo, hi)`, 划分为 `[lo, mid)` 和 `[mid, hi)`, `mid = (lo + hi) >> 1{:py}`\n2. `if x < a[mid]: hi = mid{:py}`, `else: lo = mid+1{:py}`\n3. 重复步骤1,2 直到 `lo == hi`\n\n```py\ndef bisect(a, x, lo=0, hi=None, key=lambda f: f):\n  if hi is None: hi = len(a)\n  while lo < hi:\n    mid = (lo + hi) >> 1\n    if x < key(a[mid]): hi = mid # 补上未来版本的 key\n    else: lo = mid + 1\n  return lo\n```\n\n## leetCode 2226\n\n[LeetCode 2226. 每个小孩最多能分到多少糖果](https://leetcode-cn.com/problems/maximum-candies-allocated-to-k-children/description/)\n\n给你一个 **下标从 0 开始** 的整数数组 `candies` 。数组中的每个元素表示大小为 `candies[i]` 的一堆糖果。你可以将每堆糖果分成任意数量的 **子堆** ，但 **无法** 再将两堆合并到一起。\n\n另给你一个整数 k 。你需要将这些糖果分配给 k 个小孩，使每个小孩分到 **相同** 数量的糖果。每个小孩可以拿走 **至多一堆** 糖果，有些糖果可能会不被分配。\n\n返回每个小孩可以拿走的 **最大糖果数目** 。\n\n**示例 1:**\n> 输入: `candies = [5,8,6], k = 3`\n> 输出: `5`\n> 解释: 可以将 `candies[1]` 分成大小分别为 5 和 3 的两堆，然后把 `candies[2]` 分成大小分别为 5 和 1 的两堆。现在就有五堆大小分别为 5、5、3、5 和 1 的糖果。可以把 3 堆大小为 5 的糖果分给 3 个小孩。可以证明无法让每个小孩得到超过 5 颗糖果。\n**示例 2:**\n> 输入: `candies = [2,5], k = 11`\n> 输出: `0`\n> 解释: 总共有 11 个小孩，但只有 7 颗糖果，但如果要分配糖果的话，必须保证每个小孩至少能得到 1 颗糖果。因此，最后每个小孩都没有得到糖果，答案是 0 。\n**示例 3:**\n- `1 <= candies.length <= 10^5`\n- `1 <= candies[i] <= 10^7`\n- `1 <= k <= 10^12`\n\n题解:\n```py\n# 可知问题解一定在 [0, max(candies)] 之间\n# 答案就是寻找有多个 能被 res 整除的数 在[0, max(candies)] 之间\n# def bisect(x,lo=0,hi=None,key=lambda f: f):\n# #   if hi is None: hi = len(a)\n#   while lo < hi:\n#     mid = (lo + hi) >> 1\n#     if x > key(mid): hi = mid\n#     else: lo = mid + 1\n#   return lo\n\nclass Solution:\n    def maximumCandies(self, candies: List[int], k: int) -> int:\n        tot = sum(candies)\n        r = tot//k\n        if r==1: return 1\n        elif tot<k: return 0\n        lo = 1\n        hi = 10**12+10\n        key = lambda x: sum([i//x for i in candies])\n        while lo < hi:\n            mid = (lo + hi) >> 1\n            if k > key(mid): hi = mid\n            else: lo = mid + 1\n        return lo - 1\n        # res = bisect(k, lo=1, hi=max(candies)+1, key=)\n        # return res -1\n```\n\n## lanqiao 3.冶炼金属\n\nhttps://www.lanqiao.cn/problems/3510/learning/?page=1&first_category_id=1&second_category_id=3&tags=%E4%BA%8C%E5%88%86,%E7%9C%81%E8%B5%9B&tag_relation=intersection&difficulty=20\n\n小蓝有一个神奇的炉子用于将普通金属 O 冶炼成为一种特殊金属 X。这个炉子有一个称作转换率的属性 V，V 是一个正整数，这意味着消耗 V 个普通金属 O 恰好可以冶炼出一个特殊金属 X，当普通金属 O 的数目不足 V 时，无法继续冶炼。\n\n现在给出了 N 条冶炼记录，每条记录中包含两个整数 A 和 B，这表示本次投入了 A 个普通金属 O，最终冶炼出了 B 个特殊金属 X。每条记录都是独立的，这意味着上一次没消耗完的普通金属 O 不会累加到下一次的冶炼当中。\n\n根据这 N 条冶炼记录，请你推测出转换率 V 的最小值和最大值分别可能是多少，题目保证评测数据不存在无解的情况。",
    "toc": [
      {
        "depth": 2,
        "value": "python 自带的二分查找库",
        "slug": "python-自带的二分查找库"
      },
      {
        "depth": 2,
        "value": "例题",
        "slug": "例题"
      },
      {
        "depth": 3,
        "value": "题目描述",
        "slug": "题目描述"
      },
      {
        "depth": 3,
        "value": "输入格式",
        "slug": "输入格式"
      },
      {
        "depth": 3,
        "value": "输出格式",
        "slug": "输出格式"
      },
      {
        "depth": 3,
        "value": "输入输出样例",
        "slug": "输入输出样例"
      },
      {
        "depth": 4,
        "value": "输入",
        "slug": "输入"
      },
      {
        "depth": 4,
        "value": "输出",
        "slug": "输出"
      },
      {
        "depth": 3,
        "value": "说明/提示",
        "slug": "说明/提示"
      },
      {
        "depth": 3,
        "value": "题解",
        "slug": "题解"
      },
      {
        "depth": 4,
        "value": "获得输入",
        "slug": "获得输入"
      },
      {
        "depth": 4,
        "value": "方法一: 二分查找",
        "slug": "方法一:-二分查找"
      },
      {
        "depth": 2,
        "value": "实战题:2563",
        "slug": "实战题:2563"
      },
      {
        "depth": 3,
        "value": "方法一: 枚举",
        "slug": "方法一:-枚举"
      },
      {
        "depth": 3,
        "value": "方法二: 二分查找",
        "slug": "方法二:-二分查找"
      },
      {
        "depth": 2,
        "value": "自己实现二分查找",
        "slug": "自己实现二分查找"
      },
      {
        "depth": 2,
        "value": "leetCode 2226",
        "slug": "leetcode-2226"
      },
      {
        "depth": 2,
        "value": "lanqiao 3.冶炼金属",
        "slug": "lanqiao-3.冶炼金属"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/dev/md/code-blocks",
    "slug": "dev/md/code-blocks",
    "segments": [
      "dev",
      "md",
      "code-blocks"
    ],
    "filePath": "docs/zh/dev/md/code-blocks.mdx",
    "meta": {
      "title": "code blocks",
      "created_at": "2024-10-04",
      "updated_at": "2024-11-09T13:04:17Z",
      "tags": [
        "mdx",
        "sugar-high"
      ],
      "description": "mdx代码高亮, Monaco Editor 使用 TextMate 语法高亮规则和 Tree-sitter 解析器来解析和高亮代码"
    },
    "order": 99,
    "content": "\n## syntax highlighting\n\n> [!TIP]\n> To preserve your formatting within a list, make sure to indent non-fenced code blocks by eight spaces.\n\n### Prism.js\n\nhttps://prismjs.com\n\n#### prismjs\n\n`prismjs` 是一个轻量级、可扩展的语法高亮库。它提供了多种编程语言的语法高亮支持，并且可以通过插件和主题进行扩展和自定义。 `prismjs` 主要负责实际的语法高亮逻辑和样式。\n\n- **作用**：提供语法高亮的核心功能和样式。\n- **使用**：你需要在项目中引入 `prismjs` 的核心库和样式文件，以便在页面上应用语法高亮。\n\n#### rehype-prism-plus\n\n`rehype-prism-plus` 是一个 Rehype 插件，用于在处理 MDX 或 Markdown 文件时，自动为代码块添加语法高亮。它基于 `prismjs`，并在处理 HTML AST（抽象语法树）时，应用 `prismjs` 的语法高亮功能。\n\n- **作用**：在 MDX 或 Markdown 文件的编译过程中，自动为代码块添加语法高亮。\n- **使用**：你需要在 MDX 或 Markdown 文件的编译配置中引入 `rehype-prism-plus`，以便在编译过程中应用语法高亮。\n\n#### 如何协同工作\n\n1. **Prism.js** 提供语法高亮的核心功能和样式。\n2. **rehype-prism-plus** 在编译 MDX 或 Markdown 文件时，使用 `prismjs` 为代码块添加语法高亮。\n\n引入 Prism.js 样式：\n\n```css\n@import 'prismjs/themes/prism.css';\n```\n\n#### prism-react-renderer\n\n```sh\npnpm add prism-react-renderer\n```\n\n### Highlight.js\n\n### monaco-editor\n\n使用 Monaco Editor 实现代码高亮和语法解析。\n\n> Monaco Editor 使用 TextMate 语法高亮规则和 Tree-sitter 解析器来解析和高亮代码。\n\n## test\n\n```md\n# code-highlight with monaco-editor\n> Monaco Editor 使用 TextMate 语法高亮规则和 Tree-sitter 解析器来解析和高亮代码。\n```\n```mdx\n# code-highlight with monaco-editor\n> Monaco Editor 使用 TextMate 语法高亮规则和 Tree-sitter 解析器来解析和高亮代码。\n```\n\n```html\n<!--  -->\n```\n\n$y = sin(x)$\n\n$$\ny = e^x\n$$\n\n要在 MDX 渲染的前端代码块中实现代码提示效果，可以使用以下工具和库：\n\n1. **Prism.js**:\n   - Prism.js 是一个轻量级、可扩展的语法高亮库，适用于现代 web 开发。它支持多种语言和插件，能提供良好的代码高亮效果。\n   - 官网：[Prism.js](https://prismjs.com)\n\n2. **react-syntax-highlighter**:\n   - 这是一个基于 React 的语法高亮组件，支持多种语法高亮库（包括 Prism.js 和 Highlight.js）。\n   - GitHub 仓库：[react-syntax-highlighter](https://github.com/react-syntax-highlighter/react-syntax-highlighter)\n\n3. **Monaco Editor**:\n   - Monaco Editor 是 Visual Studio Code 使用的代码编辑器，支持丰富的代码提示和语法高亮功能。可以嵌入到 web 应用中。\n   - 官网：[Monaco Editor](https://microsoft.github.io/monaco-editor/)\n\n4. **CodeMirror**:\n   - CodeMirror 是一个用于在浏览器中实现代码编辑功能的库，支持多种语言的语法高亮和代码提示。\n   - 官网：[CodeMirror](https://codemirror.net/)\n\n### 示例代码\n\n以下是一个使用 `react-syntax-highlighter` 和 `Prism.js` 实现代码高亮的示例：\n\n```jsx name=\"CodeBlock.jsx\"\nimport { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';\nimport { okaidia } from 'react-syntax-highlighter/dist/esm/styles/prism';\n\nconst codeString = `\n/// <reference types=\"node\" />\nconst fs = require('fs');\n`;\n\nconst CodeBlock = () => (\n  <SyntaxHighlighter language=\"javascript\" style={okaidia}>\n    {codeString}\n  </SyntaxHighlighter>\n);\n\nexport default CodeBlock;\n```\n\n将上述代码块嵌入到你的 MDX 文件中即可实现代码高亮效果。你可以根据需要选择不同的语法高亮库和样式。\n\n```sh\nnpm install @monaco-editor/react\n```\n\n## mdx\n\n### compile time\n\n### runtime\n\n````mdx\n```py copy=\"true\" path=\"example.py\"\ndef foo():\n  return 'bar'\n```\nto\n```jsx\n<>\n<pre copy=\"true\" path=\"example.py\"><code class=\"language-py\">def foo():\n  return 'bar'\n</code></pre>\n</>\n```\n````\n\n\n\n```py copy=\"true\" path=\"example.py\"\ndef foo():\n  return 'bar'\n```\n\n## vscode-theme\n\n### VS Code 主题\n\n1. **配置文件**：\n   - VS Code 主题通常使用 JSON 文件来定义颜色和样式。\n   - 主题文件通常位于 `.vscode` 文件夹中，或者作为 VS Code 扩展的一部分发布。\n\n2. **作用范围**：\n   - VS Code 主题不仅影响代码编辑器，还影响整个 VS Code 界面，包括侧边栏、状态栏、活动栏等。\n\n3. **语法高亮**：\n   - VS Code 使用 TextMate 语法定义文件（通常是 `.tmLanguage` 或 `.plist` 文件）来定义语法高亮规则。\n   - 主题文件中可以指定不同语法元素的颜色和样式。\n\n4. **扩展性**：\n   - 可以通过 VS Code 扩展市场发布和分享主题。\n   - 可以使用 VS Code API 来动态更改主题设置。\n\n### Monaco Editor 主题\n\n1. **配置文件**：\n   - Monaco Editor 主题通常使用 JavaScript 或 JSON 文件来定义颜色和样式。\n   - 主题文件通常直接在代码中定义，并通过 Monaco Editor 的 API 应用。\n\n2. **作用范围**：\n   - Monaco Editor 主题仅影响代码编辑器本身，不影响其他 UI 元素。\n\n3. **语法高亮**：\n   - Monaco Editor 使用内置的语法解析器和高亮规则。\n   - 可以通过 Monaco Editor 的 API 自定义语法高亮规则。\n\n4. **扩展性**：\n   - 主题通常作为应用的一部分，而不是单独的扩展。\n   - 可以通过 Monaco Editor 的 API 动态更改主题设置。\n\n### 示例\n\n#### VS Code 主题示例\n\n```ts copy=\"ture\" path=\"type.ts\" onOpen={props.openDemo} {...props}\ntype vscodeThemeJSON = {\n  name: string\n  type: 'dark' | 'light'\n  semanticHighlighting: boolean // 是否启用语义高亮(即将使用语言服务器提供的语义信息来高亮)\n  colors: {\n    [key: string]: string\n  };\n  tokenColors: {\n    name?: string\n    scope: string | string[]\n    settings: {\n      [key: string]: string\n    };\n  }[];\n};\n```\n\n```jsonc copy=\"ture\" path=\"aa-theme.json\"  onOpen={props.openDemo} {...props}\n{\n  \"name\": \"aa Theme\",\n  \"type\": \"dark\",\n  \"colors\": {\n    \"editor.background\": \"#1E1E1E\", // 编辑器背景颜色\n    \"editor.foreground\": \"#D4D4D4\", // 编辑器前景颜色（默认文本颜色）\n    \"editor.lineHighlightBackground\": \"#3A3D41\", // 当前行高亮背景颜色\n    \"editor.selectionBackground\": \"#264F78\", // 选中文本背景颜色\n    \"editorCursor.foreground\": \"#528BFF\", // 光标颜色\n    \"editorWhitespace.foreground\": \"#3B3A32\", // 空白字符颜色\n    \"editorIndentGuide.background\": \"#3B3A32\", // 缩进指导线颜色\n    \"editorLineNumber.foreground\": \"#858585\", // 行号颜色\n  },\n  \"tokenColors\": [\n    {\n      \"scope\": \"comment\",\n      \"settings\": {\n        \"foreground\": \"#848bbd\",\n        \"fontStyle\": \"italic\"\n      }\n    },\n    {\n      \"scope\": \"keyword\",\n      \"settings\": {\n        \"foreground\": \"#569CD6\"\n      }\n    }\n  ]\n}\n```\n\n#### Monaco Editor 主题示例\n\n```js\nmonaco.editor.defineTheme('myCoolTheme', {\n  base: 'vs-dark',\n  inherit: true,\n  rules: [\n    { token: 'comment', foreground: '6A9955' },\n    { token: 'keyword', foreground: '569CD6' }\n  ],\n  colors: {\n    'editor.background': '#1E1E1E',\n    'editor.foreground': '#D4D4D4'\n  }\n});\n\nmonaco.editor.setTheme('myCoolTheme');\n```\n\n\n\n### code-demo\n\n#### python\n    \n```py\n# 这是一个单行注释 NOTE|XXX|HACK|FIXME|BUG|TODO\n#NOTE|XXX|HACK|FIXME|BUG|TODO\n#这是NOTE|XXX|HACK|FIXME|BUG|TODO\n# type: python xxx\n#type: python\n\"\"\"\n这是一个多行注释（文档字符串）\n\"\"\"\n; # type: ignore\na = 'a'  # type: str\n# keyword.control.import.python \t\n# keyword.control.flow.python\n# from, as 可能来自于扩展\nfrom xxlimited import foo\nimport numpy as np  # 导入模块\n# 导入变量, 函数, 类,模块\nfrom numpy import exp, array, random\nimport scrapy\n\nwith open('file.txt', 'r') as file:  # 打开文件\n    for line in file:  # 循环\n        print(line)  # 打印\n\nasync def bar():\n    pass\n\nclass MyClass(object):  # 类声明\n    \"\"\"\n    usage:\n    >>> my_instance = MyClass(10)\n    \"\"\"\n    def __init__(self, value):  # 函数声明\n        self.value = value  # 赋值操作符\n        self.attribute = 0  # 赋值操作符\n\n    def my_method(self):  # 函数声明\n        # 生成器表达式\n        return (x * x for x in range(10))\n\n    @staticmethod\n    def static_method():  # 静态方法\n        pass\n\n    @classmethod\n    def class_method(cls):  # 类方法\n        pass\n\n    @property\n    def my_property(self):  # 属性\n        return self.value\n\n# 语句关键字\nif __name__ == \"__main__\":\n    PI = 3.14159  # 变量声明\n    my_instance = MyClass(10)  # 赋值操作符\n    print(my_instance.my_method())  # 函数调用\n    print(my_instance.my_property)  # 属性访问\n\n    # 使用分号分隔语句\n    a = 1; b = 2; c = a + b\n\n    # 文档字符串\n    def example_function():\n        \"\"\"\n        这是一个文档字符串\n        \"\"\"\n        pass\n\n    # 装饰器\n    @example_function\n    def decorated_function():\n        pass\n\n    # 生成器\n    def generator():\n        yield 1\n        yield 2\n        yield 3\n\n    for value in generator():\n        print(value)\n```\n\n#### tsx\n```tsx\n<EmptyLines count=\"2\" />\n\n<EmptyLines count=\"2\" />\n```",
    "toc": [
      {
        "depth": 2,
        "value": "syntax highlighting",
        "slug": "syntax-highlighting"
      },
      {
        "depth": 3,
        "value": "Prism.js",
        "slug": "prism.js"
      },
      {
        "depth": 4,
        "value": "prismjs",
        "slug": "prismjs"
      },
      {
        "depth": 4,
        "value": "rehype-prism-plus",
        "slug": "rehype-prism-plus"
      },
      {
        "depth": 4,
        "value": "如何协同工作",
        "slug": "如何协同工作"
      },
      {
        "depth": 4,
        "value": "prism-react-renderer",
        "slug": "prism-react-renderer"
      },
      {
        "depth": 3,
        "value": "Highlight.js",
        "slug": "highlight.js"
      },
      {
        "depth": 3,
        "value": "monaco-editor",
        "slug": "monaco-editor"
      },
      {
        "depth": 2,
        "value": "test",
        "slug": "test"
      },
      {
        "depth": 3,
        "value": "示例代码",
        "slug": "示例代码"
      },
      {
        "depth": 2,
        "value": "mdx",
        "slug": "mdx"
      },
      {
        "depth": 3,
        "value": "compile time",
        "slug": "compile-time"
      },
      {
        "depth": 3,
        "value": "runtime",
        "slug": "runtime"
      },
      {
        "depth": 2,
        "value": "vscode-theme",
        "slug": "vscode-theme"
      },
      {
        "depth": 3,
        "value": "VS Code 主题",
        "slug": "vs-code-主题"
      },
      {
        "depth": 3,
        "value": "Monaco Editor 主题",
        "slug": "monaco-editor-主题"
      },
      {
        "depth": 3,
        "value": "示例",
        "slug": "示例"
      },
      {
        "depth": 4,
        "value": "VS Code 主题示例",
        "slug": "vs-code-主题示例"
      },
      {
        "depth": 4,
        "value": "Monaco Editor 主题示例",
        "slug": "monaco-editor-主题示例"
      },
      {
        "depth": 3,
        "value": "code-demo",
        "slug": "code-demo"
      },
      {
        "depth": 4,
        "value": "python",
        "slug": "python"
      },
      {
        "depth": 4,
        "value": "tsx",
        "slug": "tsx"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/about/community/contribution-guide",
    "slug": "about/community/contribution-guide",
    "segments": [
      "about",
      "community",
      "contribution-guide"
    ],
    "filePath": "docs/zh/about/04-community/01-contribution-guide.mdx",
    "meta": {
      "title": "文档贡献指南",
      "nav_title": "贡献 指南",
      "description": "了解如何贡献文档"
    },
    "order": 1,
    "content": "\n\n\nThis page provides instructions on how to edit the Next.js documentation. Our goal is to ensure that everyone in the community feels empowered to contribute and improve our docs.\n\n## Why Contribute?\n\nOpen-source work is never done, and neither is documentation. Contributing to docs is a good way for beginners to get involved in open-source and for experienced developers to clarify more complex topics while sharing their knowledge with the community.\n\nBy contributing to the Next.js docs, you're helping us build a more robust learning resource for all developers. Whether you've found a typo, a confusing section, or you've realized that a particular topic is missing, your contributions are welcomed and appreciated.\n\n## How to Contribute\n\nThe docs content can be found on the [Next.js repo](https://github.com/vercel/next.js/tree/canary/docs). To contribute, you can edit the files directly on GitHub or clone the repo and edit the files locally.\n\n### GitHub Workflow\n\nIf you're new to GitHub, we recommend reading the [GitHub Open Source Guide](https://opensource.guide/how-to-contribute/#opening-a-pull-request) to learn how to fork a repository, create a branch, and submit a pull request.\n\n> **Good to know**: The underlying docs code lives in a private codebase that is synced to the Next.js public repo. This means that you can't preview the docs locally. However, you'll see your changes on [nextjs.org](https://nextjs.org/docs) after merging a pull request.\n\n### Writing MDX\n\nThe docs are written in [MDX](https://mdxjs.com/), a markdown format that supports JSX syntax. This allows us to embed React components in the docs. See the [GitHub Markdown Guide](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) for a quick overview of markdown syntax.\n\n### VSCode\n\n#### Previewing Changes Locally\n\nVSCode has a built-in markdown previewer that you can use to see your edits locally. To enable the previewer for MDX files, you'll need to add a configuration option to your user settings.\n\nOpen the command palette (`⌘ + ⇧ + P` on Mac or `Ctrl + Shift + P` on Windows) and search from `Preferences: Open User Settings (JSON)`.\n\nThen, add the following line to your `settings.json` file:\n\n```json filename=\"settings.json\"\n{\n  \"files.associations\": {\n    \"*.mdx\": \"markdown\"\n  }\n}\n```\n\nNext, open the command palette again, and search for `Markdown: Preview File` or `Markdown: Open Preview to the Side`. This will open a preview window where you can see your formatted changes.\n\n#### Extensions\n\nWe also recommend the following extensions for VSCode users:\n\n- [MDX](https://marketplace.visualstudio.com/items?itemName=unifiedjs.vscode-mdx): Intellisense and syntax highlighting for MDX.\n- [Prettier](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode): Format MDX files on save.\n\n### Review Process\n\nOnce you've submitted your contribution, the Next.js or Developer Experience teams will review your changes, provide feedback, and merge the pull request when it's ready.\n\nPlease let us know if you have any questions or need further assistance in your PR's comments. Thank you for contributing to the Next.js docs and being a part of our community!\n\n> **Tip:** Run `pnpm prettier-fix` to run Prettier before submitting your PR.\n\n## File Structure\n\nThe docs use **file-system routing**. Each folder and files inside [`/docs`](https://github.com/vercel/next.js/tree/canary/docs) represent a route segment. These segments are used to generate the URL paths, navigation, and breadcrumbs.\n\nThe file structure reflects the navigation that you see on the site, and by default, navigation items are sorted alphabetically. However, we can change the order of the items by prepending a two-digit number (`00-`) to the folder or file name.\n\nFor example, in the [functions API Reference](/docs/app/api-reference/functions), the pages are sorted alphabetically because it makes it easier for developers to find a specific function:\n\n```txt\n04-functions\n├── after.mdx\n├── cacheLife.mdx\n├── cacheTag.mdx\n└── ...\n```\n\nBut, in the [routing section](/docs/app/building-your-application/routing), the files are prefixed with a two-digit number, sorted in the order developers should learn these concepts:\n\n```txt\n01-routing\n├── 01-defining-routes.mdx\n├── 02-pages.mdx\n├── 03-layouts-and-templates.mdx\n└── ...\n```\n\nTo quickly find a page, you can use `⌘ + P` (Mac) or `Ctrl + P` (Windows) to open the search bar on VSCode. Then, type the slug of the page you're looking for. E.g. `defining-routes`\n\n> **Why not use a manifest?**\n>\n> We considered using a manifest file (another popular way to generate the docs navigation), but we found that a manifest would quickly get out of sync with the files. File-system routing forces us to think about the structure of the docs and feels more native to Next.js.\n\n## Metadata\n\nEach page has a metadata block at the top of the file separated by three dashes.\n\n### Required Fields\n\nThe following fields are **required**:\n\n| Field         | Description                                                                  |\n| ------------- | ---------------------------------------------------------------------------- |\n| `title`       | The page's `<h1>` title, used for SEO and OG Images.                         |\n| `description` | The page's description, used in the `<meta name=\"description\">` tag for SEO. |\n\n```yaml filename=\"required-fields.mdx\"\n---\ntitle: Page Title\ndescription: Page Description\n---\n```\n\nIt's good practice to limit the page title to 2-3 words (e.g. Optimizing Images) and the description to 1-2 sentences (e.g. Learn how to optimize images in Next.js).\n\n### Optional Fields\n\nThe following fields are **optional**:\n\n| Field       | Description                                                                                                                                        |\n| ----------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `nav_title` | Overrides the page's title in the navigation. This is useful when the page's title is too long to fit. If not provided, the `title` field is used. |\n| `source`    | Pulls content into a shared page. See [Shared Pages](#shared-pages).                                                                               |\n| `related`   | A list of related pages at the bottom of the document. These will automatically be turned into cards. See [Related Links](#related-links).         |\n| `version`   | A stage of development. e.g. `experimental`,`legacy`,`unstable`,`RC`                                                                               |\n\n```yaml filename=\"optional-fields.mdx\"\n---\nnav_title: Nav Item Title\nsource: app/building-your-application/optimizing/images\nrelated:\n  description: See the image component API reference.\n  links:\n    - app/api-reference/components/image\nversion: experimental\n---\n```\n\n## `App` and `Pages` Docs\n\nSince most of the features in the **App Router** and **Pages Router** are completely different, their docs for each are kept in separate sections (`02-app` and `03-pages`). However, there are a few features that are shared between them.\n\n### Shared Pages\n\nTo avoid content duplication and risk the content becoming out of sync, we use the `source` field to pull content from one page into another. For example, the `<Link>` component behaves _mostly_ the same in **App** and **Pages**. Instead of duplicating the content, we can pull the content from `app/.../link.mdx` into `pages/.../link.mdx`:\n\n```mdx filename=\"app/.../link.mdx\"\n---\ntitle: <Link>\ndescription: API reference for the <Link> component.\n---\n\nThis API reference will help you understand how to use the props\nand configuration options available for the Link Component.\n```\n\n```mdx filename=\"pages/.../link.mdx\"\n---\ntitle: <Link>\ndescription: API reference for the <Link> component.\nsource: app/api-reference/components/link\n---\n\n{/* DO NOT EDIT THIS PAGE. */}\n{/* The content of this page is pulled from the source above. */}\n```\n\nWe can therefore edit the content in one place and have it reflected in both sections.\n\n### Shared Content\n\nIn shared pages, sometimes there might be content that is **App Router** or **Pages Router** specific. For example, the `<Link>` component has a `shallow` prop that is only available in **Pages** but not in **App**.\n\nTo make sure the content only shows in the correct router, we can wrap content blocks in an `<AppOnly>` or `<PagesOnly>` components:\n\n```mdx filename=\"app/.../link.mdx\"\nThis content is shared between App and Pages.\n\n<PagesOnly>\n\nThis content will only be shown on the Pages docs.\n\n</PagesOnly>\n\nThis content is shared between App and Pages.\n```\n\nYou'll likely use these components for examples and code blocks.\n\n## Code Blocks\n\nCode blocks should contain a minimum working example that can be copied and pasted. This means that the code should be able to run without any additional configuration.\n\nFor example, if you're showing how to use the `<Link>` component, you should include the `import` statement and the `<Link>` component itself.\n\n```tsx filename=\"app/page.tsx\"\nimport Link from 'next/link'\n\nexport default function Page() {\n  return <Link href=\"/about\">About</Link>\n}\n```\n\nAlways run examples locally before committing them. This will ensure that the code is up-to-date and working.\n\n### Language and Filename\n\nCode blocks should have a header that includes the language and the `filename`. Add a `filename` prop to render a special Terminal icon that helps orientate users where to input the command. For example:\n\n````mdx filename=\"code-example.mdx\"\n```bash filename=\"Terminal\"\nnpx create-next-app\n```\n````\n\nMost examples in the docs are written in `tsx` and `jsx`, and a few in `bash`. However, you can use any supported language, here's the [full list](https://github.com/shikijs/shiki/blob/main/docs/languages.md#all-languages).\n\nWhen writing JavaScript code blocks, we use the following language and extension combinations.\n\n|                                | Language | Extension |\n| ------------------------------ | -------- | --------- |\n| JavaScript files with JSX code | ```jsx   | .js       |\n| JavaScript files without JSX   | ```js    | .js       |\n| TypeScript files with JSX      | ```tsx   | .tsx      |\n| TypeScript files without JSX   | ```ts    | .ts       |\n\n> **Good to know**:\n>\n> - Make sure to use **`js`** extension with **JSX** code at JavaScript files.\n> - For example, ```jsx filename=\"app/layout.js\"\n\n### TS and JS Switcher\n\nAdd a language switcher to toggle between TypeScript and JavaScript. Code blocks should be TypeScript first with a JavaScript version to accommodate users.\n\nCurrently, we write TS and JS examples one after the other, and link them with `switcher` prop:\n\n````mdx filename=\"code-example.mdx\"\n```tsx filename=\"app/page.tsx\" switcher\n\n```\n\n```jsx filename=\"app/page.js\" switcher\n\n```\n````\n\n> **Good to know**: We plan to automatically compile TypeScript snippets to JavaScript in the future. In the meantime, you can use [transform.tools](https://transform.tools/typescript-to-javascript).\n\n### Line Highlighting\n\nCode lines can be highlighted. This is useful when you want to draw attention to a specific part of the code. You can highlight lines by passing a number to the `highlight` prop.\n\n**Single Line:** `highlight={1}`\n\n```tsx filename=\"app/page.tsx\" {1}\nimport Link from 'next/link'\n\nexport default function Page() {\n  return <Link href=\"/about\">About</Link>\n}\n```\n\n**Multiple Lines:** `highlight={1,3}`\n\n```tsx filename=\"app/page.tsx\" highlight={1,3}\nimport Link from 'next/link'\n\nexport default function Page() {\n  return <Link href=\"/about\">About</Link>\n}\n```\n\n**Range of Lines:** `highlight={1-5}`\n\n```tsx filename=\"app/page.tsx\" highlight={1-5}\nimport Link from 'next/link'\n\nexport default function Page() {\n  return <Link href=\"/about\">About</Link>\n}\n```\n\n## Icons\n\nThe following icons are available for use in the docs:\n\n```mdx filename=\"mdx-icon.mdx\"\n<Check size={18} />\n<Cross size={18} />\n```\n\n**Output:**\n\n<Check size={18} />\n<Cross size={18} />\n\nWe do not use emojis in the docs.\n\n## Notes\n\nFor information that is important but not critical, use notes. Notes are a good way to add information without distracting the user from the main content.\n\n```mdx filename=\"notes.mdx\"\n> **Good to know**: This is a single line note.\n\n> **Good to know**:\n>\n> - We also use this format for multi-line notes.\n> - There are sometimes multiple items worth knowing or keeping in mind.\n```\n\n**Output:**\n\n> **Good to know**: This is a single line note.\n\n> **Good to know**:\n>\n> - We also use this format for multi-line notes.\n> - There are sometimes multiple items worth knowing or keeping in mind.\n\n## Related Links\n\nRelated Links guide the user's learning journey by adding links to logical next steps.\n\n- Links will be displayed in cards under the main content of the page.\n- Links will be automatically generated for pages that have child pages. For example, the [Optimizing](/docs/app/building-your-application/optimizing) section has links to all of its child pages.\n\nCreate related links using the `related` field in the page's metadata.\n\n```yaml filename=\"example.mdx\"\n---\nrelated:\n  description: Learn how to quickly get started with your first application.\n  links:\n    - app/building-your-application/routing/defining-routes\n    - app/building-your-application/data-fetching\n    - app/api-reference/file-conventions/page\n---\n```\n\n### Nested Fields\n\n| Field         | Required? | Description                                                                                                                                               |\n| ------------- | --------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `title`       | Optional  | The title of the card list. Defaults to **Next Steps**.                                                                                                   |\n| `description` | Optional  | The description of the card list.                                                                                                                         |\n| `links`       | Required  | A list of links to other doc pages. Each list item should be a relative URL path (without a leading slash) e.g. `app/api-reference/file-conventions/page` |\n\n## Diagrams\n\nDiagrams are a great way to explain complex concepts. We use [Figma](https://www.figma.com/) to create diagrams, following Vercel's design guide.\n\nThe diagrams currently live in the `/public` folder in our private Next.js site. If you'd like to update or add a diagram, please open a [GitHub issue](https://github.com/vercel/next.js/issues/new?assignees=&labels=template%3A+documentation&projects=&template=4.docs_request.yml&title=Docs%3A+) with your ideas.\n\n## Custom Components and HTML\n\nThese are the React Components available for the docs: `<Image />` (next/image), `<PagesOnly />`, `<AppOnly />`, `<Cross />`, and `<Check />`. We do not allow raw HTML in the docs besides the `<details>` tag.\n\nIf you have ideas for new components, please open a [GitHub issue](https://github.com/vercel/next.js/issues/new/choose).\n\n## Style Guide\n\nThis section contains guidelines for writing docs for those who are new to technical writing.\n\n### Page Templates\n\nWhile we don't have a strict template for pages, there are page sections you'll see repeated across the docs:\n\n- **Overview:** The first paragraph of a page should tell the user what the feature is and what it's used for. Followed by a minimum working example or its API reference.\n- **Convention:** If the feature has a convention, it should be explained here.\n- **Examples**: Show how the feature can be used with different use cases.\n- **API Tables**: API Pages should have an overview table at the of the page with jump-to-section links (when possible).\n- **Next Steps (Related Links)**: Add links to related pages to guide the user's learning journey.\n\nFeel free to add these sections as needed.\n\n### Page Types\n\nDocs pages are also split into two categories: Conceptual and Reference.\n\n- **Conceptual** pages are used to explain a concept or feature. They are usually longer and contain more information than reference pages. In the Next.js docs, conceptual pages are found in the **Building Your Application** section.\n- **Reference** pages are used to explain a specific API. They are usually shorter and more focused. In the Next.js docs, reference pages are found in the **API Reference** section.\n\n> **Good to know**: Depending on the page you're contributing to, you may need to follow a different voice and style. For example, conceptual pages are more instructional and use the word _you_ to address the user. Reference pages are more technical, they use more imperative words like \"create, update, accept\" and tend to omit the word _you_.\n\n### Voice\n\nHere are some guidelines to maintain a consistent style and voice across the docs:\n\n- Write clear, concise sentences. Avoid tangents.\n  - If you find yourself using a lot of commas, consider breaking the sentence into multiple sentences or use a list.\n  - Swap out complex words for simpler ones. For example, _use_ instead of _utilize_.\n- Be mindful with the word _this_. It can be ambiguous and confusing, don't be afraid to repeat the subject of the sentence if unclear.\n  - For example, _Next.js uses React_ instead of _Next.js uses this_.\n- Use an active voice instead of passive. An active sentence is easier to read.\n  - For example, _Next.js uses React_ instead of _React is used by Next.js_. If you find yourself using words like _was_ and _by_ you may be using a passive voice.\n- Avoid using words like _easy_, _quick_, _simple_, _just_, etc. This is subjective and can be discouraging to users.\n- Avoid negative words like _don't_, _can't_, _won't_, etc. This can be discouraging to readers.\n  - For example, _\"You can use the `Link` component to create links between pages\"_ instead of _\"Don't use the `<a>` tag to create links between pages\"_.\n- Write in second person (you/your). This is more personal and engaging.\n- Use gender-neutral language. Use _developers_, _users_, or _readers_, when referring to the audience.\n- If adding code examples, ensure they are properly formatted and working.\n\nWhile these guidelines are not exhaustive, they should help you get started. If you'd like to dive deeper into technical writing, check out the [Google Technical Writing Course](https://developers.google.com/tech-writing/overview).\n\n---\n\nThank you for contributing to the docs and being part of the Next.js community!\n\n{/* To do: Latest Contributors Component */}",
    "toc": [
      {
        "depth": 2,
        "value": "Why Contribute?",
        "slug": "why-contribute?"
      },
      {
        "depth": 2,
        "value": "How to Contribute",
        "slug": "how-to-contribute"
      },
      {
        "depth": 3,
        "value": "GitHub Workflow",
        "slug": "github-workflow"
      },
      {
        "depth": 3,
        "value": "Writing MDX",
        "slug": "writing-mdx"
      },
      {
        "depth": 3,
        "value": "VSCode",
        "slug": "vscode"
      },
      {
        "depth": 4,
        "value": "Previewing Changes Locally",
        "slug": "previewing-changes-locally"
      },
      {
        "depth": 4,
        "value": "Extensions",
        "slug": "extensions"
      },
      {
        "depth": 3,
        "value": "Review Process",
        "slug": "review-process"
      },
      {
        "depth": 2,
        "value": "File Structure",
        "slug": "file-structure"
      },
      {
        "depth": 2,
        "value": "Metadata",
        "slug": "metadata"
      },
      {
        "depth": 3,
        "value": "Required Fields",
        "slug": "required-fields"
      },
      {
        "depth": 3,
        "value": "Optional Fields",
        "slug": "optional-fields"
      },
      {
        "depth": 2,
        "value": "App and Pages Docs",
        "slug": "app-and-pages-docs"
      },
      {
        "depth": 3,
        "value": "Shared Pages",
        "slug": "shared-pages"
      },
      {
        "depth": 3,
        "value": "Shared Content",
        "slug": "shared-content"
      },
      {
        "depth": 2,
        "value": "Code Blocks",
        "slug": "code-blocks"
      },
      {
        "depth": 3,
        "value": "Language and Filename",
        "slug": "language-and-filename"
      },
      {
        "depth": 3,
        "value": "TS and JS Switcher",
        "slug": "ts-and-js-switcher"
      },
      {
        "depth": 3,
        "value": "Line Highlighting",
        "slug": "line-highlighting"
      },
      {
        "depth": 2,
        "value": "Icons",
        "slug": "icons"
      },
      {
        "depth": 2,
        "value": "Notes",
        "slug": "notes"
      },
      {
        "depth": 2,
        "value": "Related Links",
        "slug": "related-links"
      },
      {
        "depth": 3,
        "value": "Nested Fields",
        "slug": "nested-fields"
      },
      {
        "depth": 2,
        "value": "Diagrams",
        "slug": "diagrams"
      },
      {
        "depth": 2,
        "value": "Custom Components and HTML",
        "slug": "custom-components-and-html"
      },
      {
        "depth": 2,
        "value": "Style Guide",
        "slug": "style-guide"
      },
      {
        "depth": 3,
        "value": "Page Templates",
        "slug": "page-templates"
      },
      {
        "depth": 3,
        "value": "Page Types",
        "slug": "page-types"
      },
      {
        "depth": 3,
        "value": "Voice",
        "slug": "voice"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/alg/greedy",
    "slug": "alg/greedy",
    "segments": [
      "alg",
      "greedy"
    ],
    "filePath": "docs/zh/alg/greedy/index.mdx",
    "meta": {
      "title": "贪心算法",
      "description": "贪心算法（Greedy Algorithm）是一种在每一步选择中都做出局部最优解的算法. 它的核心思想是通过局部最优解，尝试得到全局最优解. 简单高效，适合某些特定问题. 需要证明贪心选择的正确性",
      "created_at": "2025-03-23T22:32:27.000Z",
      "updated_at": "2025-03-23T22:32:27.000Z",
      "tags": [
        "greedy",
        "alg"
      ]
    },
    "order": 99,
    "content": "\n## 为什么学习贪心算法？\n\n## 例题\n\n### 2024_CA_省C.训练士兵\n\n- P10387 [蓝桥杯 2024 省 A] 训练士兵 - https://www.luogu.com.cn/problem/P10387\n\n#### 题目描述\n\n有 $n$ 名士兵，这些士兵需要接受一系列特殊的训练，以提升他们的战斗技能。对于第 $i$ 名士兵来说，进行一次训练所需的成本为 $p_i$ 枚金币，而要想成为顶尖战士，他至少需要进行 $c_i$ 次训练。  \n为了确保训练的高效性，王国推出了一种组团训练的方案。该方案包含每位士兵所需的一次训练，且总共只需支付 $S$ 枚金币（组团训练方案可以多次购买，即士兵可以进行多次组团训练）。  \n作为训练指挥官，请你计算出最少需要花费多少金币，才能使得所有的士兵都成为顶尖战士？\n\n#### 输入格式\n\n输入的第一行包含两个整数 $n$ 和 $S$，用一个空格分隔，表示士兵的数量和进行一次组团训练所需的金币数。  \n接下来的 $n$ 行，每行包含两个整数 $p_i$ 和 $c_i$，用一个空格分隔，表示第 $i$ 名士兵进行一次训练的金币成本和要成为顶尖战士所需的训练次数。\n\n#### 输出格式\n\n输出一行包含一个整数，表示使所有士兵成为顶尖战士所需的最少金币数。\n\n#### 输入输出样例\n\n##### 输入\n\n```\n3 6\n5 2\n2 4\n3 2\n```\n\n##### 输出\n\n```\n16\n```\n\n#### 说明/提示\n\n花费金币最少的训练方式为：进行 $2$ 次组团训练，花费 $2 × 6 = 12$ 枚金币，此时士兵 $1, 3$ 已成为顶尖战士；再花费 $4$ 枚金币，让士兵 $2$ 进行两次训练，成为顶尖战士。总花费为 $12 + 4 = 16$。\n\n对于 $40\\%$ 的评测用例，$1 ≤ n ≤ 10^3，1 ≤ p_i\n, c_i ≤ 10^5，1 ≤ S ≤ 10^7$。\n\n对于所有评测用例，$1 ≤ n ≤ 10^5，1 ≤ p_i\n, c_i ≤ 10^6，1 ≤ S ≤ 10^{10}$。\n\n#### 思路\n\n- 按照需要训练的次数 $c_i$ 升序排序\n- 维护一个动态的 $cnt$, 表示已经组团训练的次数\n- 维护一个动态的 $tot$, 表示当前训练所有士兵一次的总成本, 用于和 $S$ 比较\n- 初始化总花费 $res:=0$, 遍历一遍 n, 表示按照 $c_i$ 的顺序训练士兵时, 选择组团训练还是单独训练\n  - 如果 $S \\leq tot$, 表示当前组团训练比单独训练剩下的士兵要便宜\n    - 则选择组团训练 $c_i-cnt$ 次, $res := res + (c_i-cnt) \\times S$\n    - 并更新 $cnt:=c_i$\n  - 否则, 表示当前训练所有士兵一次的总成本大于 $S$, 则选择单独训练\n    - 则单独将这个人训练 $c_i$ 次, $res := res + (c_i-cnt) \\times p_i$\n  - 这次迭代结束说明 第 $i$ 个士兵训练完成, 更新 $tot$\n    - $tot := tot - p_i$\n#### 代码示例: \n```py\n# 获得输入\nn, S = map(int, input().split())\nmatrix_p_c = [[0,0]] * n\nfor i in range(n):\n    matrix_p_c[i] = list(map(int, input().split()))\n# 按照需要训练的次数 $c_i$ 从升序排序\np, c = [0] * n, [0] * n\nmatrix_p_c.sort(key=lambda x: x[1])\nfor i in range(n):\n    p[i], c[i] = matrix_p_c[i][0], matrix_p_c[i][1]\n# 初始化\nres, cnt, tot = 0, 0, sum(p)\n# 遍历\nfor i in range(n):\n    if S <= tot:\n        res += (c[i] - cnt) * S\n        cnt = c[i]\n    else:\n        res += (c[i] - cnt) * p[i]\n    tot -= p[i]\nprint(res)\n```",
    "toc": [
      {
        "depth": 2,
        "value": "为什么学习贪心算法？",
        "slug": "为什么学习贪心算法？"
      },
      {
        "depth": 2,
        "value": "例题",
        "slug": "例题"
      },
      {
        "depth": 3,
        "value": "2024_CA_省C.训练士兵",
        "slug": "2024_ca_省c.训练士兵"
      },
      {
        "depth": 4,
        "value": "题目描述",
        "slug": "题目描述"
      },
      {
        "depth": 4,
        "value": "输入格式",
        "slug": "输入格式"
      },
      {
        "depth": 4,
        "value": "输出格式",
        "slug": "输出格式"
      },
      {
        "depth": 4,
        "value": "输入输出样例",
        "slug": "输入输出样例"
      },
      {
        "depth": 5,
        "value": "输入",
        "slug": "输入"
      },
      {
        "depth": 5,
        "value": "输出",
        "slug": "输出"
      },
      {
        "depth": 4,
        "value": "说明/提示",
        "slug": "说明/提示"
      },
      {
        "depth": 4,
        "value": "思路",
        "slug": "思路"
      },
      {
        "depth": 4,
        "value": "代码示例:",
        "slug": "代码示例:"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/alg/enum/pruning",
    "slug": "alg/enum/pruning",
    "segments": [
      "alg",
      "enum",
      "pruning"
    ],
    "filePath": "docs/zh/alg/enum/pruning.mdx",
    "meta": {
      "title": "剪枝",
      "description": "提前终止不必要的计算, 减少搜索空间, 多用于回溯法、搜索问题",
      "created_at": "2025-03-25T03:56:52.000Z",
      "updated_at": "2025-03-25T03:56:52.000Z",
      "tags": [
        "alg",
        "pruning"
      ]
    },
    "order": 99,
    "content": "",
    "toc": []
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/alg/enum",
    "slug": "alg/enum",
    "segments": [
      "alg",
      "enum"
    ],
    "filePath": "docs/zh/alg/enum/index.mdx",
    "meta": {
      "title": "穷举法",
      "description": "这是一个非常好的起点！暴力枚举是解决算法问题的基础方法之一，尤其是在解空间有限的情况下。虽然暴力枚举通常不是最优解，但它是理解问题和验证复杂算法的关键工具。",
      "created_at": "2025-03-22T16:40:54.000Z",
      "updated_at": "2025-03-22T16:40:54.000Z",
      "tags": [
        "alg",
        "enum"
      ]
    },
    "order": 99,
    "content": "\n以下是关于**如何学习暴力枚举**的详细指导：\n\n## 什么是暴力枚举？\n\n暴力枚举（Brute Force）是一种**穷举法**，即尝试所有可能的解，逐一验证每个解是否满足问题的条件。它的核心思想是：\n1. **生成所有可能的解**。\n2. **逐一验证每个解是否满足条件**。\n3. **返回满足条件的解（或最优解）**。\n\n## 学习暴力枚举的步骤\n\n### **理解问题的解空间**\n- 解空间是指问题所有可能解的集合。\n- 在暴力枚举中，你需要明确解空间的大小，以及如何生成所有可能的解。\n\n**示例**：\n- 如果问题是“从数组 `[1, 2, 3]{:py}` 中选择两个数”，解空间是所有可能的数对：`(1, 2), (1, 3), (2, 3){:py}`。\n- 如果问题是“排列字符串 `abc{:.str}` 的所有可能顺序”，解空间是所有排列：`abc, acb, bac, bca, cab, cba{:.str}`。\n\n### **生成所有可能的解**\n- 使用循环、递归或组合工具生成解空间。\n- 常见的生成方法：\n  - **单层循环**：用于简单的线性枚举。\n  - **多层嵌套循环**：用于枚举多维解空间。\n  - **递归**：用于生成排列、组合等复杂解空间。\n  - **工具库**：如 Python 的 `itertools`。\n\n**示例**：\n- **单层循环**：\n  ```python\n  for i in range(1, 5):  # 枚举 1 到 4\n      print(i)\n  ```\n\n- **多层嵌套循环**：\n  ```python\n  for i in range(1, 4):  # 第一层\n      for j in range(1, 4):  # 第二层\n          print(i, j)  # 枚举所有 (i, j) 对\n  ```\n\n- **递归生成排列**：\n  ```python\n  def permute(nums, path=[]):\n      if not nums:\n          print(path)  # 输出一个排列\n          return\n      for i in range(len(nums)):\n          permute(nums[:i] + nums[i+1:], path + [nums[i]])\n\n  permute([1, 2, 3])  # 输出 [1, 2, 3] 的所有排列\n  ```\n\n- **使用工具库**：\n  ```python\n  from itertools import permutations\n\n  for p in permutations([1, 2, 3]):\n      print(p)  # 输出 [1, 2, 3] 的所有排列\n  ```\n\n---\n\n### **验证解是否满足条件**\n- 对每个生成的解，验证它是否满足题目要求。\n- 验证逻辑通常是一个条件判断（`if` 语句）。\n\n**示例**：\n- 验证一个数是否是偶数：\n  ```python\n  for i in range(1, 10):\n      if i % 2 == 0:  # 验证是否是偶数\n          print(i)\n  ```\n\n- 验证一个排列是否满足特定条件：\n  ```python\n  from itertools import permutations\n\n  for p in permutations([1, 2, 3]):\n      if p[0] < p[1]:  # 验证第一个数小于第二个数\n          print(p)\n  ```\n\n---\n\n### **优化暴力枚举**\n暴力枚举的核心问题是**效率低**，尤其是当解空间很大时。因此，学习暴力枚举时，也需要掌握一些优化技巧：\n- **剪枝**：在生成解的过程中，提前排除不可能的解。\n  ```python\n  for i in range(1, 10):\n      if i % 2 != 0:  # 剪枝：跳过奇数\n          continue\n      print(i)\n  ```\n\n- **提前终止**：如果找到一个解就可以结束枚举，则不需要继续。\n  ```python\n  for i in range(1, 10):\n      if i == 5:  # 找到解后终止\n          print(\"Found:\", i)\n          break\n  ```\n\n- **减少嵌套循环**：通过数学公式或逻辑简化枚举过程。\n\n## 学习暴力枚举的练习题\n\n### **简单枚举**\n- **题目**：枚举 1 到 100 中所有的偶数。\n  ```python\n  for i in range(1, 101):\n      if i % 2 == 0:\n          print(i)\n  ```\n\n### **多层枚举**\n- **题目**：枚举所有两位数的组合。\n  ```python\n  for i in range(10, 100):\n      for j in range(10, 100):\n          print(i, j)\n  ```\n\n### **排列与组合**\n- **题目**：生成数组 `[1, 2, 3]` 的所有排列。\n  ```python\n  from itertools import permutations\n\n  for p in permutations([1, 2, 3]):\n      print(p)\n  ```\n\n### **验证条件**\n- **题目**：从数组 `[1, 2, 3, 4]` 中选择两个数，要求它们的和为 5。\n  ```python\n  for i in range(1, 5):\n      for j in range(i + 1, 5):\n          if i + j == 5:\n              print(i, j)\n  ```\n\n### **复杂枚举**\n- **题目**：生成长度为 3 的二进制字符串。\n  ```python\n  for i in range(2):\n      for j in range(2):\n          for k in range(2):\n              print(f\"{i}{j}{k}\")\n  ```\n\n## 学习暴力枚举的资源\n\n1. **书籍**：\n   - 《算法导论》（Introduction to Algorithms）—— Thomas H. Cormen\n   - 《编程之美》—— Microsoft Research\n\n2. **在线平台**：\n   - **LeetCode**：从简单题目开始，逐步挑战更复杂的题目。\n   - **HackerRank**：适合练习基础算法和枚举问题。\n   - **Codeforces**：适合练习竞赛题目。\n\n3. **工具**：\n   - 使用 Python 的 `itertools` 库简化排列和组合的生成。\n   - 使用可视化工具（如 [VisuAlgo](https://visualgo.net/)）帮助理解枚举过程。\n\n## 学习路径建议\n\n1. **从简单问题开始**：\n   - 练习单层循环和多层循环的枚举。\n   - 理解如何生成解空间。\n\n2. **逐步增加复杂度**：\n   - 学习排列、组合的生成方法。\n   - 练习验证条件的逻辑。\n\n3. **优化暴力枚举**：\n   - 学习剪枝和提前终止的技巧。\n   - 理解如何减少不必要的计算。\n\n4. **结合实际问题**：\n   - 在实际问题中应用暴力枚举，逐步积累经验。\n\n## 总结\n\n暴力枚举是算法学习的基础，掌握它可以帮助你更好地理解问题和验证复杂算法。学习暴力枚举的关键是：\n1. **理解解空间**：明确所有可能的解。\n2. **生成解空间**：使用循环、递归或工具库生成解。\n3. **验证解**：逐一验证每个解是否满足条件。\n4. **优化枚举**：通过剪枝和提前终止提高效率。\n\n通过不断练习和总结，你会发现暴力枚举不仅简单，而且非常实用。如果你有具体的题目或问题，可以随时告诉我，我会帮助你分析和解答！\n\n## 例题\n\n[LeetCode 1. 两数之和](https://leetcode-cn.com/problems/two-sum/description/) \n\n给定一个整数数组 `nums` 和一个整数目标值 `target` ,请你在该数组中找出 和为目标值 `target`  的那 两个 整数，并返回它们的数组下标。 <br/>\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。<br/>\n你可以按任意顺序返回答案。<br/>\n\n**示例 1:**<br/>\n**输入:** `nums = [2,7,11,15], target = 9{:py}`<br/>\n**输出:** `[0,1]`<br/>\n**解释:** 因为 `nums[0] + nums[1] == 9{:py}` ，返回 `[0, 1]{:py}` 。<br/>\n\n**示例 2:**<br/>\n**输入:** `nums = [3,2,4], target = 6{:py}`<br/>\n**输出:** `[1,2]`<br/>\n\n**示例 3:**<br/>\n**输入:** `nums = [3,3], target = 6{:py}`<br/>\n**输出:** `[0,1]{:py}`<br/>\n\n**提示:**\n- $2 \\leq nums.length \\leq 10^4$\n- $-10^9 \\leq nums[i] \\leq 10^9$\n- $-10^9 \\leq target \\leq 10^9$\n- 只会存在一个有效答案<br/>\n\n**进阶:** 你可以想出一个时间复杂度小于 $O(n^2)$ 的算法吗？\n\n### 解法1: 穷举解空间\n1. 两层循环遍历数组，找到和为目标值的两个数。\n```py\ndef twoSum(self, nums: List[int], target: int) -> List[int]:\n    n = len(nums)\n    for i in range(n):\n        for j in range(n): # 注意到这里没有排除 i==j 的情况, 例如 [3, 3], 6 会导致结构为 [0, 0]\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return []\n```\n> [!bug]\n> 这个写法是错误的, 因为没有排除 `i==j` 的情况, 例如 `[3, 3], 6` 会导致结果为 `[0, 0]`\n\n**修复:**\n```py\ndef twoSum(self, nums: List[int], target: int) -> List[int]:\n    n = len(nums)\n    for i in range(n):\n        for j in range(n):\n            if i == j: # 排除 i==j 的情况\n                continue\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return []\n```\n> [!success]\n> 这样就能得到正确答案啦 :), 但是时间复杂度是 $O(n^2)$ 的数量级, 因为我们需要遍历两遍数组\n### 解法2: 减少搜索空间(剪枝思想)+穷举\n**注意到:**\n例如: `[2, 7, 11], 9`, 最多会比较 $n\\times n$次, 实际上最多只需要比较: `2 + 7`, `2 + 11`, `7 + 11`, 即$\\frac{n^2-n}{2}$次, 写成矩阵(表格):\n```math\n\\begin{bmatrix}\n0 & 2 & 7 & 11 \\\\\n2 & 2+2 & 2+7 & 2+11 \\\\\n7 & 7+2 & 7+7 & 7+11 \\\\\n11 & 11+2 & 11+7 & 11+11 \\\\\n\\end{bmatrix}\n```\n> [!INFO]\n> 1. 如下证明可以参考: [等差数列求和](https://zh.wikipedia.org/wiki/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E6%B1%82%E5%92%8C) <br/>\n> $$\n> \\frac{n^2-n}{2}=\\sum_{i=1}^{n-1}i=1+2+3+...+(n-1)=\\frac{n(n-1)}{2}\n> $$ \n> 2. 这里写了矩阵这个术语不要感到意外, 此处仅是用来展示一个表格, 不是用来运算\n\n  \n如果直接遍历两遍, 相当于计算(判断)了9次, 实际上我们只需要又上小角落或左下角落的三个元素, 所以可以优化一下:\n```py\ndef twoSum(self, nums: List[int], target: int) -> List[int]:\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n): # 优化: 从 i+1 开始\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return []\n```\n这样我们相当于只计算了:\n```math\n\\begin{bmatrix}\n0 & 2 & 7 & 11 \\\\\n2 &  & 2+7 & 2+11 \\\\\n7 &  &  & 7+11 \\\\\n11 &  &  &  \\\\\n\\end{bmatrix}\n```\n至此, 时间复杂度仍然是 $O(n^2)$ 的数量级, 只是比原来的大概少了$\\frac{n^2+n}{2}$ (可以明显看到), 大概是因为 如果找到了答案, 就不会继续遍历了, 因此 都不会是完整的遍历, 不会刚好少了这么多\n\n对于这个方法的另外一个写法:\n```py\ndef twoSum(self, nums: List[int], target: int) -> List[int]:\n    n = len(nums)\n    for i in range(n):\n        y = target - nums[i]\n        if y in nums[i+1:]:\n            return [i, nums.index(y, i+1)]\n    return []\n```\n> [!warning]\n> 这个另外一个写法, 并不会降低时间复杂度, 甚至会增加时间复杂度, 因为 `in` 和 `index` 都是 $O(n)$ 的时间复杂度, 所以这个写法的时间复杂度是 $O(n^2)$\n\n### 解法3: 记录前缀信息(前缀和思想)+哈希表\n\n从上面的解法可以想到: 如果将已经遍历过的数字和对应的索引作为值存储到一个字典中, 那么在遍历的时候, 可以直接判断 `target - nums[i]` 是否在字典中, 如果在, 那么就找到了答案, 这样就可以将时间复杂度降低到 $O(n)$\n> [!tip]\n> 1. 字典的 `in` 和 `get` 方法的时间复杂度是 $O(1)$, `get`也可以用类似列表获取索引那样使用dict[key] 这种语法\n> 2. 关于字典的定义(设计): 把 数组中的数字 作为key, 索引作为 value, 是因为 需要直接比较 是否有符合的数字, 且当符合时, 需要返回索引, 故这个设计是合理的\n```py\ndef twoSum(self, nums: List[int], target: int) -> List[int]:\n    hashmap = {} # key: 数字, value: 索引\n    for i, num in enumerate(nums):\n        if target - num in hashmap: # 判断是否有符合的数字, O(1)\n            return [hashmap[target - num], i] # 通过key拿到value, O(1)\n        hashmap[num] = i\n    return []\n```\n\n",
    "toc": [
      {
        "depth": 2,
        "value": "什么是暴力枚举？",
        "slug": "什么是暴力枚举？"
      },
      {
        "depth": 2,
        "value": "学习暴力枚举的步骤",
        "slug": "学习暴力枚举的步骤"
      },
      {
        "depth": 3,
        "value": "理解问题的解空间",
        "slug": "理解问题的解空间"
      },
      {
        "depth": 3,
        "value": "生成所有可能的解",
        "slug": "生成所有可能的解"
      },
      {
        "depth": 3,
        "value": "验证解是否满足条件",
        "slug": "验证解是否满足条件"
      },
      {
        "depth": 3,
        "value": "优化暴力枚举",
        "slug": "优化暴力枚举"
      },
      {
        "depth": 2,
        "value": "学习暴力枚举的练习题",
        "slug": "学习暴力枚举的练习题"
      },
      {
        "depth": 3,
        "value": "简单枚举",
        "slug": "简单枚举"
      },
      {
        "depth": 3,
        "value": "多层枚举",
        "slug": "多层枚举"
      },
      {
        "depth": 3,
        "value": "排列与组合",
        "slug": "排列与组合"
      },
      {
        "depth": 3,
        "value": "验证条件",
        "slug": "验证条件"
      },
      {
        "depth": 3,
        "value": "复杂枚举",
        "slug": "复杂枚举"
      },
      {
        "depth": 2,
        "value": "学习暴力枚举的资源",
        "slug": "学习暴力枚举的资源"
      },
      {
        "depth": 2,
        "value": "学习路径建议",
        "slug": "学习路径建议"
      },
      {
        "depth": 2,
        "value": "总结",
        "slug": "总结"
      },
      {
        "depth": 2,
        "value": "例题",
        "slug": "例题"
      },
      {
        "depth": 3,
        "value": "解法1: 穷举解空间",
        "slug": "解法1:-穷举解空间"
      },
      {
        "depth": 3,
        "value": "解法2: 减少搜索空间(剪枝思想)+穷举",
        "slug": "解法2:-减少搜索空间(剪枝思想)+穷举"
      },
      {
        "depth": 3,
        "value": "解法3: 记录前缀信息(前缀和思想)+哈希表",
        "slug": "解法3:-记录前缀信息(前缀和思想)+哈希表"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/alg/greedy/lanqiao-218",
    "slug": "alg/greedy/lanqiao-218",
    "segments": [
      "alg",
      "greedy",
      "lanqiao-218"
    ],
    "filePath": "docs/zh/alg/greedy/lanqiao-218.mdx",
    "meta": {
      "title": "lanqiao-218",
      "description": null,
      "created_at": "2025-03-24T19:01:09.000Z",
      "updated_at": "2025-03-24T19:01:09.000Z",
      "tags": []
    },
    "order": 99,
    "content": "- 分糖果 - 蓝桥云课 (lanqiao.cn) - https://www.lanqiao.cn/problems/218/learning/?isWithAnswer=true&page=1&first_category_id=1&second_category_id=3&tags=%E8%B4%AA%E5%BF%83,%E6%8E%92%E5%BA%8F&tag_relation=intersection\n\n## 题目描述\n\n有 n 个小朋友围坐成一圈。老师给每个小朋友随机发偶数个糖果，然后进行下面的游戏：\n\n每个小朋友都把自己的糖果分一半给左手边的孩子。\n\n一轮分糖后，拥有奇数颗糖的孩子由老师补给 1 个糖果，从而变成偶数。\n\n反复进行这个游戏，直到所有小朋友的糖果数都相同为止。\n\n你的任务是预测在已知的初始糖果情形下，老师一共需要补发多少个糖果。\n## 输入描述\n\n程序首先读入一个整数 $N (2\\le N\\le100)$，表示小朋友的人数。\n\n接着是一行用空格分开的 N 个偶数（每个偶数不大于 1000，不小于 2）。\n## 输出描述\n\n要求程序输出一个整数，表示老师需要补发的糖果数。\n## 输入输出样例\n### 示例\n>输入\n```\n3\n2 2 4\n```\n> 输出\n```\n4\n```\n## 运行限制\n\n- 最大运行时间: 1s\n- 最大运行内存: 256M\n\n## 思路\n\n- 维护一个动态的 糖果数组 `nums`, 用于记录每轮分糖前的糖果数量\n- 记录初始糖果总数 `TOT = sum(nums){:py}` 为常数, 用于循环结束后判断老师需要补发的糖果数量\n- 开始循环\n  - 先 copy 一份糖果数组, 这样就有一份旧的 `nums` 和一份新的`nums1`, 我们需要计算出新的里面的具体的 value 这依赖于 旧的数组 `nums`\n  - `nums1[i] = nums[i]/2 + nums[(i+1)%n]/2{:py}`\n  - `if nums1[i]%2 == 1: nums1[i] += 1{:py}`\n  - 这样一轮而分糖结束了, 就要更新 `nums = nums1{:py}`, 以保证下一轮的分糖任务在新的糖果数组上进行\n  - 判断if 分个人的糖果数相同则结束循环: `if len(set(nums)) == 1: break{:py}`\n- 循环结束后, 计算老师需要补发的糖果数量: `print(int(sum(nums)-TOT)){:py}`\n\n```py\n# 获得输入\nn = int(input())\nnums = list(map(int, input().split()))\n# 初始化\nTOT = sum(nums)\n# 循环\nwhile True:\n    nums1 = nums.copy()\n    for i,v in enumerate(nums):\n        nums1[i] = v/2 + nums[(i+1)%n]/2\n        if nums1[i]%2 == 1: nums1[i] += 1\n    nums = nums1\n    if len(set(nums)) == 1: break\nprint(int(sum(nums)-TOT)) # 蓝桥杯可能 将 4.0 判为错误, 所以这里要转为 int\n```",
    "toc": [
      {
        "depth": 2,
        "value": "题目描述",
        "slug": "题目描述"
      },
      {
        "depth": 2,
        "value": "输入描述",
        "slug": "输入描述"
      },
      {
        "depth": 2,
        "value": "输出描述",
        "slug": "输出描述"
      },
      {
        "depth": 2,
        "value": "输入输出样例",
        "slug": "输入输出样例"
      },
      {
        "depth": 3,
        "value": "示例",
        "slug": "示例"
      },
      {
        "depth": 2,
        "value": "运行限制",
        "slug": "运行限制"
      },
      {
        "depth": 2,
        "value": "思路",
        "slug": "思路"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/alg/prefix",
    "slug": "alg/prefix",
    "segments": [
      "alg",
      "prefix"
    ],
    "filePath": "docs/zh/alg/prefix/index.mdx",
    "meta": {
      "title": "前缀和",
      "description": null,
      "created_at": "2025-03-25T03:49:30.000Z",
      "updated_at": "2025-03-25T03:49:30.000Z",
      "tags": [
        "alg",
        "prefix"
      ]
    },
    "order": 99,
    "content": "\n洛谷 P8218 【深进1.例1】求区间和 https://www.luogu.com.cn/problem/P8218\n\n# P8218 【深进1.例1】求区间和\n\n## 题目描述\n\n给定 $n$ 个正整数组成的数列 $a_1, a_2, \\cdots, a_n$ 和 $m$ 个区间 $[l_i,r_i]$，分别求这 $m$ 个区间的区间和。\n\n对于所有测试数据，$n,m\\le10^5,a_i\\le 10^4$\n\n## 输入格式\n\n第一行，为一个正整数 $n$ 。\n\n第二行，为 $n$ 个正整数 $a_1,a_2, \\cdots ,a_n$\n\n第三行，为一个正整数 $m$ 。\n\n接下来 $m$ 行，每行为两个正整数 $l_i,r_i$ ，满足$1\\le l_i\\le r_i\\le n$\n\n## 输出格式\n\n共 $m$ 行。\n\n第 $i$ 行为第 $i$ 组答案的询问。\n\n## 输入输出样例 #1\n\n### 输入 #1\n\n```\n4\n4 3 2 1\n2\n1 4\n2 3\n```\n\n### 输出 #1\n\n```\n10\n5\n```\n\n## 说明/提示\n\n样例解释：第 $1$ 到第 $4$ 个数加起来和为 $10$。第 $2$ 个数到第 $3$ 个数加起来和为 $5$。\n\n对于 $50 \\%$ 的数据：$n,m\\le 1000$；\n\n对于 $100 \\%$ 的数据：$1 \\le n, m\\le 10^5$，$1 \\le a_i\\le 10^4$\n\n## 题解\n\n输入:\n```py\nimport sys\ninput = sys.stdin.readline().strip()\nn = int(input())\na_ls = list(map(int, input().split()))\nm = int(input())\nl_ls = [0]*m\nr_ls = [0]*m\nfor _ in range(m):\n    l, r = map(int, input().split())\n    l_ls[_] = l\n    r_ls[_] = r\n```\n\n### 方法一: 穷举\n\n```py\ndef method1(n: int, a_ls: list[int], m: int, l_ls: list[int], r_ls: list[int]) -> list[int]:\n    res = []\n    for i in range(m): # o(m)\n        res.append(sum(a_ls[l_ls[i]-1:r_ls[i]])) # o(n)\n    return res\n```\n\n### 方法二: 前缀和\n\n```py\ndef method2(n: int, a_ls: list[int], m: int, l_ls: list[int], r_ls: list[int]) -> list[int]:\n    p_ls = [0]*(n+1)\n    for i in range(n): # o(n)\n        p_ls[i+1] = p_ls[i] + a_ls[i]\n    res = []\n    for i in range(m): # o(m)\n        res.append(prefix_sum[r_ls[i]] - prefix_sum[l_ls[i]-1])\n    return res\n```\n",
    "toc": [
      {
        "depth": 1,
        "value": "P8218 【深进1.例1】求区间和",
        "slug": "p8218-【深进1.例1】求区间和"
      },
      {
        "depth": 2,
        "value": "题目描述",
        "slug": "题目描述"
      },
      {
        "depth": 2,
        "value": "输入格式",
        "slug": "输入格式"
      },
      {
        "depth": 2,
        "value": "输出格式",
        "slug": "输出格式"
      },
      {
        "depth": 2,
        "value": "输入输出样例 #1",
        "slug": "输入输出样例-#1"
      },
      {
        "depth": 3,
        "value": "输入 #1",
        "slug": "输入-#1"
      },
      {
        "depth": 3,
        "value": "输出 #1",
        "slug": "输出-#1"
      },
      {
        "depth": 2,
        "value": "说明/提示",
        "slug": "说明/提示"
      },
      {
        "depth": 2,
        "value": "题解",
        "slug": "题解"
      },
      {
        "depth": 3,
        "value": "方法一: 穷举",
        "slug": "方法一:-穷举"
      },
      {
        "depth": 3,
        "value": "方法二: 前缀和",
        "slug": "方法二:-前缀和"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/linux/file_systems/readme",
    "slug": "linux/file_systems/readme",
    "segments": [
      "linux",
      "file_systems",
      "readme"
    ],
    "filePath": "docs/zh/linux/file_systems/readme.mdx",
    "meta": {},
    "order": 99,
    "content": "# file_systems",
    "toc": [
      {
        "depth": 1,
        "value": "file_systems",
        "slug": "file_systems"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/linux/console/Command-line_shell",
    "slug": "linux/console/Command-line_shell",
    "segments": [
      "linux",
      "console",
      "Command-line_shell"
    ],
    "filePath": "docs/zh/linux/console/Command-line_shell.mdx",
    "meta": {},
    "order": 99,
    "content": "",
    "toc": []
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/alg/enum/if",
    "slug": "alg/enum/if",
    "segments": [
      "alg",
      "enum",
      "if"
    ],
    "filePath": "docs/zh/alg/enum/if.mdx",
    "meta": {
      "title": "条件判断",
      "description": "命题逻辑是数学逻辑的一个分支，它研究命题之间的逻辑关系。在算法中，条件判断是一种常见的逻辑结构，用于根据不同的条件执行不同的操作。",
      "created_at": "2025-03-25T02:26:38.000Z",
      "updated_at": "2025-03-25T02:26:38.000Z",
      "tags": [
        "alg",
        "if"
      ]
    },
    "order": 99,
    "content": "\n## 例题\n刑侦科推理试题-lanqiao-1792\n\n### 题目描述\n```md\n有以下10道单选题，编程求这10道题的答案。\n1. 这道题的答案是：\nA. A  B. B   C. C  D. D\n2. 第5题的答案是：\nA. C  B. D  C. A  D. B\n3. 以下选项中哪一题的答案与其他三项不同：\nA. 第3题  B. 第6题  C. 第2题  D. 第4题\n4. 以下选项中哪两题的答案相同：\nA. 第1、5题 B. 第2、7题 C. 第1、9题 D. 第6、10题\n5. 以下选项中哪一题的答案与本题相同：\nA. 第8题  B. 第4题  C. 第9题 D. 第7题\n6. 以下选项中哪两题的答案与第8题相同：\nA. 第2、4题  B. 第1、6题  C. 第3、10题 D. 第5、9题\n7. 在这十道题中，被选中次数最少的选项字母为：\nA. C B. B C. A D. D\n8. 以下选项中哪一题的答案与第1题的答案在字母中不相邻：\nA. 第7题 B. 第5题 C. 第2题 D. 第10题\n9. 已知“第1题与第6题的答案相同”与“第X题与第5题的答案相同”的真假性相反，那么X为：\nA. 第6题 B. 第10题 C. 第2题 D. 第9题\n10. 在这10道题的答案中，ABCD四个字母出现次数最多与最少者的差为：\nA. 3 B. 2 C. 4 D. 1\n```\n### 输入描述\n\n无输入。\n### 输出描述\n\n输出这10道题的答案，用空格隔开。输出示例：B C A C A C D A B A。（显然这不是本题的答案）\n### 知识点\n\n- 命题的表示\n- 命题的真值\n- 枚举\n\n### 运行限制\n\n- 最大运行时间: 1s\n- 最大运行内存: 32M\n\n### 解答\n\n> [!TIP]\n> 我没有进行优化\n\n```py\nfrom itertools import product\nfrom typing import Tuple\n\n# py3.8写法 Tuple[str, ...]; py3.9写法 tuple[str] 即不用导入 Tuple\ndef is_valid(answers: Tuple[str, ...]) -> bool:\n    # 将答案映射到题目中 题目从 1 开始编号\n    q1, q2, q3, q4, q5, q6, q7, q8, q9, q10 = answers\n    q_list = list(answers)\n\n    # 规则 1: 第1题的答案是 A. A B. B C. C D. D\n    # if q1 not in 'ABCD':\n    #     return False\n\n    # 规则 2: 第5题的答案是 A. C B. D C. A D. B\n    if q5 != {'A': 'C', 'B': 'D', 'C': 'A', 'D': 'B'}[q2]:\n        return False\n\n    # 规则 3: 以下选项中哪一题的答案与其他三项不同\n    # q3_dict = { 'A': q3, 'B': q6, 'C': q2, 'D': q4 }\n    other_answers = { 'A': [q6, q2, q4], 'B': [q3, q2, q4], 'C': [q3, q6, q4],  'D': [q3, q6, q2] }\n    def existentiallySame(q3:str):\n        return q3 in other_answers[q3]\n    if existentiallySame(q3):\n        return False\n\n    # 规则 4: 以下选项中哪两题的答案相同\n    q4_dict = { \"A\": (q1, q5), \"B\": (q2, q7), \"C\": (q1, q9), \"D\": (q6, q10)}\n    def both_questions_not_same(qn1:str,qn2:str):\n        return not qn1==qn2\n    if both_questions_not_same(*q4_dict[q4]):\n        return False\n\n    # 规则 5: 以下选项中哪一题的答案与本题相同\n    q5_dict = {\"A\": q8, \"B\": q4, \"C\": q9, \"D\": q7}\n    if q5_dict[q5]!=q5:\n        return False\n    \n    # 规则 6: 以下选项中哪两题的答案与第8题相同\n    q6_dict = { \"A\": (q2,q4), \"B\": (q1, q6), \"C\": (q3, q10), \"D\": (q5, q9)}\n    def not_eq8(qn1:str,qn2:str):\n        return not qn1==qn2==q8\n    if not_eq8(*q6_dict[q6]):\n        return False\n\n    # 规则 7: 在这十道题中，被选中次数最少的选项字母为\n    # tip: 这里可以只比较值, 因为只要拿到最小值, 然后对应的 key 都可以称为次数最少的选项字母\n    counts = {c: answers.count(c) for c in 'ABCD'}\n    q7_dict = {'A': \"C\", \"B\": \"B\", \"C\": \"A\", \"D\": \"D\"}\n    if min(counts.values()) != counts[q7_dict[q7]]:\n        return False\n\n    # 规则 8: 以下选项中哪一题的答案与第1题的答案在字母中不相邻\n    q8_dict = {'A': q7, \"B\": q5, \"C\": q2, \"D\": q10}\n    def isAdjacent(qn:str):\n        return abs(ord(q1)-ord(qn))==1\n    if isAdjacent(q8_dict[q8]):\n        return False\n\n    # 规则 9: 已知“第1题与第6题的答案相同”与“第X题与第5题的答案相同”的真假性相反\n    q9_dict = {'A': q6, \"B\": q10, \"C\": q2, \"D\": q9}\n    is_q1_eq_q6 = q1 == q6\n    def isSame(qn:str):\n        return is_q1_eq_q6 == (qn == q5)\n    \n    if isSame(q9_dict[q9]):\n        return False\n\n    # 规则 10: 在这10道题的答案中，ABCD四个字母出现次数最多与最少者的差为\n    d = max(counts.values()) - min(counts.values())\n    q10_dict = {'A': 3, \"B\": 2, \"C\": 4, \"D\": 1}\n    if d != q10_dict[q10]:\n        return False\n\n    return True\n\n# Enumerate 所有可能的答案组合\nfor answers in product('ABCD', repeat=10):\n    if is_valid(answers):\n        print(' '.join(answers))\n        # break\n```",
    "toc": [
      {
        "depth": 2,
        "value": "例题",
        "slug": "例题"
      },
      {
        "depth": 3,
        "value": "题目描述",
        "slug": "题目描述"
      },
      {
        "depth": 3,
        "value": "输入描述",
        "slug": "输入描述"
      },
      {
        "depth": 3,
        "value": "输出描述",
        "slug": "输出描述"
      },
      {
        "depth": 3,
        "value": "知识点",
        "slug": "知识点"
      },
      {
        "depth": 3,
        "value": "运行限制",
        "slug": "运行限制"
      },
      {
        "depth": 3,
        "value": "解答",
        "slug": "解答"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/linux/command/readme",
    "slug": "linux/command/readme",
    "segments": [
      "linux",
      "command",
      "readme"
    ],
    "filePath": "docs/zh/linux/command/readme.mdx",
    "meta": {},
    "order": 99,
    "content": "# command\n\n## file\n\n| action | bash | zsh | cmd | powershell |\n| --- | --- | --- | --- | --- |\n| list file\\dir | `ls` | `ls` | `dir` | `Get-ChildItem` |\n| create file | `touch filename` | `touch filename` | `echo.>filename` | `New-Item -Type file filename` |\n| create dir | `mkdir dirname` | `mkdir dirname` | `md dirname` | `New-Item -Type directory dirname` |\n| copy file | `cp file1 file2` | `cp file1 file2` | `copy file1 file2` | `Copy-Item file1 file2` |\n| copy dir | `cp -r dir1 dir2` | `cp -r dir1 dir2` | `xcopy dir1 dir2 /s` | `Copy-Item -Recurse dir1 dir2` |\n| move file | `mv file1 file2` | `mv file1 file2` | `move file1 file2` | `Move-Item file1 file2` |\n| move dir | `mv dir1 dir2` | `mv dir1 dir2` | `move dir1 dir2` | `Move-Item dir1 dir2` |\n| remove file | `rm filename` | `rm filename` | `del filename` | `Remove-Item filename` |\n| remove dir | `rm -r dirname` | `rm -r dirname` | `rd dirname /s /q` | `Remove-Item -Recurse dirname` |\n| remove dir/* | `rm -r dirname/*` | `rm -r dirname/*` | `del dirname\\*.*` | `Remove-Item -Recurse dirname\\*` |",
    "toc": [
      {
        "depth": 1,
        "value": "command",
        "slug": "command"
      },
      {
        "depth": 2,
        "value": "file",
        "slug": "file"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/linux/console/readme",
    "slug": "linux/console/readme",
    "segments": [
      "linux",
      "console",
      "readme"
    ],
    "filePath": "docs/zh/linux/console/readme.mdx",
    "meta": {},
    "order": 99,
    "content": "# terminal\n\n```sh\n/usr/bin/bash '--init-file' '/opt/visual-studio-code/resources/app/out/vs/workbench/contrib/terminal/common/scripts/shellIntegration-bash.sh'\n```\n\n## Keyboard Shortcuts\n\n在 vscode 中打开命令搜索框(输入>), 然后输入 key 找到 类似于 `Preferences: Open Keyboard Shortcuts (JSON)`，打开后可以看到所有的快捷键配置。\n\n| command | key | when | source |\n| --- | --- | --- | --- |\n\n## start\nnetworking\n### Terminal: Paste\n\n在 Bash 中，Ctrl + V 用于插入下一个按键的字面值。这在需要输入特殊字符或控制字符时非常有用。例如，如果你想输入一个实际的 Ctrl + C 字符而不是执行中断命令，你可以按 Ctrl + V 然后按 Ctrl + C。\n\n1. 打开 `@/.inputrc` 文件（如果文件不存在，可以创建一个）：\n\n```sh\ncode @/.inputrc\n```\n\n2. 在文件中添加以下内容：\n\n```sh\n\"\\C-v\": paste-from-clipboard\n```\n\n3. 保存并关闭文件。\n\n4. 重新启动 Visual Studio Code 或在终端中运行以下命令以使更改生效：\n\n```sh\nbind -f @/.inputrc\n```\n\n请注意，这个方法依赖于你的终端模拟器支持 `paste-from-clipboard` 功能。如果你的终端模拟器不支持这个功能，你可能需要使用 Visual Studio Code 本身的设置来更改粘贴快捷键。\n\n在 Visual Studio Code 中，你可以通过以下步骤更改终端的粘贴快捷键：\n\n1. 打开 Visual Studio Code。\n2. 进入设置：文件 > 首选项 > 键盘快捷方式。\n3. 搜索 terminal paste。\n4. 找到 Terminal: Paste 命令，点击右侧的铅笔图标，然后按 Ctrl + V 进行绑定。\n\n这样，你就可以在 Visual Studio Code 的终端中使用 Ctrl + V 进行粘贴了。\n\n### Terminal: Copy Selection",
    "toc": [
      {
        "depth": 1,
        "value": "terminal",
        "slug": "terminal"
      },
      {
        "depth": 2,
        "value": "Keyboard Shortcuts",
        "slug": "keyboard-shortcuts"
      },
      {
        "depth": 2,
        "value": "start",
        "slug": "start"
      },
      {
        "depth": 3,
        "value": "Terminal: Paste",
        "slug": "terminal:-paste"
      },
      {
        "depth": 3,
        "value": "Terminal: Copy Selection",
        "slug": "terminal:-copy-selection"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/alg/lanqiao",
    "slug": "alg/lanqiao",
    "segments": [
      "alg",
      "lanqiao"
    ],
    "filePath": "docs/zh/alg/lanqiao/index.mdx",
    "meta": {
      "title": "蓝桥杯",
      "description": "每年都有省赛和国赛, 省赛一般在四月上旬或中旬, 国赛一般在六月上旬, 比赛时长4小时(9:00~13:00), 省赛一等奖才能参加国赛",
      "created_at": "2025-03-22T06:38:45.000Z",
      "updated_at": "2025-03-22T06:38:45.000Z",
      "tags": [
        "alg",
        "lanqiao"
      ]
    },
    "order": 99,
    "content": "\n时间较长可以带点吃的\n\n## 竞赛规则\n\n### 编程环境\n\n#### python\n- python 3.8.6\n- IDLE (python 自带编辑器)\n\n```sh\n# 启动 IDLE\nidle\n# 启动虚拟环境中的 IDLE 编辑器\npython -m idlelib\n```\n\n### OI赛制\n1. 无现场提交反馈. 也就是说, 你提交了代码, 你不知道对不对, 只有等到比赛结束, 才能知道对不对.\n2. 按点给分. 根据测试点通过的数量给分. \n  e.g:\n    - $对于 30\\% 的评测用例, 1\\leq n\\leq 10^3, 1\\leq a_i\\leq 10^3$\n    - $对于 100\\% 的评测用例, 1\\leq n\\leq 2\\cdot10^5, 1\\leq a_i\\leq 10^{16}$\n\n### 结果填空题\n\n可以用别的语言, 工具, 或手算\n\n### 编程大题\n\n通过测试用例估算正解的时间复杂度, 一般要在 $n^7,n^8$ 以内, 例如用例是 \n- $n\\leq 10^3$, 那么时间复杂度 可以选 $O(n^2)$,\n- $n\\leq 10^5$, 那么时间复杂度 可以选 $O(n\\log n)$\n\n## 语法\n\n```py\n# 常用变量名\n# res\\ans\\ret 结果\n# cnt\\tot 用于计数\n# i\\idex\\k\\v 用于索引,键值\n# i\\j\\k\\x\\y\\z 用于循环\n# a\\b\\c 用于变量\n# s,n, arr, d, nums 用于字符串, 数字, 数组, 字典, 数字组\n# l,r 用于 left, right\n# 常见保留字 -----------------------------------------\nand, or, not, in, is,\nTrue, False, None, \nif, else, elif,\nglobal, nonlocal,\nwhile, for, break, continue, \nreturn, def, lambda, class, yield, pass,\ntry, except, finally, raise, assert\nimport, from, as, \nwith, del,  \n# 字符串 -----------------------------------------\ns = \"hello\"\ns[start:end:step] # 切片\n# import -----------------------------------------\nimport math\nimport numpy as np\n```\n\n### input\n\n```py\nimport sys\ninput = lambda: sys.stdin.readline().strip()\ns = input()\n# 读取一行  -----------------------------------------\n# 1 2 3\na, b, c = map(int, input().split())\n# 读取多行 -----------------------------------------\n# 2\n# 1\n# 3\n# lst = [1, 3]\nn = int(input())\nlst = [int(input()) for _ in range(n)]\n\n# 矩阵读取 -----------------------------------------\n# 2 3\n# 1 2 3\n# 4 5 6\n# matrix = [[1, 2, 3], [4, 5, 6]]\nn, m = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\nprint(matrix)\n\n# 读取多行\nlines = sys.stdin.readlines()\n```\n\n### sort\n\n```py\nsorted(iterable, key=None, reverse=False)\niterable: 需要排序的可迭代对象\nkey: 用来进行比较的元素\nreverse: 排序规则, reverse = True 降序, reverse = False 升序（默认）\n\nlist.sort(key=None, reverse=False)\n```\n",
    "toc": [
      {
        "depth": 2,
        "value": "竞赛规则",
        "slug": "竞赛规则"
      },
      {
        "depth": 3,
        "value": "编程环境",
        "slug": "编程环境"
      },
      {
        "depth": 4,
        "value": "python",
        "slug": "python"
      },
      {
        "depth": 3,
        "value": "OI赛制",
        "slug": "oi赛制"
      },
      {
        "depth": 3,
        "value": "结果填空题",
        "slug": "结果填空题"
      },
      {
        "depth": 3,
        "value": "编程大题",
        "slug": "编程大题"
      },
      {
        "depth": 2,
        "value": "语法",
        "slug": "语法"
      },
      {
        "depth": 3,
        "value": "input",
        "slug": "input"
      },
      {
        "depth": 3,
        "value": "sort",
        "slug": "sort"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/linux/input/readme",
    "slug": "linux/input/readme",
    "segments": [
      "linux",
      "input",
      "readme"
    ],
    "filePath": "docs/zh/linux/input/readme.mdx",
    "meta": {},
    "order": 99,
    "content": "# input\n",
    "toc": [
      {
        "depth": 1,
        "value": "input",
        "slug": "input"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/alg/sort",
    "slug": "alg/sort",
    "segments": [
      "alg",
      "sort"
    ],
    "filePath": "docs/zh/alg/sort/index.mdx",
    "meta": {
      "title": "排序",
      "description": null,
      "created_at": "2025-03-24T15:40:14.000Z",
      "updated_at": "2025-03-24T15:40:14.000Z",
      "tags": [
        "alg",
        "sort"
      ]
    },
    "order": 99,
    "content": "\n## 冒泡排序\n**算法思想**\n- 冒泡排序通过**相邻元素的比较和交换**，将较大的元素逐步“冒泡”到数组的末尾\n- 每一轮都会将当前未排序部分的最大（或最小）元素放到正确的位置\n\n**实现步骤**:\n```py\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(n-i-1): # 从数组的第一个元素到未排序的位置 -1, 因为最后一个元素没有下一位或者下一位是有序的，依次比较相邻的两个元素\n            if arr[j] > arr[j+1]: # 如果前一个元素大于后一个元素，则交换两个元素\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n        # 例如遍历一遍后, 最后一个元素就是最大的元素, 下一次遍历就不需要比较最后一个元素\n        # 遍历两次后, 最后两个元素就是最大的两个元素, 下一次遍历就不需要比较最后两个元素\n    return arr\n```\n## 选择排序\n交换次数比冒泡排序少，但是比较次数一样多\n\n**算法思想**:\n- 选择排序每次从未排序的部分**选择最小（或最大）的元素**，放到未排序部分的起始位置\n**实现步骤**:\n```py\ndef selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        min_index = i\n        for j in range(i+1, n): # 从未排序的部分选择最小的元素\n            if arr[j] < arr[min_index]:\n                min_index = j\n        arr[i], arr[min_index] = arr[min_index], arr[i]\n    return arr\n```\n\n## 题例 LeetCode 406. 根据身高重建队列\n\n- 406.根据身高重建队列 - 力扣 (LeetCode) - https://leetcode.cn/problems/queue-reconstruction-by-height/description/\n\n### 题目描述\n\n假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 $people[i] = [h_i, k_i]$ 表示第 `i` 个人的身高为 $h_i$ ，前面 **正好** 有 $k_i$ 个身高大于或等于 $h_i$ 的人。\n\n请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 $queue[j] = [h_j, k_j]$ 是队列中第 `j` 个人的属性 (`queue[0]{:py}` 是排在队列前面的人)。\n\n### 输入输出样例\n\n1. 示例 1:\n```\n输入: people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]\n输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]\n解释：\n编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。\n编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。\n编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。\n编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。\n编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。\n编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。\n因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。\n```\n2. 示例 2:\n```\n输入: people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]\n输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]\n```\n### 提示：\n\n- $1 ≤ people.length ≤ 2000$\n- $0 ≤ h_i ≤ 10^6$\n- $0 ≤ k_i < people.length$\n- 题目数据确保队列可以被重建\n\n### 分析\n\n1. 排在前面的 $k_i$ 会比较小, 而排在后面的 $k_i$ 会比较大, 因此 排在前面的 $h_i$ 需要比较大.\n2. 对于 $h_i$ 相同的情况, $k_i$ 较大的必须排在后面\n3. 对于 $k_i$ 相同的情况, 排序没有直接关系\n4. 进行 $h_i$ 的降序排序, 对于 $h_i$ 相同的情况, 对 $k_i$ 升序排序后, 进行插入操作, 来保证\n\n#### 做法\n\n```py\nimport sys\ninput = lambda: sys.stdin.readline().strip()\nfrom typing import List\n\npeople: List[List[int]] = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]\n# 1. 先对 h_i 降序排序, 对于 h_i 相同的情况, 对 k_i 升序排序\npeople.sort(key=lambda x: (-x[0], x[1]))\n# 2. \nres = []\nfor i,v in enumerate(people):\n   h, k = v[0], v[1]\n   if k >= len(res):\n       res.append(v) # 这样虽然不能保证满足要求, 但是题目说了是数据是来自正确的队列, 打乱后的, 因为等其他插入完成后, 最终就能还原了\n   else:\n       res.insert(k, v) # 插入到 k 的位置, 这样前面就有 k 个大于等于 h 的元素\nprint(res)\n```\n\n```go\npeople := []string{\"Alice\", \"Bob\", \"Charlie\"}\nfor i, v := range people {\n    fmt.Println(i, v)\n}\n```",
    "toc": [
      {
        "depth": 2,
        "value": "冒泡排序",
        "slug": "冒泡排序"
      },
      {
        "depth": 2,
        "value": "选择排序",
        "slug": "选择排序"
      },
      {
        "depth": 2,
        "value": "题例 LeetCode 406. 根据身高重建队列",
        "slug": "题例-leetcode-406.-根据身高重建队列"
      },
      {
        "depth": 3,
        "value": "题目描述",
        "slug": "题目描述"
      },
      {
        "depth": 3,
        "value": "输入输出样例",
        "slug": "输入输出样例"
      },
      {
        "depth": 3,
        "value": "提示：",
        "slug": "提示："
      },
      {
        "depth": 3,
        "value": "分析",
        "slug": "分析"
      },
      {
        "depth": 4,
        "value": "做法",
        "slug": "做法"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/linux/network/NTP",
    "slug": "linux/network/NTP",
    "segments": [
      "linux",
      "network",
      "NTP"
    ],
    "filePath": "docs/zh/linux/08-network/01-NTP.mdx",
    "meta": {
      "title": "时间同步",
      "description": "时间同步",
      "created_at": "2025-03-22T01:12:59.000Z",
      "updated_at": "2025-03-22T01:12:59.000Z",
      "tags": [
        "linux",
        "time"
      ],
      "related": {
        "links": [
          "linux/systemd-timesyncd",
          "linux/system_time"
        ]
      }
    },
    "order": 1,
    "content": "[NTP](https://wiki.archlinuxcn.org/wiki/Network_Time_Protocol_daemon), 是最常用的网络同步时间协议\n\n[Network Time Protocol](https://en.wikipedia.org/wiki/Network_Time_Protocol) (网络时间协议) 是 GUN/linux 系统通过互联网时间服务器同步系统[软件时钟](https://wiki.archlinuxcn.org/wiki/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4#%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F)的最常见方法。设计时考虑到了各种网络延迟，通过公共网络同步时，误差可以降低到10毫秒以内；通过本地网络同步时，误差可以降低到 1 毫秒。 \n\n[NTP 项目](https://support.ntp.org/bin/view/Main/WebHome#The_NTP_Project)提供了一个名为简单 NTP 的参考实现。本文介绍如何设置和运行服务器和客户端 NTP 进程。 \n\n## 安装\n\n[安装 ntp](https://archlinux.org/packages/?name=ntp) 软件包。如果不做任何配置， ntpd 默认工作于客户端模式。如果使用 Arch Linux 默认的配置，请跳转到 [#使用](#使用)。作为服务器的配置，请参阅 [#NTP 服务器模式](#ntp-服务器模式)。\n\n## 配置\n\n### 连接到 NTP 服务器\n\n### NTP 服务器模式\n\n## 使用\n\narchlinux 软件包默认包含客户端模式的配置，并且使用单独的用户和群组，启动时就会移除 root 权限。如果在终端中启动，请使用 `-u` 选项: \n```sh\nntpd -u ntp:ntp\n```\nsystemd 服务默认使用 `-u` 选项和 `-g` 选项禁用一个阈值(panic-gate). 这样即使 ntp-server 的时间和系统时间的差异超过阈值，依然会同步时间。 \n> [!warning] 警告: 使用 panic-gate 的原因是某些后台任务或服务会引起时间跳跃. 如果系统的时间从来没有同步过，请考虑先禁用其他服务再进行同步。\n\n两个服务都依赖系统网络状况，会在检测到网络连接时开始同步。",
    "toc": [
      {
        "depth": 2,
        "value": "安装",
        "slug": "安装"
      },
      {
        "depth": 2,
        "value": "配置",
        "slug": "配置"
      },
      {
        "depth": 3,
        "value": "连接到 NTP 服务器",
        "slug": "连接到-ntp-服务器"
      },
      {
        "depth": 3,
        "value": "NTP 服务器模式",
        "slug": "ntp-服务器模式"
      },
      {
        "depth": 2,
        "value": "使用",
        "slug": "使用"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/dev/deploy/Kubernetes",
    "slug": "dev/deploy/Kubernetes",
    "segments": [
      "dev",
      "deploy",
      "Kubernetes"
    ],
    "filePath": "docs/zh/dev/deploy/Kubernetes/index.mdx",
    "meta": {
      "title": "Kubernetes",
      "description": "Kubernetes (简称 K8s) 是一个开源的容器编排平台，用于自动化部署、扩展和管理容器化应用程序。它最初由 Google 开发，现在由 CNCF (Cloud Native Computing Foundation) 维护。",
      "created_at": "2025-03-24T13:16:07.000Z",
      "updated_at": "2025-03-24T13:16:07.000Z",
      "tags": []
    },
    "order": 99,
    "content": "\n**核心功能**:\n- **容器编排**：管理多个容器的部署、运行和通信。\n- **自动化**：自动处理容器的启动、停止、扩展和故障恢复。\n- **负载均衡**：分配流量到多个容器实例，确保高可用性。\n- **弹性伸缩**：根据负载动态扩展或缩减容器数量。\n- **服务发现**：通过 DNS 或 IP 自动发现服务。\n- **存储管理**：支持挂载本地存储、云存储（如 AWS EBS、GCP Persistent Disk）等。\n\n\n## Kubernetes 的用途\n\nKubernetes 的主要用途是帮助开发者和运维人员高效地管理容器化应用程序，尤其是在分布式系统中。以下是一些典型的应用场景：\n\n### 容器化应用的部署和管理\n- 自动化部署容器化应用程序。\n- 管理应用程序的生命周期（启动、停止、更新）。\n\n### 高可用性和容错\n- 如果某个容器实例崩溃，Kubernetes 会自动重新启动或替换它。\n- 通过负载均衡和健康检查，确保服务的高可用性。\n\n### 弹性伸缩\n- 根据流量或资源使用情况，动态扩展或缩减容器实例数量。\n\n### 多云和混合云支持\n- Kubernetes 可以运行在本地数据中心、公有云（如 AWS、GCP、Azure）或混合云环境中。\n\n### 微服务架构支持\n- Kubernetes 非常适合管理微服务架构，支持服务发现、负载均衡和跨服务通信。\n\n##  Kubernetes 的核心概念\n\n学习 Kubernetes 需要理解以下核心概念：\n\n### Pod\n- Pod 是 Kubernetes 中的最小部署单元，通常包含一个或多个容器。\n- 同一个 Pod 中的容器共享网络和存储。\n\n### Node\n- Node 是 Kubernetes 集群中的工作节点，可以是物理机或虚拟机。\n- 每个 Node 上运行容器，并由 Kubernetes 管理。\n\n### Cluster\n- Cluster 是由多个 Node 组成的 Kubernetes 集群，用于运行容器化应用。\n\n### Deployment\n- Deployment 用于管理 Pod 的部署和更新。\n- 支持滚动更新和回滚。\n\n### Service\n- Service 提供 Pod 的网络访问，支持负载均衡和服务发现。\n\n### ConfigMap 和 Secret\n- ConfigMap：用于存储非敏感的配置信息。\n- Secret: 用于存储敏感信息（如密码、API 密钥）。\n\n### Namespace\n- Namespace 用于逻辑隔离 Kubernetes 集群中的资源。\n\n### Ingress\n- Ingress 是一种 API 对象，用于管理外部 HTTP/HTTPS 流量到集群内部服务的路由\n\n## 学习 Kubernetes 的步骤\n\n### 基础知识准备\n在学习 Kubernetes 之前，建议先掌握以下基础知识：\n1. **容器化技术**：\n   - 学习 Docker，理解容器的基本概念和操作（如镜像、容器、网络、存储）。\n2. **Linux 基础**：\n   - 熟悉 Linux 命令行操作和网络基础。\n3. **云计算基础**：\n   - 了解云计算的基本概念（如虚拟机、负载均衡、存储）。\n\n### 学习 Kubernetes 核心概念\n1. 学习 Kubernetes 的基本架构和核心组件。\n2. 理解 Pod、Deployment、Service 等核心资源的作用和用法。\n\n### 实践 Kubernetes\n1. **安装 Kubernetes**：\n   - 使用 Minikube 或 Kind 在本地搭建 Kubernetes 集群。\n   - 或者使用云服务提供的 Kubernetes（如 AWS EKS、GCP GKE、Azure AKS）。\n2. **部署应用**：\n   - 部署一个简单的容器化应用（如 Nginx）。\n   - 学习如何使用 `kubectl` 命令管理 Kubernetes 资源。\n3. **配置和管理**：\n   - 学习如何使用 ConfigMap 和 Secret 配置应用。\n   - 学习如何使用 Ingress 暴露服务。\n\n### 学习高级功能\n1. **弹性伸缩**：\n   - 学习 Horizontal Pod Autoscaler（HPA）。\n2. **监控和日志**：\n   - 使用工具（如 Prometheus、Grafana）监控 Kubernetes 集群。\n   - 学习如何查看 Pod 的日志。\n3. **持久化存储**：\n   - 学习如何使用 PersistentVolume 和 PersistentVolumeClaim 管理存储。\n4. **安全性**：\n   - 学习 RBAC（基于角色的访问控制）。\n   - 学习如何使用 Secret 管理敏感信息。\n\n### 学习 Kubernetes 生态系统\n1. **Helm**：\n   - 学习 Helm，用于管理 Kubernetes 应用的包管理工具。\n2. **CI/CD 集成**：\n   - 学习如何将 Kubernetes 集成到 CI/CD 流程中。\n3. **服务网格（Service Mesh）**：\n   - 学习 Istio 或 Linkerd，用于管理微服务的通信。\n\n---\n\n## 学习 Kubernetes 的资源\n\n### 官方文档\n- Kubernetes 官方文档是最权威的学习资源：\n  - [Kubernetes 官方文档](https://kubernetes.io/)\n\n### 在线课程\n- **免费课程**：\n  - [Kubernetes Basics by Google Cloud](https://kubernetes.io/docs/tutorials/kubernetes-basics/)\n- **付费课程**：\n  - Udemy 上的 Kubernetes 入门课程。\n  - Pluralsight 的 Kubernetes 系列课程。\n\n### 实践工具\n- **Minikube**：\n  - 在本地运行 Kubernetes 集群。\n  - [Minikube 官方文档](https://minikube.sigs.k8s.io/docs/)\n- **Kind**：\n  - 使用 Docker 容器运行 Kubernetes 集群。\n  - [Kind 官方文档](https://kind.sigs.k8s.io/)\n\n### 学习书籍\n- 《Kubernetes in Action》\n- 《Kubernetes Up & Running》\n\n### 社区资源\n- Kubernetes 官方 Slack 社区。\n- CNCF（Cloud Native Computing Foundation）资源。\n\n## Kubernetes 的优缺点\n\n### 优点\n1. **自动化**：自动化部署、扩展和管理容器化应用。\n2. **高可用性**：支持容错和负载均衡。\n3. **跨平台支持**：支持多云和混合云环境。\n4. **生态系统丰富**：与 Helm、Prometheus、Istio 等工具集成良好。\n\n### 缺点\n1. **学习曲线陡峭**：需要掌握大量概念和工具。\n2. **复杂性**：对于小型项目可能显得过于复杂。\n3. **资源消耗**：运行 Kubernetes 集群需要较高的资源。\n\n## 总结\n\n- **Kubernetes 是什么**：\n  - Kubernetes 是一个容器编排平台，用于自动化部署、扩展和管理容器化应用。\n\n- **Kubernetes 的用途**：\n  - 管理容器化应用的生命周期。\n  - 提供高可用性、弹性伸缩和服务发现。\n\n- **如何学习 Kubernetes**：\n  1. 掌握基础知识（Docker、Linux、云计算）。\n  2. 学习 Kubernetes 核心概念（Pod、Deployment、Service 等）。\n  3. 通过 Minikube 或云服务实践 Kubernetes。\n  4. 学习高级功能（弹性伸缩、监控、持久化存储等）。\n\n{/* ```mermaid\ngraph TD\n    User[用户请求] --> DNS[DNS解析]\n    DNS --> VIP[\"VIP (keepalived 提供)\"]\n    VIP --> LBService[\"Service (负载均衡到 Ingress Controller)\"]\n    LBService --> IngressController[Nginx Ingress Controller]\n    IngressController --> BackendService[\"Service (负载均衡到具体服务)\"]\n    BackendService --> Pod[\"Pod (运行具体应用)\"]\n``` */}\n",
    "toc": [
      {
        "depth": 2,
        "value": "Kubernetes 的用途",
        "slug": "kubernetes-的用途"
      },
      {
        "depth": 3,
        "value": "容器化应用的部署和管理",
        "slug": "容器化应用的部署和管理"
      },
      {
        "depth": 3,
        "value": "高可用性和容错",
        "slug": "高可用性和容错"
      },
      {
        "depth": 3,
        "value": "弹性伸缩",
        "slug": "弹性伸缩"
      },
      {
        "depth": 3,
        "value": "多云和混合云支持",
        "slug": "多云和混合云支持"
      },
      {
        "depth": 3,
        "value": "微服务架构支持",
        "slug": "微服务架构支持"
      },
      {
        "depth": 2,
        "value": "Kubernetes 的核心概念",
        "slug": "kubernetes-的核心概念"
      },
      {
        "depth": 3,
        "value": "Pod",
        "slug": "pod"
      },
      {
        "depth": 3,
        "value": "Node",
        "slug": "node"
      },
      {
        "depth": 3,
        "value": "Cluster",
        "slug": "cluster"
      },
      {
        "depth": 3,
        "value": "Deployment",
        "slug": "deployment"
      },
      {
        "depth": 3,
        "value": "Service",
        "slug": "service"
      },
      {
        "depth": 3,
        "value": "ConfigMap 和 Secret",
        "slug": "configmap-和-secret"
      },
      {
        "depth": 3,
        "value": "Namespace",
        "slug": "namespace"
      },
      {
        "depth": 3,
        "value": "Ingress",
        "slug": "ingress"
      },
      {
        "depth": 2,
        "value": "学习 Kubernetes 的步骤",
        "slug": "学习-kubernetes-的步骤"
      },
      {
        "depth": 3,
        "value": "基础知识准备",
        "slug": "基础知识准备"
      },
      {
        "depth": 3,
        "value": "学习 Kubernetes 核心概念",
        "slug": "学习-kubernetes-核心概念"
      },
      {
        "depth": 3,
        "value": "实践 Kubernetes",
        "slug": "实践-kubernetes"
      },
      {
        "depth": 3,
        "value": "学习高级功能",
        "slug": "学习高级功能"
      },
      {
        "depth": 3,
        "value": "学习 Kubernetes 生态系统",
        "slug": "学习-kubernetes-生态系统"
      },
      {
        "depth": 2,
        "value": "学习 Kubernetes 的资源",
        "slug": "学习-kubernetes-的资源"
      },
      {
        "depth": 3,
        "value": "官方文档",
        "slug": "官方文档"
      },
      {
        "depth": 3,
        "value": "在线课程",
        "slug": "在线课程"
      },
      {
        "depth": 3,
        "value": "实践工具",
        "slug": "实践工具"
      },
      {
        "depth": 3,
        "value": "学习书籍",
        "slug": "学习书籍"
      },
      {
        "depth": 3,
        "value": "社区资源",
        "slug": "社区资源"
      },
      {
        "depth": 2,
        "value": "Kubernetes 的优缺点",
        "slug": "kubernetes-的优缺点"
      },
      {
        "depth": 3,
        "value": "优点",
        "slug": "优点"
      },
      {
        "depth": 3,
        "value": "缺点",
        "slug": "缺点"
      },
      {
        "depth": 2,
        "value": "总结",
        "slug": "总结"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/next/community/contribution-guide",
    "slug": "next/community/contribution-guide",
    "segments": [
      "next",
      "community",
      "contribution-guide"
    ],
    "filePath": "docs/zh/next/04-community/01-contribution-guide.mdx",
    "meta": {
      "title": "文档贡献指南",
      "nav_title": "贡献 指南",
      "description": "了解如何贡献文档到 Next.js 文档"
    },
    "order": 1,
    "content": "\n欢迎来到 Next.js 文档贡献指南！我们很高兴你来到这里\n\n本页面提供了如何编辑 Next.js 文档的说明。我们的目标是确保社区中的每个人都能参与并改进我们的文档。\n\n## 为什么要贡献？\n\n开源工作永远不会完成，文档也是如此。为文档做贡献是初学者参与开源的好方法，同时也是经验丰富的开发者通过分享知识来澄清复杂主题的机会。\n\n通过为 Next.js 文档做贡献，你正在帮助我们为所有开发者构建一个更强大的学习资源。无论你发现了一个错别字、一个令人困惑的部分，还是意识到某个主题缺失，你的贡献都将受到欢迎和感谢。\n\n## 如何贡献\n\n文档内容可以在 [Next.js repo](https://github.com/vercel/next.js/tree/canary/docs) 仓库 中找到。你可以直接在 GitHub 上编辑文件，或者克隆仓库并在本地编辑文件。\n\nThe docs content can be found on the [Next.js repo](https://github.com/vercel/next.js/tree/canary/docs). To contribute, you can edit the files directly on GitHub or clone the repo and edit the files locally.\n\n### GitHub Workflow\n\nIf you're new to GitHub, we recommend reading the [GitHub Open Source Guide](https://opensource.guide/how-to-contribute/#opening-a-pull-request) to learn how to fork a repository, create a branch, and submit a pull request.\n\n> **Good to know**: The underlying docs code lives in a private codebase that is synced to the Next.js public repo. This means that you can't preview the docs locally. However, you'll see your changes on [nextjs.org](https://nextjs.org/docs) after merging a pull request.\n\n### Writing MDX\n\nThe docs are written in [MDX](https://mdxjs.com/), a markdown format that supports JSX syntax. This allows us to embed React components in the docs. See the [GitHub Markdown Guide](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) for a quick overview of markdown syntax.\n\n### VSCode\n\n#### Previewing Changes Locally\n\nVSCode has a built-in markdown previewer that you can use to see your edits locally. To enable the previewer for MDX files, you'll need to add a configuration option to your user settings.\n\nOpen the command palette (`⌘ + ⇧ + P` on Mac or `Ctrl + Shift + P` on Windows) and search from `Preferences: Open User Settings (JSON)`.\n\nThen, add the following line to your `settings.json` file:\n\n```json filename=\"settings.json\"\n{\n  \"files.associations\": {\n    \"*.mdx\": \"markdown\"\n  }\n}\n```\n\nNext, open the command palette again, and search for `Markdown: Preview File` or `Markdown: Open Preview to the Side`. This will open a preview window where you can see your formatted changes.\n\n#### Extensions\n\nWe also recommend the following extensions for VSCode users:\n\n- [MDX](https://marketplace.visualstudio.com/items?itemName=unifiedjs.vscode-mdx): Intellisense and syntax highlighting for MDX.\n- [Prettier](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode): Format MDX files on save.\n\n### Review Process\n\nOnce you've submitted your contribution, the Next.js or Developer Experience teams will review your changes, provide feedback, and merge the pull request when it's ready.\n\nPlease let us know if you have any questions or need further assistance in your PR's comments. Thank you for contributing to the Next.js docs and being a part of our community!\n\n> **Tip:** Run `pnpm prettier-fix` to run Prettier before submitting your PR.\n\n## File Structure\n\nThe docs use **file-system routing**. Each folder and files inside [`/docs`](https://github.com/vercel/next.js/tree/canary/docs) represent a route segment. These segments are used to generate the URL paths, navigation, and breadcrumbs.\n\nThe file structure reflects the navigation that you see on the site, and by default, navigation items are sorted alphabetically. However, we can change the order of the items by prepending a two-digit number (`00-`) to the folder or file name.\n\nFor example, in the [functions API Reference](/docs/app/api-reference/functions), the pages are sorted alphabetically because it makes it easier for developers to find a specific function:\n\n```txt\n04-functions\n├── after.mdx\n├── cacheLife.mdx\n├── cacheTag.mdx\n└── ...\n```\n\nBut, in the [routing section](/docs/app/building-your-application/routing), the files are prefixed with a two-digit number, sorted in the order developers should learn these concepts:\n\n```txt\n01-routing\n├── 01-defining-routes.mdx\n├── 02-pages.mdx\n├── 03-layouts-and-templates.mdx\n└── ...\n```\n\nTo quickly find a page, you can use `⌘ + P` (Mac) or `Ctrl + P` (Windows) to open the search bar on VSCode. Then, type the slug of the page you're looking for. E.g. `defining-routes`\n\n> **Why not use a manifest?**\n>\n> We considered using a manifest file (another popular way to generate the docs navigation), but we found that a manifest would quickly get out of sync with the files. File-system routing forces us to think about the structure of the docs and feels more native to Next.js.\n\n## Metadata\n\nEach page has a metadata block at the top of the file separated by three dashes.\n\n### Required Fields\n\nThe following fields are **required**:\n\n| Field         | Description                                                                  |\n| ------------- | ---------------------------------------------------------------------------- |\n| `title`       | The page's `<h1>` title, used for SEO and OG Images.                         |\n| `description` | The page's description, used in the `<meta name=\"description\">` tag for SEO. |\n\n```yaml filename=\"required-fields.mdx\"\n---\ntitle: Page Title\ndescription: Page Description\n---\n```\n\nIt's good practice to limit the page title to 2-3 words (e.g. Optimizing Images) and the description to 1-2 sentences (e.g. Learn how to optimize images in Next.js).\n\n### Optional Fields\n\nThe following fields are **optional**:\n\n| Field       | Description                                                                                                                                        |\n| ----------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `nav_title` | Overrides the page's title in the navigation. This is useful when the page's title is too long to fit. If not provided, the `title` field is used. |\n| `source`    | Pulls content into a shared page. See [Shared Pages](#shared-pages).                                                                               |\n| `related`   | A list of related pages at the bottom of the document. These will automatically be turned into cards. See [Related Links](#related-links).         |\n| `version`   | A stage of development. e.g. `experimental`,`legacy`,`unstable`,`RC`                                                                               |\n\n```yaml filename=\"optional-fields.mdx\"\n---\nnav_title: Nav Item Title\nsource: app/building-your-application/optimizing/images\nrelated:\n  description: See the image component API reference.\n  links:\n    - app/api-reference/components/image\nversion: experimental\n---\n```\n\n## `App` and `Pages` Docs\n\nSince most of the features in the **App Router** and **Pages Router** are completely different, their docs for each are kept in separate sections (`02-app` and `03-pages`). However, there are a few features that are shared between them.\n\n### Shared Pages\n\nTo avoid content duplication and risk the content becoming out of sync, we use the `source` field to pull content from one page into another. For example, the `<Link>{:jsx}` component behaves _mostly_ the same in **App** and **Pages**. Instead of duplicating the content, we can pull the content from `app/.../link.mdx` into `pages/.../link.mdx`:\n\n```mdx filename=\"app/.../link.mdx\" title=\"app/.../link.mdx\"\n---\ntitle: <Link>\ndescription: API reference for the <Link> component.\n---\n\nThis API reference will help you understand how to use the props\nand configuration options available for the Link Component.\n```\n\n```mdx filename=\"pages/.../link.mdx\"\n---\ntitle: <Link>\ndescription: API reference for the <Link> component.\nsource: app/api-reference/components/link\n---\n\n{/* DO NOT EDIT THIS PAGE. */}\n{/* The content of this page is pulled from the source above. */}\n```\n\nWe can therefore edit the content in one place and have it reflected in both sections.\n\n### Shared Content\n\nIn shared pages, sometimes there might be content that is **App Router** or **Pages Router** specific. For example, the `<Link>{:jsx}` component has a `shallow` prop that is only available in **Pages** but not in **App**.\n\nTo make sure the content only shows in the correct router, we can wrap content blocks in an `<AppOnly>` or `<PagesOnly>` components:\n\n```mdx filename=\"app/.../link.mdx\"\nThis content is shared between App and Pages.\n\n<PagesOnly>\n\nThis content will only be shown on the Pages docs.\n\n</PagesOnly>\n\nThis content is shared between App and Pages.\n```\n\nYou'll likely use these components for examples and code blocks.\n\n## Code Blocks\n\nCode blocks should contain a minimum working example that can be copied and pasted. This means that the code should be able to run without any additional configuration.\n\nFor example, if you're showing how to use the `<Link>` component, you should include the `import` statement and the `<Link>` component itself.\n\n```tsx filename=\"app/page.tsx\"\nimport Link from 'next/link'\n\nexport default function Page() {\n  return <Link href=\"/about\">About</Link>\n}\n```\n\nAlways run examples locally before committing them. This will ensure that the code is up-to-date and working.\n\n### Language and Filename\n\nCode blocks should have a header that includes the language and the `filename`. Add a `filename` prop to render a special Terminal icon that helps orientate users where to input the command. For example:\n\n````mdx filename=\"code-example.mdx\"\n```bash filename=\"Terminal\"\nnpx create-next-app\n```\n````\n\nMost examples in the docs are written in `tsx` and `jsx`, and a few in `bash`. However, you can use any supported language, here's the [full list](https://github.com/shikijs/shiki/blob/main/docs/languages.md#all-languages).\n\nWhen writing JavaScript code blocks, we use the following language and extension combinations.\n\n|                                | Language | Extension |\n| ------------------------------ | -------- | --------- |\n| JavaScript files with JSX code | ```jsx   | .js       |\n| JavaScript files without JSX   | ```js    | .js       |\n| TypeScript files with JSX      | ```tsx   | .tsx      |\n| TypeScript files without JSX   | ```ts    | .ts       |\n\n> **Good to know**:\n>\n> - Make sure to use **`js`** extension with **JSX** code at JavaScript files.\n> - For example, ```jsx filename=\"app/layout.js\"\n\n### TS and JS Switcher\n\nAdd a language switcher to toggle between TypeScript and JavaScript. Code blocks should be TypeScript first with a JavaScript version to accommodate users.\n\nCurrently, we write TS and JS examples one after the other, and link them with `switcher` prop:\n\n````mdx filename=\"code-example.mdx\"\n```tsx filename=\"app/page.tsx\" switcher\n\n```\n\n```jsx filename=\"app/page.js\" switcher\n\n```\n````\n\n> **Good to know**: We plan to automatically compile TypeScript snippets to JavaScript in the future. In the meantime, you can use [transform.tools](https://transform.tools/typescript-to-javascript).\n\n### Line Highlighting\n\nCode lines can be highlighted. This is useful when you want to draw attention to a specific part of the code. You can highlight lines by passing a number to the `highlight` prop.\n\n**Single Line:** `highlight={1}`\n\n```tsx filename=\"app/page.tsx\" {1}\nimport Link from 'next/link'\n\nexport default function Page() {\n  return <Link href=\"/about\">About</Link>\n}\n```\n\n**Multiple Lines:** `highlight={1,3}`\n\n```tsx filename=\"app/page.tsx\" highlight={1,3}\nimport Link from 'next/link'\n\nexport default function Page() {\n  return <Link href=\"/about\">About</Link>\n}\n```\n\n**Range of Lines:** `highlight={1-5}`\n\n```tsx filename=\"app/page.tsx\" highlight={1-5}\nimport Link from 'next/link'\n\nexport default function Page() {\n  return <Link href=\"/about\">About</Link>\n}\n```\n\n## Icons\n\nThe following icons are available for use in the docs:\n\n```mdx filename=\"mdx-icon.mdx\"\n<Check size={18} />\n<Cross size={18} />\n```\n\n**Output:**\n\n<Check size={18} />\n<Cross size={18} />\n\nWe do not use emojis in the docs.\n\n## Notes\n\nFor information that is important but not critical, use notes. Notes are a good way to add information without distracting the user from the main content.\n\n```mdx filename=\"notes.mdx\"\n> **Good to know**: This is a single line note.\n\n> **Good to know**:\n>\n> - We also use this format for multi-line notes.\n> - There are sometimes multiple items worth knowing or keeping in mind.\n```\n\n**Output:**\n\n> **Good to know**: This is a single line note.\n\n> **Good to know**:\n>\n> - We also use this format for multi-line notes.\n> - There are sometimes multiple items worth knowing or keeping in mind.\n\n## Related Links\n\nRelated Links guide the user's learning journey by adding links to logical next steps.\n\n- Links will be displayed in cards under the main content of the page.\n- Links will be automatically generated for pages that have child pages. For example, the [Optimizing](/docs/app/building-your-application/optimizing) section has links to all of its child pages.\n\nCreate related links using the `related` field in the page's metadata.\n\n```yaml filename=\"example.mdx\"\n---\nrelated:\n  description: Learn how to quickly get started with your first application.\n  links:\n    - app/building-your-application/routing/defining-routes\n    - app/building-your-application/data-fetching\n    - app/api-reference/file-conventions/page\n---\n```\n\n### Nested Fields\n\n| Field         | Required? | Description                                                                                                                                               |\n| ------------- | --------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `title`       | Optional  | The title of the card list. Defaults to **Next Steps**.                                                                                                   |\n| `description` | Optional  | The description of the card list.                                                                                                                         |\n| `links`       | Required  | A list of links to other doc pages. Each list item should be a relative URL path (without a leading slash) e.g. `app/api-reference/file-conventions/page` |\n\n## Diagrams\n\nDiagrams are a great way to explain complex concepts. We use [Figma](https://www.figma.com/) to create diagrams, following Vercel's design guide.\n\nThe diagrams currently live in the `/public` folder in our private Next.js site. If you'd like to update or add a diagram, please open a [GitHub issue](https://github.com/vercel/next.js/issues/new?assignees=&labels=template%3A+documentation&projects=&template=4.docs_request.yml&title=Docs%3A+) with your ideas.\n\n## Custom Components and HTML\n\nThese are the React Components available for the docs: `<Image />` (next/image), `<PagesOnly />`, `<AppOnly />`, `<Cross />`, and `<Check />`. We do not allow raw HTML in the docs besides the `<details>` tag.\n\nIf you have ideas for new components, please open a [GitHub issue](https://github.com/vercel/next.js/issues/new/choose).\n\n## Style Guide\n\nThis section contains guidelines for writing docs for those who are new to technical writing.\n\n### Page Templates\n\nWhile we don't have a strict template for pages, there are page sections you'll see repeated across the docs:\n\n- **Overview:** The first paragraph of a page should tell the user what the feature is and what it's used for. Followed by a minimum working example or its API reference.\n- **Convention:** If the feature has a convention, it should be explained here.\n- **Examples**: Show how the feature can be used with different use cases.\n- **API Tables**: API Pages should have an overview table at the of the page with jump-to-section links (when possible).\n- **Next Steps (Related Links)**: Add links to related pages to guide the user's learning journey.\n\nFeel free to add these sections as needed.\n\n### Page Types\n\nDocs pages are also split into two categories: Conceptual and Reference.\n\n- **Conceptual** pages are used to explain a concept or feature. They are usually longer and contain more information than reference pages. In the Next.js docs, conceptual pages are found in the **Building Your Application** section.\n- **Reference** pages are used to explain a specific API. They are usually shorter and more focused. In the Next.js docs, reference pages are found in the **API Reference** section.\n\n> **Good to know**: Depending on the page you're contributing to, you may need to follow a different voice and style. For example, conceptual pages are more instructional and use the word _you_ to address the user. Reference pages are more technical, they use more imperative words like \"create, update, accept\" and tend to omit the word _you_.\n\n### Voice\n\nHere are some guidelines to maintain a consistent style and voice across the docs:\n\n- Write clear, concise sentences. Avoid tangents.\n  - If you find yourself using a lot of commas, consider breaking the sentence into multiple sentences or use a list.\n  - Swap out complex words for simpler ones. For example, _use_ instead of _utilize_.\n- Be mindful with the word _this_. It can be ambiguous and confusing, don't be afraid to repeat the subject of the sentence if unclear.\n  - For example, _Next.js uses React_ instead of _Next.js uses this_.\n- Use an active voice instead of passive. An active sentence is easier to read.\n  - For example, _Next.js uses React_ instead of _React is used by Next.js_. If you find yourself using words like _was_ and _by_ you may be using a passive voice.\n- Avoid using words like _easy_, _quick_, _simple_, _just_, etc. This is subjective and can be discouraging to users.\n- Avoid negative words like _don't_, _can't_, _won't_, etc. This can be discouraging to readers.\n  - For example, _\"You can use the `Link` component to create links between pages\"_ instead of _\"Don't use the `<a>` tag to create links between pages\"_.\n- Write in second person (you/your). This is more personal and engaging.\n- Use gender-neutral language. Use _developers_, _users_, or _readers_, when referring to the audience.\n- If adding code examples, ensure they are properly formatted and working.\n\nWhile these guidelines are not exhaustive, they should help you get started. If you'd like to dive deeper into technical writing, check out the [Google Technical Writing Course](https://developers.google.com/tech-writing/overview).\n\n---\n\nThank you for contributing to the docs and being part of the Next.js community!\n\n{/* To do: Latest Contributors Component */}",
    "toc": [
      {
        "depth": 2,
        "value": "为什么要贡献？",
        "slug": "为什么要贡献？"
      },
      {
        "depth": 2,
        "value": "如何贡献",
        "slug": "如何贡献"
      },
      {
        "depth": 3,
        "value": "GitHub Workflow",
        "slug": "github-workflow"
      },
      {
        "depth": 3,
        "value": "Writing MDX",
        "slug": "writing-mdx"
      },
      {
        "depth": 3,
        "value": "VSCode",
        "slug": "vscode"
      },
      {
        "depth": 4,
        "value": "Previewing Changes Locally",
        "slug": "previewing-changes-locally"
      },
      {
        "depth": 4,
        "value": "Extensions",
        "slug": "extensions"
      },
      {
        "depth": 3,
        "value": "Review Process",
        "slug": "review-process"
      },
      {
        "depth": 2,
        "value": "File Structure",
        "slug": "file-structure"
      },
      {
        "depth": 2,
        "value": "Metadata",
        "slug": "metadata"
      },
      {
        "depth": 3,
        "value": "Required Fields",
        "slug": "required-fields"
      },
      {
        "depth": 3,
        "value": "Optional Fields",
        "slug": "optional-fields"
      },
      {
        "depth": 2,
        "value": "App and Pages Docs",
        "slug": "app-and-pages-docs"
      },
      {
        "depth": 3,
        "value": "Shared Pages",
        "slug": "shared-pages"
      },
      {
        "depth": 3,
        "value": "Shared Content",
        "slug": "shared-content"
      },
      {
        "depth": 2,
        "value": "Code Blocks",
        "slug": "code-blocks"
      },
      {
        "depth": 3,
        "value": "Language and Filename",
        "slug": "language-and-filename"
      },
      {
        "depth": 3,
        "value": "TS and JS Switcher",
        "slug": "ts-and-js-switcher"
      },
      {
        "depth": 3,
        "value": "Line Highlighting",
        "slug": "line-highlighting"
      },
      {
        "depth": 2,
        "value": "Icons",
        "slug": "icons"
      },
      {
        "depth": 2,
        "value": "Notes",
        "slug": "notes"
      },
      {
        "depth": 2,
        "value": "Related Links",
        "slug": "related-links"
      },
      {
        "depth": 3,
        "value": "Nested Fields",
        "slug": "nested-fields"
      },
      {
        "depth": 2,
        "value": "Diagrams",
        "slug": "diagrams"
      },
      {
        "depth": 2,
        "value": "Custom Components and HTML",
        "slug": "custom-components-and-html"
      },
      {
        "depth": 2,
        "value": "Style Guide",
        "slug": "style-guide"
      },
      {
        "depth": 3,
        "value": "Page Templates",
        "slug": "page-templates"
      },
      {
        "depth": 3,
        "value": "Page Types",
        "slug": "page-types"
      },
      {
        "depth": 3,
        "value": "Voice",
        "slug": "voice"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/dev/md/css/tailwind",
    "slug": "dev/md/css/tailwind",
    "segments": [
      "dev",
      "md",
      "css",
      "tailwind"
    ],
    "filePath": "docs/zh/dev/md/css/tailwind.mdx",
    "meta": {},
    "order": 99,
    "content": "# tailwindCss\n\n## Colors\n\n",
    "toc": [
      {
        "depth": 1,
        "value": "tailwindCss",
        "slug": "tailwindcss"
      },
      {
        "depth": 2,
        "value": "Colors",
        "slug": "colors"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/dev/md/css/color",
    "slug": "dev/md/css/color",
    "segments": [
      "dev",
      "md",
      "css",
      "color"
    ],
    "filePath": "docs/zh/dev/md/css/color.mdx",
    "meta": {},
    "order": 99,
    "content": "# Color\n\n$$\ny=\\sin(x)\n$$\n\n## format\n\n### rgb\n\n```css\n.dc {\n  color: rgb(88, 101, 242);\n}\n```\n\n### HSL\n\n`HSL` 是一种表示颜色的格式，全称为 **Hue（色相）、Saturation（饱和度）、Lightness（亮度）**。它是一种基于色相、饱和度和亮度的颜色模型，常用于 CSS 和其他设计工具中，用于定义颜色。\n\n### HSL 的结构\n\nHSL 的格式如下：\n\n```css\nhsl(hue, saturation, lightness)\n```\n\n- **`hue`（色相）**：\n  - 表示颜色的基本类型，例如红色、绿色、蓝色等。\n  - 取值范围为 `0` 到 `360`，表示色轮上的角度：\n    - `0`：红色\n    - `120`：绿色\n    - `240`：蓝色\n    - 其他值是这些颜色之间的过渡，例如 `60` 是黄色，`180` 是青色。\n    \n- **`saturation`（饱和度）**：\n  - 表示颜色的强度或纯度。\n  - 取值范围为 `0%` 到 `100%`：\n    - `0%`：完全无色（灰色）。\n    - `100%`：完全饱和（最纯的颜色）。\n\n- **`lightness`（亮度）**：\n  - 表示颜色的明暗程度。\n  - 取值范围为 `0%` 到 `100%`：\n    - `0%`：完全黑色。\n    - `100%`：完全白色。\n    - `50%`：标准亮度。\n\n### 示例\n\n#### 基本颜色\n\n```css\n/* 红色 */\nhsl(0, 100%, 50%)\n\n/* 绿色 */\nhsl(120, 100%, 50%)\n\n/* 蓝色 */\nhsl(240, 100%, 50%)\n```\n\n#### 调整饱和度\n\n```css\n/* 低饱和度的红色（接近灰色） */\nhsl(0, 20%, 50%)\n\n/* 高饱和度的红色 */\nhsl(0, 100%, 50%)\n```\n\n#### 调整亮度\n\n```css\n/* 暗红色 */\nhsl(0, 100%, 20%)\n\n/* 明亮的红色 */\nhsl(0, 100%, 80%)\n```\n\n### HSLA 格式\n\n`HSLA` 是 HSL 的扩展，支持透明度（Alpha 通道）。格式如下：\n\n```css\nhsla(hue, saturation, lightness, alpha)\n```\n\n- **`alpha`（透明度）**：\n  - 表示颜色的透明度。\n  - 取值范围为 `0`（完全透明）到 `1`（完全不透明）。\n\n#### 示例\n\n```css\n/* 半透明的红色 */\nhsla(0, 100%, 50%, 0.5)\n\n/* 半透明的蓝色 */\nhsla(240, 100%, 50%, 0.3)\n```\n\n### HSL 的优点\n\n1. **直观**：相比于 RGB，HSL 更加直观，特别是在调整颜色的亮度和饱和度时。\n2. **易于调整**：可以轻松调整颜色的亮度和饱和度，而不需要重新计算 RGB 值。\n3. **设计友好**：HSL 更接近设计师的思维方式，因为它基于色相、饱和度和亮度。\n\n### 总结\n\nHSL 是一种基于色相、饱和度和亮度的颜色模型，常用于 CSS 中定义颜色。它的格式为 `hsl(hue, saturation, lightness)`，其中 `hue` 表示颜色的类型，`saturation` 表示颜色的纯度，`lightness` 表示颜色的明暗程度。扩展格式 `hsla` 还支持透明度。HSL 的直观性和易用性使其在设计和开发中非常流行。\n",
    "toc": [
      {
        "depth": 1,
        "value": "Color",
        "slug": "color"
      },
      {
        "depth": 2,
        "value": "format",
        "slug": "format"
      },
      {
        "depth": 3,
        "value": "rgb",
        "slug": "rgb"
      },
      {
        "depth": 3,
        "value": "HSL",
        "slug": "hsl"
      },
      {
        "depth": 3,
        "value": "HSL 的结构",
        "slug": "hsl-的结构"
      },
      {
        "depth": 3,
        "value": "示例",
        "slug": "示例"
      },
      {
        "depth": 4,
        "value": "基本颜色",
        "slug": "基本颜色"
      },
      {
        "depth": 4,
        "value": "调整饱和度",
        "slug": "调整饱和度"
      },
      {
        "depth": 4,
        "value": "调整亮度",
        "slug": "调整亮度"
      },
      {
        "depth": 3,
        "value": "HSLA 格式",
        "slug": "hsla-格式"
      },
      {
        "depth": 4,
        "value": "示例",
        "slug": "示例"
      },
      {
        "depth": 3,
        "value": "HSL 的优点",
        "slug": "hsl-的优点"
      },
      {
        "depth": 3,
        "value": "总结",
        "slug": "总结"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/dev/md/css",
    "slug": "dev/md/css",
    "segments": [
      "dev",
      "md",
      "css"
    ],
    "filePath": "docs/zh/dev/md/css/index.mdx",
    "meta": {
      "title": "md css",
      "description": null,
      "created_at": "2025-03-21T23:23:27.000Z",
      "updated_at": "2025-03-21T23:23:27.000Z",
      "tags": [
        "md",
        "css"
      ]
    },
    "order": 99,
    "content": "",
    "toc": []
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/next/app/building-your-application/optimizing/package-bundling",
    "slug": "next/app/building-your-application/optimizing/package-bundling",
    "segments": [
      "next",
      "app",
      "building-your-application",
      "optimizing",
      "package-bundling"
    ],
    "filePath": "docs/zh/next/01-app/03-building-your-application/06-optimizing/06-package-bundling.mdx",
    "meta": {
      "title": "Optimizing Package Bundling",
      "nav_title": "Package Bundling",
      "description": "Learn how to optimize your application's server and client bundles.",
      "related": {
        "description": "Learn more about optimizing your application for production.",
        "links": [
          "app/building-your-application/deploying/production-checklist"
        ]
      }
    },
    "order": 6,
    "content": "\nBundling external packages can significantly improve the performance of your application. <AppOnly>By default, packages imported inside Server Components and Route Handlers are automatically bundled by Next.js. This page will guide you through how to analyze and further optimize package bundling.</AppOnly> <PagesOnly>By default, packages imported into your application are not bundled. This can impact performance or might not work if external packages are not pre-bundled, for example, if imported from a monorepo or `node_modules`. This page will guide you through how to analyze and configure package bundling.</PagesOnly>\n\n> 捆绑外部包可以显著提高应用程序的性能。<AppOnly>默认情况下，在服务器组件和路由处理程序中导入的包会自动由 Next.js 进行捆绑。本页面将指导您如何分析和进一步优化包的捆绑。</AppOnly> <PagesOnly>默认情况下，导入到应用程序中的包不会被捆绑。这可能会影响性能，或者如果外部包没有预先捆绑（例如，从 monorepo 或 node_modules 导入），可能无法正常工作。本页面将指导您如何分析和配置包的捆绑。</PagesOnly>\n\n## Analyzing JavaScript bundles\n\n[`@next/bundle-analyzer`](https://www.npmjs.com/package/@next/bundle-analyzer) is a plugin for Next.js that helps you manage the size of your application bundles. It generates a visual report of the size of each package and their dependencies. You can use the information to remove large dependencies, split, or [lazy-load](/docs/app/building-your-application/optimizing/lazy-loading) your code.\n\n### Installation\n\nInstall the plugin by running the following command:\n\n```bash\nnpm i @next/bundle-analyzer\n# or\nyarn add @next/bundle-analyzer\n# or\npnpm add @next/bundle-analyzer\n```\n\nThen, add the bundle analyzer's settings to your `next.config.js`.\n\n```js filename=\"next.config.js\"\n/** @type {import('next').NextConfig} */\nconst nextConfig = {}\n\nconst withBundleAnalyzer = require('@next/bundle-analyzer')({\n  enabled: process.env.ANALYZE === 'true',\n})\n\nmodule.exports = withBundleAnalyzer(nextConfig)\n```\n\n### Generating a report\n\nRun the following command to analyze your bundles:\n\n```bash\nANALYZE=true npm run build\n# or\nANALYZE=true yarn build\n# or\nANALYZE=true pnpm build\n```\n\nThe report will open three new tabs in your browser, which you can inspect. Periodically evaluating your application's bundles can help you maintain application performance over time.\n\n## Optimizing package imports\n\nSome packages, such as icon libraries, can export hundreds of modules, which can cause performance issues in development and production.\n\nYou can optimize how these packages are imported by adding the [`optimizePackageImports`](/docs/app/api-reference/config/next-config-js/optimizePackageImports) option to your `next.config.js`. This option will only load the modules you _actually_ use, while still giving you the convenience of writing import statements with many named exports.\n\n```js filename=\"next.config.js\"\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  experimental: {\n    optimizePackageImports: ['icon-library'],\n  },\n}\n\nmodule.exports = nextConfig\n```\n\nNext.js also optimizes some libraries automatically, thus they do not need to be included in the optimizePackageImports list. See the [full list](https://nextjs.org/docs/app/api-reference/config/next-config-js/optimizePackageImports).\n\n<PagesOnly>\n\n## Bundling specific packages\n\nTo bundle specific packages, you can use the [`transpilePackages`](/docs/app/api-reference/config/next-config-js/transpilePackages) option in your `next.config.js`. This option is useful for bundling external packages that are not pre-bundled, for example, in a monorepo or imported from `node_modules`.\n\n```js filename=\"next.config.js\"\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  transpilePackages: ['package-name'],\n}\n\nmodule.exports = nextConfig\n```\n\n## Bundling all packages\n\nTo automatically bundle all packages (default behavior in the App Router), you can use the [`bundlePagesRouterDependencies`](/docs/pages/api-reference/config/next-config-js/bundlePagesRouterDependencies) option in your `next.config.js`.\n\n```js filename=\"next.config.js\"\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  bundlePagesRouterDependencies: true,\n}\n\nmodule.exports = nextConfig\n```\n\n## Opting specific packages out of bundling\n\nIf you have the [`bundlePagesRouterDependencies`](/docs/pages/api-reference/config/next-config-js/bundlePagesRouterDependencies) option enabled, you can opt specific packages out of automatic bundling using the [`serverExternalPackages`](/docs/pages/api-reference/config/next-config-js/serverExternalPackages) option in your `next.config.js`:\n\n```js filename=\"next.config.js\"\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  // Automatically bundle external packages in the Pages Router:\n  bundlePagesRouterDependencies: true,\n  // Opt specific packages out of bundling for both App and Pages Router:\n  serverExternalPackages: ['package-name'],\n}\n\nmodule.exports = nextConfig\n```\n\n</PagesOnly>\n\n<AppOnly>\n\n## Opting specific packages out of bundling\n\nSince packages imported inside Server Components and Route Handlers are automatically bundled by Next.js, you can opt specific packages out of bundling using the [`serverExternalPackages`](/docs/app/api-reference/config/next-config-js/serverExternalPackages) option in your `next.config.js`.\n\n```js filename=\"next.config.js\"\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  serverExternalPackages: ['package-name'],\n}\n\nmodule.exports = nextConfig\n```\n\nNext.js includes a list of popular packages that currently are working on compatibility and automatically opt-ed out. See the [full list](/docs/app/api-reference/config/next-config-js/serverExternalPackages).\n\n</AppOnly>",
    "toc": [
      {
        "depth": 2,
        "value": "Analyzing JavaScript bundles",
        "slug": "analyzing-javascript-bundles"
      },
      {
        "depth": 3,
        "value": "Installation",
        "slug": "installation"
      },
      {
        "depth": 3,
        "value": "Generating a report",
        "slug": "generating-a-report"
      },
      {
        "depth": 2,
        "value": "Optimizing package imports",
        "slug": "optimizing-package-imports"
      },
      {
        "depth": 2,
        "value": "Bundling specific packages",
        "slug": "bundling-specific-packages"
      },
      {
        "depth": 2,
        "value": "Bundling all packages",
        "slug": "bundling-all-packages"
      },
      {
        "depth": 2,
        "value": "Opting specific packages out of bundling",
        "slug": "opting-specific-packages-out-of-bundling"
      },
      {
        "depth": 2,
        "value": "Opting specific packages out of bundling",
        "slug": "opting-specific-packages-out-of-bundling"
      }
    ]
  },
  {
    "locale": "zh",
    "type": "docs",
    "url": "/zh/docs/next/app/api-reference/config/next-config-js/turbo",
    "slug": "next/app/api-reference/config/next-config-js/turbo",
    "segments": [
      "next",
      "app",
      "api-reference",
      "config",
      "next-config-js",
      "turbo"
    ],
    "filePath": "docs/zh/next/01-app/04-api-reference/05-config/01-next-config-js/turbo.mdx",
    "meta": {
      "title": "turbo",
      "description": "Configure Next.js with Turbopack-specific options",
      "version": "experimental"
    },
    "order": 99,
    "content": "\n{/* The content of this doc is shared between the app and pages router. You can use the `<PagesOnly>Content</PagesOnly>` component to add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. */}\n\nThe `turbo` option lets you customize [Turbopack](/docs/app/api-reference/turbopack) to transform different files and change how modules are resolved.\n\n```ts filename=\"next.config.ts\" switcher\nimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  experimental: {\n    turbo: {\n      // ...\n    },\n  },\n}\n\nexport default nextConfig\n```\n\n```js filename=\"next.config.js\" switcher\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  experimental: {\n    turbo: {\n      // ...\n    },\n  },\n}\n\nmodule.exports = nextConfig\n```\n\n> **Good to know**:\n>\n> - Turbopack for Next.js does not require loaders nor loader configuration for built-in functionality. Turbopack has built-in support for CSS and compiling modern JavaScript, so there's no need for `css-loader`, `postcss-loader`, or `babel-loader` if you're using `@babel/preset-env`.\n\n## Reference\n\n### Options\n\nThe following options are available for the `turbo` configuration:\n\n| Option              | Description                                                             |\n| ------------------- | ----------------------------------------------------------------------- |\n| `rules`             | List of supported webpack loaders to apply when running with Turbopack. |\n| `resolveAlias`      | Map aliased imports to modules to load in their place.                  |\n| `resolveExtensions` | List of extensions to resolve when importing files.                     |\n| `moduleIdStrategy`  | Assign module IDs                                                       |\n| `treeShaking`       | Enable tree shaking for the turbopack dev server and build.             |\n| `memoryLimit`       | A target memory limit for turbo, in bytes.                              |\n\n### Supported loaders\n\nThe following loaders have been tested to work with Turbopack's webpack loader implementation:\n\n- [`babel-loader`](https://www.npmjs.com/package/babel-loader)\n- [`@svgr/webpack`](https://www.npmjs.com/package/@svgr/webpack)\n- [`svg-inline-loader`](https://www.npmjs.com/package/svg-inline-loader)\n- [`yaml-loader`](https://www.npmjs.com/package/yaml-loader)\n- [`string-replace-loader`](https://www.npmjs.com/package/string-replace-loader)\n- [`raw-loader`](https://www.npmjs.com/package/raw-loader)\n- [`sass-loader`](https://www.npmjs.com/package/sass-loader)\n\n## Examples\n\n### Configuring webpack loaders\n\nIf you need loader support beyond what's built in, many webpack loaders already work with Turbopack. There are currently some limitations:\n\n- Only a core subset of the webpack loader API is implemented. Currently, there is enough coverage for some popular loaders, and we'll expand our API support in the future.\n- Only loaders that return JavaScript code are supported. Loaders that transform files like stylesheets or images are not currently supported.\n- Options passed to webpack loaders must be plain JavaScript primitives, objects, and arrays. For example, it's not possible to pass `require()` plugin modules as option values.\n\nTo configure loaders, add the names of the loaders you've installed and any options in `next.config.js`, mapping file extensions to a list of loaders:\n\n```js filename=\"next.config.js\"\nmodule.exports = {\n  experimental: {\n    turbo: {\n      rules: {\n        '*.svg': {\n          loaders: ['@svgr/webpack'],\n          as: '*.js',\n        },\n      },\n    },\n  },\n}\n```\n\n> **Good to know**: Prior to Next.js version 13.4.4, `turbo.rules` was named `turbo.loaders` and only accepted file extensions like `.mdx` instead of `*.mdx`.\n\n### Resolving aliases\n\nTurbopack can be configured to modify module resolution through aliases, similar to webpack's [`resolve.alias`](https://webpack.js.org/configuration/resolve/#resolvealias) configuration.\n\nTo configure resolve aliases, map imported patterns to their new destination in `next.config.js`:\n\n```js filename=\"next.config.js\"\nmodule.exports = {\n  experimental: {\n    turbo: {\n      resolveAlias: {\n        underscore: 'lodash',\n        mocha: { browser: 'mocha/browser-entry.js' },\n      },\n    },\n  },\n}\n```\n\nThis aliases imports of the `underscore` package to the `lodash` package. In other words, `import underscore from 'underscore'` will load the `lodash` module instead of `underscore`.\n\nTurbopack also supports conditional aliasing through this field, similar to Node.js' [conditional exports](https://nodejs.org/docs/latest-v18.x/api/packages.html#conditional-exports). At the moment only the `browser` condition is supported. In the case above, imports of the `mocha` module will be aliased to `mocha/browser-entry.js` when Turbopack targets browser environments.\n\n### Resolving custom extensions\n\nTurbopack can be configured to resolve modules with custom extensions, similar to webpack's [`resolve.extensions`](https://webpack.js.org/configuration/resolve/#resolveextensions) configuration.\n\nTo configure resolve extensions, use the `resolveExtensions` field in `next.config.js`:\n\n```js filename=\"next.config.js\"\nmodule.exports = {\n  experimental: {\n    turbo: {\n      resolveExtensions: [\n        '.mdx',\n        '.tsx',\n        '.ts',\n        '.jsx',\n        '.js',\n        '.mjs',\n        '.json',\n      ],\n    },\n  },\n}\n```\n\nThis overwrites the original resolve extensions with the provided list. Make sure to include the default extensions.\n\nFor more information and guidance for how to migrate your app to Turbopack from webpack, see [Turbopack's documentation on webpack compatibility](https://turbo.build/pack/docs/migrating-from-webpack).\n\n### Assigning module IDs\n\nTurbopack currently supports two strategies for assigning module IDs:\n\n- `'named'` assigns readable module IDs based on the module's path and functionality.\n- `'deterministic'` assigns small hashed numeric module IDs, which are mostly consistent between builds and therefore help with long-term caching.\n\nIf not set, Turbopack will use `'named'` for development builds and `'deterministic'` for production builds.\n\nTo configure the module IDs strategy, use the `moduleIdStrategy` field in `next.config.js`:\n\n```js filename=\"next.config.js\"\nmodule.exports = {\n  experimental: {\n    turbo: {\n      moduleIdStrategy: 'deterministic',\n    },\n  },\n}\n```\n\n## Version History\n\n| Version  | Changes                          |\n| -------- | -------------------------------- |\n| `13.0.0` | `experimental.turbo` introduced. |",
    "toc": [
      {
        "depth": 2,
        "value": "Reference",
        "slug": "reference"
      },
      {
        "depth": 3,
        "value": "Options",
        "slug": "options"
      },
      {
        "depth": 3,
        "value": "Supported loaders",
        "slug": "supported-loaders"
      },
      {
        "depth": 2,
        "value": "Examples",
        "slug": "examples"
      },
      {
        "depth": 3,
        "value": "Configuring webpack loaders",
        "slug": "configuring-webpack-loaders"
      },
      {
        "depth": 3,
        "value": "Resolving aliases",
        "slug": "resolving-aliases"
      },
      {
        "depth": 3,
        "value": "Resolving custom extensions",
        "slug": "resolving-custom-extensions"
      },
      {
        "depth": 3,
        "value": "Assigning module IDs",
        "slug": "assigning-module-ids"
      },
      {
        "depth": 2,
        "value": "Version History",
        "slug": "version-history"
      }
    ]
  }
]