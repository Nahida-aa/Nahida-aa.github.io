[
  {
    "title": "dp",
    "description": "**动态规划(Dynamic Programming)** 是一种将复杂问题分解成更小的子问题的方法, 通过保存子问题的结果来避免重复计算",
    "url": "/blog/2024/03/12/dp.mdx",
    "slug": "2024/03/12/dp.mdx",
    "segments": [
      "2024",
      "03",
      "12",
      "dp.mdx"
    ],
    "filePath": "2024/03/12/dp.mdx",
    "meta": {
      "title": "dp",
      "description": "**动态规划(Dynamic Programming)** 是一种将复杂问题分解成更小的子问题的方法, 通过保存子问题的结果来避免重复计算",
      "created_at": "2024-03-12T16:22:16.000Z",
      "updated_at": "2025-04-03T16:22:16.000Z",
      "tags": [
        "alg",
        "dp"
      ]
    },
    "content": "\n## leetCode 70 爬楼梯\n\n假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。\n\n每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n**示例1:**\n> 输入：`n = 2`<br/>\n> 输出：`2`<br/>\n> 解释: 有两种方法可以爬到楼顶\n> 1. 1 阶 + 1 阶\n> 2. 2 阶\n\n**示例2:**\n> 输入：`n = 3`<br/>\n> 输出：`3`<br/>\n> 解释: 有三种方法可以爬到楼顶\n> 1. 1 阶 + 1 阶 + 1 阶\n> 2. 1 阶 + 2 阶\n> 3. 2 阶 + 1 阶\n\n**提示:**\n- $1 \\leq n \\leq 45$\n\n### 分析\n1. 爬 3 阶, 从 2 阶上来是一种方法, 从 1 阶上来是另外一种方法\n2. 因此爬 3 阶的方法数 = 爬 2 阶的方法数 + 爬 1 阶的方法数\n3. 也就是 `f(n) = f(n-1) + f(n-2)`, 发现此递推公式符合斐波那契数列\n### 解法1: 递归\n```py\ndef dfs(n: int) -> int:\n    if n <= 2:\n        return n # f(1)=1, f(2)=2\n    return dfs(n - 1) + dfs(n - 2)\n```\n**复杂度分析:**\n- 时间复杂度: $O(2^n)$, 这个递归解法相当于搜索一个课高为 `n` 的二叉树\n- 空间复杂度: $O(n)$, 递归栈的深度为 `n`\n\n例如 n=7\n```mermaid\ngraph TD\n    7((7)) --> 6.6((6))\n    7 --> 6.5((5))\n    6.6 --> 5.5((5))\n    6.6 --> 5.4((4))\n    6.5 --> 5.4.2((4))\n    6.5 --> 5.3((3))\n    5.5 --> 4.4((4))\n    5.5 --> 4.3((3))\n    5.4 --> 4.3.2((3))\n    5.4 --> 4.2((2))\n    5.4.2 --> 4.3.3((3))\n    5.4.2 --> 4.2.2((2))\n    5.3 --> 4.2.1((2))\n    5.3 --> 4.1((1))\n    4.4 --> 3.3((3))\n    4.4 --> 3.2((2))\n    4.3 --> 3.2.2((2))\n    4.3 --> 3.1((1))\n    4.3.2 --> 3.2.3((2))\n    4.3.2 --> 3.1.2((1))\n    4.2 --> 3.1.3((1))\n    4.3.3 --> 3.2.4((2))\n    4.3.3 --> 3.1.4((1))\n    4.2.2 --> 3.1.5((1))\n    3.3 --> 2.2((2))\n    3.3 --> 2.1((1))\n```\n> [!warning]\n> 发现计算了过多的重复子问题\n### 解法2: 递归 + 记录返回值 = 记忆化搜索\n> [!note]\n> 可以存储已经计算过的值, 以避免重复计算, 例如可以使用 array or hash_map 来存储<br/>\n> 不过 python 中内置了, `functools.lru_cache{:py}` 装饰器, 可以直接用于这个需求\n```py\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef dfs(n: int) -> int:\n    if n <= 2:\n        return n # f(1)=1, f(2)=2\n    return dfs(n - 1) + dfs(n - 2)\n```\n使用记忆化搜索后的复杂度是$O(n)$, 只需要计算每个子问题一次, 递归栈的深度为 `n`, 所以空间复杂度也是 $O(n)$<br/>\n图示如下:\n```mermaid\ngraph LR\n    7((7)) --> 6((6))\n    6 --> 5((5))\n    5 --> 4((4))\n    4 --> 3((3))\n    3 --> 2((2))\n    2 --> 1((1))\n```\n### 解法3: 动态规划\n> [!note]\n> **动态规划(Dynamic Programming, DP)** 可以被看作是将**递归问题**转化为**迭代问题**的一种算法，但它的核心思想不仅仅是简单的转化，而是通过 **分解问题** 和 **存储子问题的解** 来优化计算过程\n```py\ndef climbStairs(n: int) -> int:\n    if n <= 2:\n        return n\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = 1, 2\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n```\n### 解法4: DP + 状态压缩(滚动数组)\n- 在这个 解法3 中, `dp[i]` 的值只依赖于 `dp[i-1]` 和 `dp[i-2]`\n- 因此，我们不需要存储整个 `dp` 数组，只需要用两个变量来保存最近的两个状态即可\n- 状态压缩的时间复杂度与普通动态规划相同，但它的 空间复杂度更低，从 $O(n)$ 降到了 $O(1)$\n- 在实际运行中，减少内存分配和访问的开销会使程序运行得更快\n```py\ndef climbStairs(n: int) -> int:\n    if n <= 2:\n        return n\n    prev, curr = 1, 2  # 初始化 f(1) 和 f(2)\n    for i in range(3, n + 1):\n        prev, curr = curr, prev + curr  # 更新状态\n    return curr\n```\n### 解法5: 解通项公式\n```math\n\\begin{align*}\n&f(n) = f(n-1) + f(n-2) \\\\\n&\\rightarrow f(n) = \\frac{1}{\\sqrt{5}}(\\phi^n - \\psi^n) \\\\\n&\\phi = \\frac{1 + \\sqrt{5}}{2} \\quad （黄金比例） \\\\\n&\\psi = \\frac{1 - \\sqrt{5}}{2} \\\\\n\\end{align*}\n```\n```py\nfrom math import sqrt\ndef climbStairs(n: int) -> int:\n    sqrt5 = sqrt(5)\n    phi = (1 + sqrt5) / 2\n    n += 1 # 注意这题求的是 f(n+1)\n    return round((phi**n - (1 - phi)**n) / sqrt5)\n```\n> [!note]\n> 这个解法的时间复杂度是 $O(1)$, 但是由于浮点数精度问题, 当 `n` 较大时可能会出现误差\n#### 证明\n```math\nf(n) = f(n-1) + f(n-2)\n```\n这是一个 **线性递推关系**, 并且它的系数是常数 (即 `1` 和 `1`) 。对于这种递推关, Binet's Formula 提供了一种通用的解法，可以直接推导出数列的通项公式\n\n##### 待定系数法 推导\n\n**1. 递推关系:**\n```math\nf(n) = f(n-1) + f(n-2)\n```\n这是一个二阶线性递推关系\n\n**2. 特征方程:**\n\n为了求解这个递推关系, 我们假设通解的形式为\n```math\nf(n) = x^n\n```\n- 将其代入递推关系中, 得到:\n```math\nx^n = x^{n-1} + x^{n-2}\n```\n- 除以 $x^{n-2}$ (假设 $x \\neq 0$), 得到:\n```math\nx^2 = x + 1\n```\n这就是斐波那契数列的 **特征方程**\n\n**3. 求解特征方程:**\n\n- 解这个方程可以得到两个根:\n```math\n\\begin{align*}\n&x_1 = \\frac{1 + \\sqrt{5}}{2} \\quad (黄金比例) \\quad\\quad\n&x_2 = \\frac{1 - \\sqrt{5}}{2}\n\\end{align*}\n```\n**4. 通解的形式:**\n\n根据线性递推关系，通解可以表示为特征根的线性组合：\n```math\nf(n) = A \\cdot x_1^n + B \\cdot x_2^n\n```\n**5. 确定系数:**\n- 通过初始条件来确定系数 `A` 和 `B`\n```math\n\\begin{aligned}\n&\\left\\{\n\\begin{aligned}\nf(0) &= A \\cdot x_1^0 + B \\cdot x_2^0 = 0, \\\\\nf(1) &= A \\cdot x_1 + B \\cdot x_2 = 1, \\\\\nf(2) &= A \\cdot x_1^2 + B \\cdot x_2^2 = 2.\n\\end{aligned}\n\\right. \n\\\\\n&\\left\\{\n\\begin{aligned}\nA + B &= 0, \\\\\nA \\cdot x_1 + B \\cdot x_2 &= 1.\n\\end{aligned}\n\\right.\n\\end{aligned}\n```\n```math\nA \\cdot \\frac{1 + \\sqrt{5}}{2} + (-A) \\cdot \\frac{1 - \\sqrt{5}}{2} = 1 \n```\n解得\n```math\n\\left\\{\n\\begin{aligned}\n&A \\cdot \\sqrt{5} = 1, \\\\\n&A = \\frac{1}{\\sqrt{5}}, \\\\\n&B = -\\frac{1}{\\sqrt{5}}.\n\\end{aligned}\n\\right.\n```\n- 斐波那契数列的通项公式为:\n```math\nf(n) = \\frac{1}{\\sqrt{5}}(x_1^n - x_2^n)\n```\n### 总结: 不同解法对比\n| 解法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |\n|------|------------|------------|------|------|\n| 递归 | $O(2^n)$   | $O(n)$     | 简单易懂 | 重复计算, 效率低 |\n| 记忆化搜索 | $O(n)$   | $O(n)$     | 避免重复计算 | 需要额外的存储空间 |\n| 动态规划(数组) | $O(n)$   | $O(n)$     | 直观易懂 | 需要额外的数组存储空间 |\n| 动态规划(状态压缩) | $O(n)$   | $O(1)$     | 节省空间 | 代码稍复杂 |\n| 数学解法(斐波那契公式) | $O(1)$   | $O(1)$     | 理论最快，常数时间复杂度 | 浮点运算可能导致精度问题 |\n\n## leetCode 198 打家劫舍\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。\n\n**示例1:**\n> 输入：`nums = [1,2,3,1]`<br/>\n> 输出：`4`<br/>\n> 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3) 。偷窃到的最高金额 = 1 + 3 = 4 。\n\n**示例2:**\n> 输入：`nums = [2,7,9,3,1]`<br/>\n> 输出：`12`<br/>\n> 解释：偷窃 1 号房屋 (金额 = 2)，然后偷窃 3 号房屋 (金额 = 9)，最后偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n\n**提示:**\n- `1 <= nums.length <= 100`\n- `0 <= nums[i] <= 400`\n\n```py\ndef rob(self, nums: List[int]) -> int:\n    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    for i in range(2, n):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n    return dp[-1]\n```\n易懂解法\n```py\ndef rob(self, nums: List[int]) -> int:\n    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n    dp = [[0, 0] for _ in range(n)]\n    dp[0][0] = 0\n    dp[0][1] = nums[0]\n    for i in range(1, n):\n        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])\n        dp[i][1] = dp[i - 1][0] + nums[i]\n    return max(dp[-1][0], dp[-1][1])\n```\n\n## 背包问题\n\n$N$ 个物品, 价值为 $v_i$, 重量为 $w_i$, 背包总容量为 $W$, 找到背包能装下的最大价值\n- 0-1背包问题: 每个物品只能选择 0 或 1 次\n- 完全背包问题: 每个物品可以选择多次\n- 多重背包问题: 每个物品最多选择 $s_i$ 次\n- 分组背包问题: 物品分为若干组, 每组只能选择 0 或 1 次\n\n### 0-1背包问题\n状态表示: `dp[i][j]{:py}` 表示前 `i` 个物品, 背包容量为 `j` 时的最大价值\n\n那么 `dp[N][W]{:py}` 就是我们要求的最大价值\n\n从 `i-1` 到 `i` 这个过程, 有两种情况, 即选第 `i` 个物品和不选第 `i` 个物品:\n- 如果不选第 `i` 个物品, 那么最大价值就是前 `i-1` 个物品的最大价值, 即 `dp[i-1][j]{:py}`\n- 如果选第 `i` 个物品, 那么最大价值就是前 `i-1` 个物品的最大价值加上第 `i` 个物品的价值, 即 `dp[i-1][j-w_i] + v_i{:py}`\n\n> [!note]\n> 这里需要注意, 如果选第 `i` 个物品, 那么背包的容量就要减去第 `i` 个物品的重量, 即 `j-w_i`<br/>\n> 因此 `dp[i][j]{:py}` 就是 `dp[i-1][j]{:py}` 和 `dp[i-1][j-w_i] + v_i{:py}` 的最大值<br/>\n> 注意: 需要判断 `j` 是否大于等于 `w_i`, 如果小于 `w_i`, 那么就不能选第 `i` 个物品, 也就是 `dp[i][j] = dp[i-1][j]{:py}`\n\n状态转移方程:\n```math\ndp[i][j] = \\left\\{\n\\begin{aligned}\n&dp[i-1][j] & j < w_i \\\\\n&max(dp[i-1][j], dp[i-1][j-w_i] + v_i) & j \\geq w_i\n\\end{aligned}\n\\right.\n```\ngraph",
    "toc": [
      {
        "depth": 2,
        "value": "leetCode 70 爬楼梯",
        "slug": "leetcode-70-爬楼梯"
      },
      {
        "depth": 3,
        "value": "分析",
        "slug": "分析"
      },
      {
        "depth": 3,
        "value": "解法1: 递归",
        "slug": "解法1:-递归"
      },
      {
        "depth": 3,
        "value": "解法2: 递归 + 记录返回值 = 记忆化搜索",
        "slug": "解法2:-递归-+-记录返回值-=-记忆化搜索"
      },
      {
        "depth": 3,
        "value": "解法3: 动态规划",
        "slug": "解法3:-动态规划"
      },
      {
        "depth": 3,
        "value": "解法4: DP + 状态压缩(滚动数组)",
        "slug": "解法4:-dp-+-状态压缩(滚动数组)"
      },
      {
        "depth": 3,
        "value": "解法5: 解通项公式",
        "slug": "解法5:-解通项公式"
      },
      {
        "depth": 4,
        "value": "证明",
        "slug": "证明"
      },
      {
        "depth": 5,
        "value": "待定系数法 推导",
        "slug": "待定系数法-推导"
      },
      {
        "depth": 3,
        "value": "总结: 不同解法对比",
        "slug": "总结:-不同解法对比"
      },
      {
        "depth": 2,
        "value": "leetCode 198 打家劫舍",
        "slug": "leetcode-198-打家劫舍"
      },
      {
        "depth": 2,
        "value": "背包问题",
        "slug": "背包问题"
      },
      {
        "depth": 3,
        "value": "0-1背包问题",
        "slug": "0-1背包问题"
      }
    ]
  },
  {
    "title": "paper.mdx",
    "description": "",
    "url": "/blog/2024/03/26/paper.mdx",
    "slug": "2024/03/26/paper.mdx",
    "segments": [
      "2024",
      "03",
      "26",
      "paper.mdx"
    ],
    "filePath": "2024/03/26/paper.mdx",
    "meta": {
      "title": "paper.mdx",
      "description": ""
    },
    "content": "",
    "toc": []
  },
  {
    "title": "graph",
    "description": "图 (Graph) 是一种数据结构, 由节点 (Vertex) 和边 (Edge) 组成, 用于表示对象之间的关系",
    "url": "/blog/2024/03/13/graph.mdx",
    "slug": "2024/03/13/graph.mdx",
    "segments": [
      "2024",
      "03",
      "13",
      "graph.mdx"
    ],
    "filePath": "2024/03/13/graph.mdx",
    "meta": {
      "title": "graph",
      "description": "图 (Graph) 是一种数据结构, 由节点 (Vertex) 和边 (Edge) 组成, 用于表示对象之间的关系",
      "created_at": "2024-03-13T16:39:24.000Z",
      "updated_at": "2025-04-04T16:39:24.000Z",
      "tags": [
        "alg",
        "graph"
      ]
    },
    "content": "\n## 建图\n\n给定 `n` 个节点, `m` 条边, 用 $g(u,v)$ 表示 $u$, $v$ 的信息, 如 连通性, 边权\n```\n5 6\n0 1 2\n1 2 5\n0 3 3\n1 3 4\n3 4 7\n3 2 10\n```\n```mermaid\ngraph TD\n    0((0)) o--o|2| 1((1))\n    1 o--o|5| 2((2))\n    0 o--o|3| 3((3))\n    1 o--o|4| 3\n    3 o--o|7| 4((4))\n    3 o--o|10| 2\n```\n\n### 邻接矩阵\n\n- `g[i][j]` 表示 `i` 到 `j` 的信息\n- `g[i][i] = 0`, 表示到自己的距离为 0\n- 初始值为 `inf`, 表示不可达, 即距离为无穷大\n- 对于无向图, `g[u][v] = g[v][u]`\n\n```py\nfrom math import inf\nn, m = map(int, input().split())\ng = [[inf] * n for _ in range(n)]\nfor _ in range(m):\n    u, v, w = map(int, input().split())\n    g[u][v] = g[v][u] = w\n    g[u][u] = g[v][v] = 0 # 一般的题目中 不写这行 也是可以做对的\n```\n```py\ng = [\n  [0, 2, inf, 3, inf],\n  [2, 0, 5, 4, inf],\n  [inf, 5, 0, inf, inf],\n  [3, 4, inf, 0, 7],\n  [inf, inf, inf, 7, 0]\n]\n```\n\n对于稀疏图: 边数 `<<` 节点数, 邻接矩阵会浪费很多空间, 这时可以使用邻接表\n\n### 邻接表\n```py\nn ,m = map(int, input().split())\ne = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v, w = map(int, input().split())\n    e[u].append((v, w))\n    e[v].append((u, w))\n```\n```math\ne[u][j] = (v, w_{u,v})\n```\n```py\ne = [\n  [(1, 2), (3, 3)],\n  [(0, 2), (2, 5), (3, 4)],\n  [(1, 5)],\n  [(0, 3), (1, 4), (4, 7), (2, 10)],\n  [(3, 7)]\n]\n```\n- 对于稀疏图, 可以节省空间, 另外 可以直接获取邻居数量\n- 注意: 空间复杂度依旧是 $O(n^2)$, 只是常数小了很多\n\n## 遍历\n\n### dfs序\n\n```py\ns = set() # 已经访问的节点\ndef dfs(u):\n    if u in s:\n        return\n    # 操作开始 ---\n    # 操作\n    # 操作结束 ---\n    s.add(u)\n    for v, w in e[u]:\n        dfs(v)\n```\n\n#### leetCode 1971 寻找图中是否存在路径\nhttps://leetcode.cn/problems/find-if-path-exists-in-graph/\n\n有一个具有 `n` 个顶点的 双向 图，其中每个顶点标记从 `0` 到 `n - 1` (包含 `0` 和 `n - 1`) 。图中的边用一个二维整数数组 `edges` 表示，其中 `edges[i] = [u_i, v_i]{:ts}`表示顶点 `u_i` 和顶点 `v_i` 之间的双向边。 每个顶点对由 最多一条 边连接，并且没有顶点存在与自身相连的边。\n\n请你确定是否存在从顶点 `source` 开始，到顶点 `destination` 结束的 有效路径 。\n\n给你数组 `edges` 和整数 `n`、`source` 和 `destination`,如果从 `source` 到 `destination` 存在 有效路径 ，则返回 `true{:ts}`, 否则返回 `false{:ts}` 。\n\n**示例1:**\n```mermaid\ngraph TD\n    0((0)) --- 1((1))\n    0 --- 2((2))\n    1 --- 2\n```\n\n> **输入：**n=3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2<br/>\n> **输出：**true<br/>\n> **解释：**存在路径 0 -> 2<br/>\n> **示例2:**\n\n```mermaid\ngraph TD\n    0((0)) --- 1((1))\n    0 --- 2((2))\n    3((3)) --- 4((4))\n    3 --- 5((5))\n    4 --- 5\n```\n\n> **输入：** n=6, edges = [[0,1],[0,2],[3,4],[5,4],[5,3]], source = 0, destination = 5<br/>\n> **输出：** false<br/>\n> **解释：** 不存在路径 0 -> 5\n\n**提示:**\n- `1 <= n <= 2 * 10^4`\n- `0 <= edges.length <= 2 * 10^4`\n- `edges[i].length == 2`\n- `0 <= u_i, v_i <= n - 1`\n- `u_i != v_i`\n- `0 <= source, destination <= n - 1`\n- 不存在重复边\n- 不存在指向自身的边\n\n```py\ndef validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n    e = [[] for _ in range(n)]\n    for u, v in edges:\n        e[u].append(v)\n        e[v].append(u)\n\n    s = set()\n    def dfs(u):\n        if u in s:\n            return False\n        if u == destination:\n            return True\n        s.add(u)\n        for v in e[u]:\n            if dfs(v):\n                return True\n        return False\n\n    return dfs(source)\n```\n",
    "toc": [
      {
        "depth": 2,
        "value": "建图",
        "slug": "建图"
      },
      {
        "depth": 3,
        "value": "邻接矩阵",
        "slug": "邻接矩阵"
      },
      {
        "depth": 3,
        "value": "邻接表",
        "slug": "邻接表"
      },
      {
        "depth": 2,
        "value": "遍历",
        "slug": "遍历"
      },
      {
        "depth": 3,
        "value": "dfs序",
        "slug": "dfs序"
      },
      {
        "depth": 4,
        "value": "leetCode 1971 寻找图中是否存在路径",
        "slug": "leetcode-1971-寻找图中是否存在路径"
      }
    ]
  },
  {
    "title": "Latex",
    "description": "LaTeX 是一种基于排版的文档准备系统，广泛用于学术论文、书籍和演示文稿的编写。它以其强大的数学公式支持和高质量的排版效果而闻名。",
    "url": "/blog/2024/05/19/latex.mdx",
    "slug": "2024/05/19/latex.mdx",
    "segments": [
      "2024",
      "05",
      "19",
      "latex.mdx"
    ],
    "filePath": "2024/05/19/latex.mdx",
    "meta": {
      "title": "Latex",
      "description": "LaTeX 是一种基于排版的文档准备系统，广泛用于学术论文、书籍和演示文稿的编写。它以其强大的数学公式支持和高质量的排版效果而闻名。",
      "created_at": "2024-05-19T19:35:46.000Z",
      "updated_at": "2025-03-28T19:35:46.000Z",
      "tags": [
        "docs",
        "math",
        "latex"
      ]
    },
    "content": "\n## 基本结构\n\n一个简单的 LaTeX 文档通常包含以下结构：\n\n```latex\n\\documentclass{article} % 文档类型\n\\usepackage{amsmath}    % 数学公式支持\n\\begin{document}\n\n\\section{引言}\n这是一个简单的 LaTeX 示例。\n\n\\subsection{数学公式}\n以下是一个数学公式示例：\n\\[\nE = mc^2\n\\]\n\n\\end{document}\n```\n\n## 数学公式\n\nLaTeX 对数学公式的支持非常强大。以下是一些常见的公式示例：\n\n行内公式：\n```latex\n这是一个行内公式 $a^2 + b^2 = c^2$。\n```\n\n块级公式：\n```latex\n\\[\n\\int_a^b f(x) \\, dx = F(b) - F(a)\n\\]\n```\n\n### 希腊字母\n```latex\n\\alpha, \\beta, \\gamma, \\delta, \\epsilon, \\pi, \\sigma\n```\n```math\n\\begin{align}\n&\\alpha \\quad A \\quad  \\text{希腊字母 alpha} \\quad   \\\\\n&\\beta \\quad B  \\text{希腊字母 beta} \\\\\n&\\gamma \\quad \\Gamma \\quad  \\text{希腊字母 gamma} \\\\\n&\\delta \\quad \\Delta \\quad  \\text{希腊字母 delta} \\\\\n&\\epsilon \\quad E  \\text{希腊字母 epsilon} \\\\\n&\\zeta \\quad Z \\quad  \\text{希腊字母 zeta} \\\\\n&\\eta \\quad H \\quad  \\text{希腊字母 eta} \\\\\n&\\theta \\quad \\Theta \\quad  \\text{希腊字母 theta} \\\\\n&\\iota \\quad I \\quad  \\text{希腊字母 iota} \\\\\n&\\kappa \\quad K \\quad  \\text{希腊字母 kappa} \\\\\n&\\lambda \\quad \\Lambda \\quad  \\text{希腊字母 lambda} \\\\\n&\\mu \\quad M \\quad  \\text{希腊字母 mu} \\\\\n&\\nu \\quad N \\quad  \\text{希腊字母 nu} \\\\\n&\\xi \\quad \\Xi \\quad  \\text{希腊字母 xi} \\\\\n&\\omicron \\quad O \\quad  \\text{希腊字母 omicron} \\\\\n&\\pi \\quad \\Pi \\quad  \\text{希腊字母 pi} \\\\\n&\\rho \\quad P  \\quad \\text{希腊字母 rho} \\\\\n&\\sigma \\quad \\Sigma \\quad  \\text{希腊字母 sigma}\\\\\n&\\tau \\quad T \\quad  \\text{希腊字母 tau} \\\\\n&\\upsilon \\quad \\Upsilon \\quad  \\text{希腊字母 upsilon} \\\\\n&\\phi \\quad \\Phi \\quad  \\text{希腊字母 phi} \\\\\n&\\chi \\quad X \\quad  \\text{希腊字母 chi} \\\\\n&\\psi \\quad \\Psi \\quad  \\text{希腊字母 psi} \\\\\n&\\omega \\quad \\Omega  \\quad  \\text{希腊字母 omega} \\\\\n&\\varepsilon \\ :varepsilon,\\ \\vartheta\\ :vartheta,\\ \\varpi\\ :varpi,\\ \\varrho\\ :varrho,\\ \\varsigma\\ :varsigma, \\varphi\\ :varphi \\\\\n\\end{align}\n```\n\n## 表格\n\n使用 `tabular` 环境可以创建表格：\n\n```latex\n\\begin{tabular}{|c|c|c|}\n\\hline\n列1 & 列2 & 列3 \\\\\n\\hline\n数据1 & 数据2 & 数据3 \\\\\n\\hline\n\\end{tabular}\n```\n\n## 插入图片\n\n使用 `graphicx` 包可以插入图片：\n\n```latex\n\\usepackage{graphicx}\n\n\\begin{figure}[h]\n\\centering\n\\includegraphics[width=0.5\\textwidth]{example.png}\n\\caption{示例图片}\n\\end{figure}\n```",
    "toc": [
      {
        "depth": 2,
        "value": "基本结构",
        "slug": "基本结构"
      },
      {
        "depth": 2,
        "value": "数学公式",
        "slug": "数学公式"
      },
      {
        "depth": 3,
        "value": "希腊字母",
        "slug": "希腊字母"
      },
      {
        "depth": 2,
        "value": "表格",
        "slug": "表格"
      },
      {
        "depth": 2,
        "value": "插入图片",
        "slug": "插入图片"
      }
    ]
  },
  {
    "title": "Java",
    "description": "东西都被删除了吗 runtime function 重...",
    "url": "/blog/2024/10/12/java.mdx",
    "slug": "2024/10/12/java.mdx",
    "segments": [
      "2024",
      "10",
      "12",
      "java.mdx"
    ],
    "filePath": "2024/10/12/java.mdx",
    "meta": {
      "title": "Java",
      "description": "东西都被删除了吗 runtime function 重...",
      "created_at": "2024-10-12T15:55:11.000Z",
      "updated_at": "2025-03-30T15:55:11.000Z",
      "tags": [
        "java"
      ]
    },
    "content": "\n东西都被删除了吗\n\n## runtime\n\n## function\n\n### 重写 (Override)\n\n### 重载 (Overload)\n\n",
    "toc": [
      {
        "depth": 2,
        "value": "runtime",
        "slug": "runtime"
      },
      {
        "depth": 2,
        "value": "function",
        "slug": "function"
      },
      {
        "depth": 3,
        "value": "重写 (Override)",
        "slug": "重写-(override)"
      },
      {
        "depth": 3,
        "value": "重载 (Overload)",
        "slug": "重载-(overload)"
      }
    ]
  },
  {
    "title": "websocket",
    "description": "v",
    "url": "/blog/2025/02/01/ws.mdx",
    "slug": "2025/02/01/ws.mdx",
    "segments": [
      "2025",
      "02",
      "01",
      "ws.mdx"
    ],
    "filePath": "2025/02/01/ws.mdx",
    "meta": {
      "title": "websocket",
      "description": "v",
      "created_at": "2025-02-01T17:34:03.000Z",
      "updated_at": "2025-04-02T17:34:03.000Z",
      "tags": [
        "web",
        "ws"
      ]
    },
    "content": "",
    "toc": []
  },
  {
    "title": "alg",
    "description": "算法竞赛学习路线 算法竞赛是一个需要扎实的数学基础和编...",
    "url": "/blog/2025/03/25/alg.mdx",
    "slug": "2025/03/25/alg.mdx",
    "segments": [
      "2025",
      "03",
      "25",
      "alg.mdx"
    ],
    "filePath": "2025/03/25/alg.mdx",
    "meta": {
      "title": "alg",
      "description": "算法竞赛学习路线 算法竞赛是一个需要扎实的数学基础和编...",
      "created_at": "2025-03-28T19:55:10.000Z",
      "updated_at": "2025-03-28T19:55:10.000Z",
      "tags": [
        "alg"
      ]
    },
    "content": "\n## 算法竞赛学习路线\n算法竞赛是一个需要扎实的数学基础和编程能力的领域。以下是一个系统的学习路线，帮助你在算法竞赛中取得更好的成绩。\n\n### 基础数据结构\n   - **数组与字符串**：基本操作、滑动窗口、双指针。\n   - **栈与队列**：单调栈、单调队列、优先队列。\n   - **链表**：单链表、双向链表、环形链表。\n   - **哈希表**：哈希映射、哈希集合。\n   - **树与图**：二叉树、二叉搜索树、并查集（如你当前的文档）、图的表示方法（邻接表、邻接矩阵）。\n\n### 算法基础\n   - **排序与搜索**：快速排序、归并排序、二分查找。\n   - **递归与分治**：递归思想、分治法的应用。\n   - **动态规划 (DP)**：背包问题、区间 DP、状态压缩 DP。\n   - **贪心算法**：常见贪心策略及其应用。\n   - **图论算法**：\n     - 最短路径：Dijkstra、Floyd-Warshall、Bellman-Ford。\n     - 最小生成树：Prim、Kruskal。\n     - 拓扑排序、强连通分量 (Tarjan 算法)。\n   - **数学相关算法**：\n     - 数论：快速幂、欧几里得算法、线性筛、模运算。\n     - 组合数学：排列组合、容斥原理、生成函数。\n     - 博弈论：Nim 博弈、SG 函数。\n\n### 高级数据结构\n   - **线段树**：区间查询与修改。\n   - **树状数组**：高效处理前缀和问题。\n   - **字典树 (Trie)**：字符串处理。\n   - **堆**：优先队列的实现。\n   - **并查集**：路径压缩与按秩合并（如你当前文档提到的内容）。\n   - **平衡树**：如 AVL 树、红黑树、Treap。\n\n### 算法竞赛技巧\n   - **代码能力**：熟练掌握 C++ 或 Python 等语言，尤其是 STL（C++）或内置函数（Python）。\n   - **模板积累**：常用算法和数据结构的代码模板。\n   - **题型分类**：熟悉常见题型，如模拟、搜索、动态规划、数学题。\n   - **时间与空间优化**：掌握复杂度分析，避免超时或超内存。\n\n### 学习资源\n   - **书籍**：\n     - 《算法竞赛入门经典》（刘汝佳，《算法竞赛入门经典（第2版）》）。\n     - 《算法导论》（Introduction to Algorithms）。\n     - 《挑战程序设计竞赛》（日文版/中文版）。\n   - **在线平台**：\n     - [LeetCode](https://leetcode.com/)：刷题平台，适合练习算法和数据结构。\n     - [Codeforces](https://codeforces.com/)：算法竞赛平台，适合参加比赛。\n     - [AtCoder](https://atcoder.jp/)：日本的算法竞赛平台。\n     - [洛谷](https://www.luogu.com.cn/)：中文算法竞赛平台。\n   - **视频课程**：\n     - B 站上的算法竞赛课程（如《算法竞赛基础》系列）。\n\n### 训练计划\n   - **初期**：每天刷 2-3 道简单题，熟悉基础数据结构和算法。\n   - **中期**：每天刷 1-2 道中等题，尝试解决动态规划和图论问题。\n   - **后期**：参加虚拟比赛，模拟真实竞赛环境，提升解题速度和准确率。\n\n### 数学与算法结合\n   - 你的数学背景可以帮助你在以下领域更快上手：\n     - 数学建模：动态规划、图论问题。\n     - 数论：快速幂、模运算、线性代数在图论中的应用。\n     - 组合数学：排列组合、概率问题。\n\n通过系统学习和不断练习，你可以快速提升算法竞赛能力！",
    "toc": [
      {
        "depth": 2,
        "value": "算法竞赛学习路线",
        "slug": "算法竞赛学习路线"
      },
      {
        "depth": 3,
        "value": "基础数据结构",
        "slug": "基础数据结构"
      },
      {
        "depth": 3,
        "value": "算法基础",
        "slug": "算法基础"
      },
      {
        "depth": 3,
        "value": "高级数据结构",
        "slug": "高级数据结构"
      },
      {
        "depth": 3,
        "value": "算法竞赛技巧",
        "slug": "算法竞赛技巧"
      },
      {
        "depth": 3,
        "value": "学习资源",
        "slug": "学习资源"
      },
      {
        "depth": 3,
        "value": "训练计划",
        "slug": "训练计划"
      },
      {
        "depth": 3,
        "value": "数学与算法结合",
        "slug": "数学与算法结合"
      }
    ]
  },
  {
    "title": "bfs",
    "description": "通常是指 广度优先搜索 (Breadth-First Search)，一种经典的图算法，用于遍历或搜索树或图的数据结构",
    "url": "/blog/2025/03/26/bfs.mdx",
    "slug": "2025/03/26/bfs.mdx",
    "segments": [
      "2025",
      "03",
      "26",
      "bfs.mdx"
    ],
    "filePath": "2025/03/26/bfs.mdx",
    "meta": {
      "title": "bfs",
      "description": "通常是指 广度优先搜索 (Breadth-First Search)，一种经典的图算法，用于遍历或搜索树或图的数据结构",
      "created_at": "2025-03-26T22:29:10.000Z",
      "updated_at": "2025-03-27T20:40:13.000Z",
      "tags": [
        "alg",
        "bfs"
      ]
    },
    "content": "\n## BFS 思想\n\nBFS 通常是指 广度优先搜索 (Breadth-First Search)，一种经典的图算法，用于遍历或搜索树或图的数据结构。\n\nBFS 的核心是逐层扩展，使用队列存储待访问的节点\n1. 遍历所有相邻节点（如岛屿问题）。\n2. 模拟扩散过程。\n3. 求最短路径。\n\n## leetCode 695. 岛屿的最大面积\n\n[695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)\n\n给你一个大小为 `m x n` 的二进制矩阵 `grid` 。\n\n岛屿 是由一些相邻的 `1` (代表土地) 构成的组合，这里的「相邻」要求两个 `1` 必须在 水平或者竖直的四个方向上 相邻。你可以假设 `grid` 的四个边缘都被 `0` （代表水）包围着。\n\n岛屿的面积是岛上值为 `1` 的单元格的数目。\n\n计算并返回 `grid` 中最大的岛屿面积。如果没有岛屿，则返回面积为 `0` \n\n**示例 1:**\n![1](https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg)\n> **输入:** \n> ```py\n> grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],\n>         [0,0,0,0,0,0,0,1,1,1,0,0,0],\n>         [0,1,1,0,1,0,0,0,0,0,0,0,0],\n>         [0,1,0,0,1,1,0,0,1,0,1,0,0],\n>         [0,1,0,0,1,1,0,0,1,1,1,0,0],\n>         [0,0,0,0,0,0,0,0,0,0,1,0,0],\n>         [0,0,0,0,0,0,0,1,1,1,0,0,0],\n>         [0,0,0,0,0,0,0,1,1,0,0,0,0]]\n> ```\n> **输出:** 6 <br/>\n> **解释:** 答案不应该是 `11` ，因为岛屿只能包含水平或垂直这四个方向上的 `1` 。\n\n**示例 2:**\n> **输入:** `grid = [[0,0,0,0,0,0,0,0]]{:py}` <br/>\n> **输出:** 0\n\n**提示:**\n- `m == grid.length`\n- `n == grid[i].length`\n- `1 <= m, n <= 50`\n- `grid[i][j]` 为 `0` 或 `1`\n\n```py showLineNumbers\ndef maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    # 维护一个结果变量\n    res = 0\n    # 定义一个方向数组\n    d1 = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    # 遍历每个点\n    for i in range(m):\n        for j in range(n):\n        # 如果当前点是陆地\n        if grid[i][j] == 1:\n            # 将当前点加入队列\n            q = [(i, j)]\n            # 维护当前岛屿的面积\n            area = 1\n            # 将当前点置为 0\n            grid[i][j] = 0\n            # 遍历队列\n            while q:\n                # 取出队列的第一个元素\n                x, y = q.pop(0)\n                # 遍历四个方向\n                for dx, dy in d1:\n                    # 计算新的坐标\n                    nx, ny = x + dx, y + dy\n                    # 如果新的坐标合法\n                    if 0 <= nx < m and 0 <= ny < n and grid[nx][ny]:\n                    # 将新的坐标加入队列\n                    q.append((nx, ny))\n                    # 将新的坐标置为 0\n                    grid[nx][ny] = 0\n                    # 面积加一\n                    area += 1\n            # 更新结果\n            res = max(res, area)\n    return res\n```\n\n## lanqiao 长草\n\nhttps://www.lanqiao.cn/problems/149/learning/?page=1&first_category_id=1&tags=BFS&tag_relation=intersection&difficulty=20\n\n**题目描述**\n\n小明有一块空地，他将这块空地划分为 n 行 m 列的小块，每行和每列的长度都为 1。\n\n小明选了其中的一些小块空地，种上了草，其他小块仍然保持是空地。\n\n这些草长得很快，每个月，草都会向外长出一些，如果一个小块种了草，则它将向自己的上、下、左、右四小块空地扩展，\n\n这四小块空地都将变为有草的小块。请告诉小明, k 个月后空地上哪些地方有草。\n**输入描述**\n\n输入的第一行包含两个整数 n,m。\n\n接下来 n 行，每行包含 m 个字母，表示初始的空地状态，字母之间没有空格。如果为小数点，表示为空地，如果字母为 g, 表示种了草。\n\n接下来包含一个整数 k。 其中, 2≤n,m≤1000, 1≤k≤1000\n**输出描述**\n\n输出 n 行，每行包含 m 个字母，表示 k 个月后空地的状态。如果为小数点，表示为空地，如果字母为 g, 表示长了草。\n**输入输出样例**\n**示例**\n\n>输入\n```\n4 5\n.g...\n.....\n..g..\n.....\n2\n```\n>输出\n```\ngggg.\ngggg.\nggggg\n.ggg.\n```\n**运行限制**\n\n- 最大运行时间: 1s\n- 最大运行内存: 256M\n\n```py showLineNumbers\nimport sys\nfrom collections import deque\ninput = lambda: sys.stdin.readline().strip()\ndef grass_growth(n, m, grid, k):\n    # 定义方向数组（上下左右）\n    d1 = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # 初始化队列，找到所有初始种草的格子\n    q = deque()\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == 1:\n                print(\"aq\")\n                q.append((y, x))\n    \n    # 模拟 k 个月的扩展\n    for _ in range(k):\n        print('k')\n        for _ in range(len(q)):\n            print('q', len(q))\n            y, x = q.popleft()\n            for dy, dx in d1:\n                ny, nx = y + dy, x + dx\n                # 检查边界条件和是否为空地\n                if 0 <= ny < n and 0 <= nx < m and grid[ny][nx] == 0:\n                    grid[ny][nx] = 1  # 将空地变为草\n                    q.append((ny, nx))\n    \n    # 返回最终的状态\n    return grid\n\nn, m = map(int, input().split())\ngrid = [[0]*m for _ in range(n)]\nprint(grid)\nfor y in range(n):\n    r = input()\n    print(r)\n    for x in range(m):\n        if r[x] == 'g':\n            print('rx==g')\n            grid[y][x] = 1\nprint(grid)\nk = int(input())\nres = grass_growth(n, m, grid, k)\nfor row in res:\n    print(''.join(['g' if x == 1 else '.' for x in row]))\n```\n",
    "toc": [
      {
        "depth": 2,
        "value": "BFS 思想",
        "slug": "bfs-思想"
      },
      {
        "depth": 2,
        "value": "leetCode 695. 岛屿的最大面积",
        "slug": "leetcode-695.-岛屿的最大面积"
      },
      {
        "depth": 2,
        "value": "lanqiao 长草",
        "slug": "lanqiao-长草"
      }
    ]
  },
  {
    "title": "export",
    "description": "当想要将next.js项目导出为静态网站时, 可以使用next export命令。",
    "url": "/blog/2025/03/26/export.mdx",
    "slug": "2025/03/26/export.mdx",
    "segments": [
      "2025",
      "03",
      "26",
      "export.mdx"
    ],
    "filePath": "2025/03/26/export.mdx",
    "meta": {
      "title": "export",
      "description": "当想要将next.js项目导出为静态网站时, 可以使用next export命令。",
      "created_at": "2025-03-26T03:42:29.000Z",
      "updated_at": "2025-03-26T03:42:29.000Z",
      "tags": [
        "nextjs",
        "export",
        "html"
      ]
    },
    "content": "\n## Unsupported feature\n> 不支持的功能\n\nhttps://nextjs.org/docs/app/building-your-application/deploying/static-exports#unsupported-features\n\nFeatures that require a Node.js server, or dynamic logic that cannot be computed during the build process, are **not** supported:\n> 需要Node.js服务器的功能, 或者在构建过程中无法计算的动态逻辑，**不**支持：\n- Dynamic Routes with `dynamicParams: true`\n- Dynamic Routes without `generateStaticParams()`\n- ...\n\n## 注意\n\n可能不会识别 next.config.ts 导致变成默认配置, 尽量写 next.config.js 或者 next.config.mjs",
    "toc": [
      {
        "depth": 2,
        "value": "Unsupported feature",
        "slug": "unsupported-feature"
      },
      {
        "depth": 2,
        "value": "注意",
        "slug": "注意"
      }
    ]
  },
  {
    "title": "Next PWA",
    "description": "渐进式 Web 应用（PWA）结合了 Web 应用的覆盖范围和可访问性，以及原生移动应用的功能和用户体验。使用 Next.js，您可以创建提供无缝、类似应用体验的 PWA，无需多个代码库或应用商店审批",
    "url": "/blog/2025/03/26/nextPwa.mdx",
    "slug": "2025/03/26/nextPwa.mdx",
    "segments": [
      "2025",
      "03",
      "26",
      "nextPwa.mdx"
    ],
    "filePath": "2025/03/26/nextPwa.mdx",
    "meta": {
      "title": "Next PWA",
      "description": "渐进式 Web 应用（PWA）结合了 Web 应用的覆盖范围和可访问性，以及原生移动应用的功能和用户体验。使用 Next.js，您可以创建提供无缝、类似应用体验的 PWA，无需多个代码库或应用商店审批",
      "created_at": "2025-03-29T05:13:17.000Z",
      "updated_at": "2025-03-29T05:13:17.000Z",
      "tags": [
        "nextjs",
        "pwa"
      ]
    },
    "content": "偶然发现 nextjs15 版本中内置了对 PWA 的支持, https://nextjs.org/docs/app/building-your-application/configuring/progressive-web-apps\n",
    "toc": []
  },
  {
    "title": "api",
    "description": "fastApi vs hono",
    "url": "/blog/2025/03/27/api.mdx",
    "slug": "2025/03/27/api.mdx",
    "segments": [
      "2025",
      "03",
      "27",
      "api.mdx"
    ],
    "filePath": "2025/03/27/api.mdx",
    "meta": {
      "title": "api",
      "description": "fastApi vs hono",
      "created_at": "2025-03-27T23:15:42.000Z",
      "updated_at": "2025-03-27T23:15:42.000Z",
      "tags": [
        "web",
        "api"
      ]
    },
    "content": "",
    "toc": []
  },
  {
    "title": "dfs",
    "description": "最大数字 lanqiao 2193 https://w...",
    "url": "/blog/2025/03/27/dfs.mdx",
    "slug": "2025/03/27/dfs.mdx",
    "segments": [
      "2025",
      "03",
      "27",
      "dfs.mdx"
    ],
    "filePath": "2025/03/27/dfs.mdx",
    "meta": {
      "title": "dfs",
      "description": "最大数字 lanqiao 2193 https://w...",
      "created_at": "2025-03-27T20:41:55.000Z",
      "updated_at": "2025-03-27T20:41:55.000Z",
      "tags": [
        "alg",
        "dfs"
      ]
    },
    "content": "\n## 最大数字 lanqiao 2193\nhttps://www.lanqiao.cn/problems/2193/learning/?page=1&first_category_id=1&name=%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97\n\n**问题描述**\n\n给定一个正整数 N 。你可以对 N 的任意一位数字执行任意次以下 2 种操 作：\n\n1. 将该位数字加 1 。如果该位数字已经是 9 , 加 1 之后变成 0 。\n\n2. 将该位数字减 1 。如果该位数字已经是 0 , 减 1 之后变成 9 。\n\n你现在总共可以执行 1 号操作不超过 A 次, 2 号操作不超过 B 次。 请问你最大可以将 N 变成多少?\n**输入格式**\n\n第一行包含 3 个整数: N,A,B\n**输出格式**\n\n一个整数代表答案。\n**样例输入**\n```\n123 1 2\n```\n**样例输出**\n```\n933\n```\n**样例说明**\n\n对百位数字执行 2 次 2 号操作, 对十位数字执行 1 次 1 号操作。\n**评测用例规模与约定**\n\n对于 30%30% 的数据, 1≤N≤100; 0≤A,B≤10\n\n对于 100%100% 的数据, 1≤N≤10^17;0≤A,B≤100\n**运行限制**\n\n- 最大运行时间: 1s\n- 最大运行内存: 512M\n\n**思路**: \n1. 贪心: 从左到右, 近可能构造9\n\n```py\nN, A, B = map(int, input().split())\nsN = str(N)\nlenN = len(sN)\nres = 0\n# 当前的贪心策略虽然高效, 但在某些情况下可能无法找到全局最优解\nfor i in range(len(sN)):\n    base = 10 ** (lenN - i - 1)\n    x = int(sN[i])\n    if x != 9:\n        need_add = 9 - x\n        need_sub = x+1\n        if need_add<= A  and (need_add <= need_sub or B < need_sub):\n            A -= need_add\n            res += 9 * base\n        elif need_sub <= B:\n            B -= need_sub\n            res += 9 * base\n        elif 0 < A:\n            res += (x + A) * base\n            A = 0\n        else:\n          res += x * base\n    else:\n        res += x * base\nprint(res)\n```\n\n```py\ndef dfs(i, curr, a, b):\n    global res\n    if  i == lenN:\n        res = max(res, curr)\n        return\n    x = int(sN[i])\n    d = min(9-x, a)\n    dfs(i+1, curr*10+(x+d), a-d, b)\n    if x+1<=b:\n        dfs(i+1, curr*10+9, a, b-(x+1))\ndfs(0, 0, A, B)\n```\n\n## 小朋友崇拜圈 lanqiao 182\n\nhttps://www.lanqiao.cn/problems/182/learning/?page=1&first_category_id=1&name=%E5%B0%8F%E6%9C%8B%E5%8F%8B%E5%B4%87%E6%8B%9C%E5%9C%88\n\n**题目描述**\n\n班里 N 个小朋友，每个人都有自己最崇拜的一个小朋友（也可以是自己）。\n\n在一个游戏中，需要小朋友坐一个圈，每个小朋友都有自己最崇拜的小朋友在他的右手边。\n\n求满足条件的圈最大多少人？\n\n小朋友编号为 1,2,3,⋯N\n**输入描述**\n\n输入第一行，一个整数 `N (3<N<10^5)`\n\n接下来一行 N 个整数，由空格分开。\n**输出描述**\n\n要求输出一个整数，表示满足条件的最大圈的人数。\n**输入输出样例**\n\n示例\n\n>输入\n```\n9\n3 4 2 5 3 8 4 6 9\n```\n\n>输出\n\n```\n4\n```\n\n>样例解释\n\n如下图所示，崇拜关系用箭头表示，红色表示不在圈中。\n\n显然，最大圈是[2 4 5 3] 构成的圈。\n```mermaid\ngraph LR\n    1((1))-->3\n    2((2))-->4\n    3((3))-->2\n    4((4))-->5\n    5((5))-->3\n    6((6))-->8\n    7((7))-->4\n    8((8))-->6\n    9((9))-->9\n```\n运行限制\n\n- 最大运行时间: 1s\n- 最大运行内存: 256M\n\n**分析**\n- 每个节点 `u` 有且仅有一条出边 `u->v`, 给定数组 `g`, `g[u]==v` 表示这条出边\n\n```py showLineNumbers\nimport sys\nsys.setrecursionlimit(10**5)\nn = int(input())\ng = [0]+ list(map(int, input().split()))\nres = 0 \ndct = {}\ndef dfs(u, idx):\n    global res\n    if u in dct:\n        res = max(res, idx - dct[u])\n        return\n    dct[u] = idx\n    dfs(g[u], idx+1)\nfor u in range(1, n+1):\n    dfs(u, 0)\nprint(res)\n```\n",
    "toc": [
      {
        "depth": 2,
        "value": "最大数字 lanqiao 2193",
        "slug": "最大数字-lanqiao-2193"
      },
      {
        "depth": 2,
        "value": "小朋友崇拜圈 lanqiao 182",
        "slug": "小朋友崇拜圈-lanqiao-182"
      }
    ]
  },
  {
    "title": "Union-Find",
    "description": "并查集 (Disjoint Set Union, 简称 DSU 或 Union-Find) 并查集通常实现为一个森林，其中每棵树表示一个集合 是一种用于处理动态连通性问题的数据结构。",
    "url": "/blog/2025/03/28/Union-Find.mdx",
    "slug": "2025/03/28/Union-Find.mdx",
    "segments": [
      "2025",
      "03",
      "28",
      "Union-Find.mdx"
    ],
    "filePath": "2025/03/28/Union-Find.mdx",
    "meta": {
      "title": "Union-Find",
      "description": "并查集 (Disjoint Set Union, 简称 DSU 或 Union-Find) 并查集通常实现为一个森林，其中每棵树表示一个集合 是一种用于处理动态连通性问题的数据结构。",
      "created_at": "2025-03-28T19:28:35.000Z",
      "updated_at": "2025-03-30T02:10:58.000Z",
      "tags": [
        "alg",
        "tree"
      ]
    },
    "content": "```mermaid\ngraph BT\n    2((2)) --\"fa[2]\"-->  1((1))\n    3((3)) --\"fa[3]\"-->  1\n    4((4)) --\"fa[4]\"-->  3\n    5((5)) --\"fa[5]\"-->  3\n    8((8)) -->  7((7))\n    7 -->  6((6))\n```\n## overview\n\n它可以高效地解决以下问题: \n1. 合并 (Union) ：将两个集合合并为一个集合 (合并对应的树)。\n2. 查询 (Find) ：查询某个元素属于哪个集合 (通常通过找到集合的代表元素, 即根节点)。 \n\n并查集的核心思想是用一个数组表示集合，通过路径压缩和按秩合并优化，使得查询和合并操作的时间复杂度接近常数 (摊还时间复杂度为 $O(\\alpha(n))$，其中 $\\alpha(n)$ 是反阿克曼函数，增长极慢) \n\n### find\n\n```math\n\\begin{align}\n& find(x) = x 所在集合的根节点的值 \\\\\n& if\\quad fa[x] = x : 表示 x 是根节点 \\\\\n& else : find(fa[x]) 递归调用, 沿着树向上找\n\\end{align}\n```\n通常在判断是否可达, 连通性问题时 进行查询, 如需要判断 u, v 是否属于同一个集合, 则可以判断 find(u) == find(v)\n```py\n# 例如 fa[4] = 3 -> fa[3] = 1 -> fa[1] = 1\ndef find(x):\n    if fa[x] == x:\n        return x\n    return find(fa[x])\n```\n```py\n# or 如下写法\ndef find(x):\n    return x if fa[x] == x else find(fa[x])\n\nfind = lambda x: x if fa[x] == x else find(fa[x])\n```\n\n### union\n有时需要将两个集合合并(例如两个家庭结婚), 例如将 u, v 合并为同一个集合, 则可以将 u 的根节点的父节点设为 v 的根节点\n```mermaid\ngraph BT\n    1 --> 6\n    2((2)) -->  1((1))\n    3((3)) -->  1\n    4((4)) -->  3\n    5((5)) -->  3\n    8((8)) -->  7((7))\n    7 -->  6((6))\n```\n```py\ndef union(x, y):\n    x = find(x)\n    y = find(y)\n    if x != y:\n        fa[x] = y\n# or\ndef union(x, y):\n    if find(x) != find(y): fa[find(x)] = find(y)\n```\n> [!info]- python 的 `=` 操作是 **引用模型** (Reference Model)\n> `a = b{:py}` 是将 a 指向 b\n>```py\n> # 赋值语法: 变量 = 字面量; 实际上是\n> b = [1, 2, 3]\n> # 引用语法: 变量 = 变量\n> a = b\n> a[0] = 4\n> print(b) # [4, 2, 3]\n> ```\n\n### 路径压缩\n```mermaid\nflowchart LR\n    subgraph 第一阶段\n        2((2)) -->  1((1))\n        3((3)) -->  1\n        4((4)) -->  3\n        5((5)) -->  3\n    end\n\n    subgraph 第二阶段\n        2.2((2)) -->  2.1((1))\n        2.3((3)) -->  2.1\n        2.4((4)) -->  2.1\n        2.5((5)) -->  2.1\n    end\n\n    第一阶段 --路径压缩--> 第二阶段\n```\n路径压缩是指在查找过程中, 将访问过的节点的父节点直接指向根节点, 以减少树的高度, 提高查询效率\n```py {4}\ndef find(x):\n    if fa[x] == x: # 如果 x 是根节点\n        return x\n    fa[x] = find(fa[x]) # 路径压缩\n    return fa[x]\n```\n我们通过对查询操作引入路径压缩, 可以对比 [find](#find)\n\n### 模板总结\n\n```py title=\"递归模板\"\nfa = list(range(n)) # \ndef find(x):\n    if fa[x] == x: return x\n    fa[x] = find(fa[x]) # 路径压缩\n    return fa[x]\ndef union(x, y):\n    if find(x) != find(y):\n        fa[find(x)] = find(y)\n```\n可以不用考虑迭代模板, 一般不会爆栈的\n```py title=\"迭代模板\"\nfa = list(range(n)) #\ndef find(x):\n    root = x\n    while fa[root] != root:\n        root = fa[root]\n    while fa[x] != x: # 路径压缩\n        fa[x], x = root, fa[x]\n    return root\ndef union(x, y):\n    root_x = find(x)\n    root_y = find(y)\n    if root_x != root_y:\n        fa[root_x] = root_y\n```",
    "toc": [
      {
        "depth": 2,
        "value": "overview",
        "slug": "overview"
      },
      {
        "depth": 3,
        "value": "find",
        "slug": "find"
      },
      {
        "depth": 3,
        "value": "union",
        "slug": "union"
      },
      {
        "depth": 3,
        "value": "路径压缩",
        "slug": "路径压缩"
      },
      {
        "depth": 3,
        "value": "模板总结",
        "slug": "模板总结"
      }
    ]
  },
  {
    "title": "todo",
    "description": "paper | 时间 | 任务 | | ------ ...",
    "url": "/blog/2025/03/30/todo.mdx",
    "slug": "2025/03/30/todo.mdx",
    "segments": [
      "2025",
      "03",
      "30",
      "todo.mdx"
    ],
    "filePath": "2025/03/30/todo.mdx",
    "meta": {
      "title": "todo",
      "description": "paper | 时间 | 任务 | | ------ ...",
      "created_at": "2025-03-30T20:54:11.000Z",
      "updated_at": "2025-03-31T20:54:11.000Z",
      "tags": [
        "todo"
      ]
    },
    "content": "\r\n## paper\r\n\r\n| 时间 | 任务 |\r\n| ------ | ---- |\r\n| 03/31 | 大量阅读 CHARLS 相关论文的摘要, 并下载 |\r\n| 04/01 | 描述性统计 |\r\n| 04/02 | 阅读一篇 |\r\n| 04/03 | 阅读两篇 |\r\n| 04/04 | 阅读两篇 |\r\n| 04/05 | 阅读两篇 |\r\n| 04/06 | 回归 |\r\n",
    "toc": [
      {
        "depth": 2,
        "value": "paper",
        "slug": "paper"
      }
    ]
  },
  {
    "title": "paper",
    "description": "常规生物医学指标与中国老年人健康状况的相关性研究 ht...",
    "url": "/blog/2025/03/31/paper.mdx",
    "slug": "2025/03/31/paper.mdx",
    "segments": [
      "2025",
      "03",
      "31",
      "paper.mdx"
    ],
    "filePath": "2025/03/31/paper.mdx",
    "meta": {
      "title": "paper",
      "description": "常规生物医学指标与中国老年人健康状况的相关性研究 ht...",
      "created_at": "2025-03-31T20:55:25.000Z",
      "updated_at": "2025-03-31T20:55:25.000Z",
      "tags": []
    },
    "content": "\r\n## 常规生物医学指标与中国老年人健康状况的相关性研究\r\n\r\nhttp://vgms.fanyu.com\r\n\r\n2020 CHARLS Wave 5\r\n\r\n## 数据集\r\n\r\n### 2020 CHARLS Wave 5\r\n\r\n本次数据发布 (版本号: 20231106) 一共发布了八个主要数据集以及两个辅助数据集  (样本信息以及横截面权重) 。PSU信息与往期数据相同。下表给出了这十个数据集的详细\r\n说明\r\n\r\n| 问卷模块 | dataset | description |\r\n| -------- | ------- | ----------- |\r\n| B. 基本信息 | Demographic_Background | 主要受访者及其配偶的基本人口学信息 |\r\n| C. 家庭信息 |  Family_Information | 家庭以及家户成员信息 |\r\n| D. 健康状况与功能 | Health_Status_and_Functioning | 健康状态、健康行为以及认知能力 |\r\n| F. 工作与退休 | Work_Retirement | 工作以及退休状况 |\r\n| G1. 家户收入与支出 | Household_Income | 家户收入、支出以及住房情况 |\r\n| G2. 个人收入 | Individual_Income | 个人收入 |\r\n| V. 疫情 | COVID_Module | 受访者疫情期间的相关信息 |\r\n| EX. 退出问卷 | EXIT_Module | 去世受访者的信息 |\r\n|  | Weights | 横截面权重 |\r\n| | Sample_Infor | 样本信息 |\r\n\r\n所有的数据集均以Stata 14格式存储, 用户可以通过随数据发布的“codebook”获取\r\n数据的基本统计描述。\r\n",
    "toc": [
      {
        "depth": 2,
        "value": "常规生物医学指标与中国老年人健康状况的相关性研究",
        "slug": "常规生物医学指标与中国老年人健康状况的相关性研究"
      },
      {
        "depth": 2,
        "value": "数据集",
        "slug": "数据集"
      },
      {
        "depth": 3,
        "value": "2020 CHARLS Wave 5",
        "slug": "2020-charls-wave-5"
      }
    ]
  },
  {
    "title": "微积分",
    "description": "...",
    "url": "/blog/2021/11/11/calculus.mdx",
    "slug": "2021/11/11/calculus.mdx",
    "segments": [
      "2021",
      "11",
      "11",
      "calculus.mdx"
    ],
    "filePath": "2021/11/11/calculus.mdx",
    "meta": {
      "title": "微积分",
      "description": "...",
      "created_at": "2021-11-11T10:13:16.000Z",
      "updated_at": "2025-03-30T10:13:16.000Z",
      "tags": [
        "math"
      ]
    },
    "content": "",
    "toc": []
  },
  {
    "title": "var",
    "description": "赋值 (Assignment) 引用 (Referen...",
    "url": "/blog/2021/12/11/var.mdx",
    "slug": "2021/12/11/var.mdx",
    "segments": [
      "2021",
      "12",
      "11",
      "var.mdx"
    ],
    "filePath": "2021/12/11/var.mdx",
    "meta": {
      "title": "var",
      "description": "赋值 (Assignment) 引用 (Referen...",
      "created_at": "2021-12-11T10:11:52.000Z",
      "updated_at": "2025-03-30T10:11:52.000Z",
      "tags": [
        "c"
      ]
    },
    "content": "\n## 赋值 (Assignment)\n\n### 引用 (Reference)\n\n引用是一个变量的别名，它本质上是一个绑定到已有变量的“标签”，并不是直接的“取地址”\n\n示例:\n```c title=\"c\" \nint a = 10;\nint &b = a;  // b 是 a 的引用\nb = 20;      // 修改 b 等同于修改 a\nstd::cout << a;  // 输出: 20\n```\n\n#### 解引用 (Dereference)\n解引用是通过指针访问指针所指向的内存地址中的值。解引用操作需要显式使用 `*` 运算符\n\n```c title=\"c\"\nint a = 10;\nint *ptr = &a;  // ptr 是指向 a 的指针\n*ptr = 20;      // 解引用 ptr，修改 a 的值\nstd::cout << a;  // 输出: 20\n```\n",
    "toc": [
      {
        "depth": 2,
        "value": "赋值 (Assignment)",
        "slug": "赋值-(assignment)"
      },
      {
        "depth": 3,
        "value": "引用 (Reference)",
        "slug": "引用-(reference)"
      },
      {
        "depth": 4,
        "value": "解引用 (Dereference)",
        "slug": "解引用-(dereference)"
      }
    ]
  },
  {
    "title": "git",
    "description": "git 是一个分布式版本控制系统, 用于跟踪计算机文件的修改, 主要用于源代码管理 (SCM) 。",
    "url": "/blog/2021/12/14/git.mdx",
    "slug": "2021/12/14/git.mdx",
    "segments": [
      "2021",
      "12",
      "14",
      "git.mdx"
    ],
    "filePath": "2021/12/14/git.mdx",
    "meta": {
      "title": "git",
      "description": "git 是一个分布式版本控制系统, 用于跟踪计算机文件的修改, 主要用于源代码管理 (SCM) 。",
      "created_at": "2021-11-14T20:18:40.000Z",
      "updated_at": "2025-03-31T20:18:40.000Z",
      "tags": [
        "git",
        "cli"
      ]
    },
    "content": "\r\n## cli\r\n\r\n### git status\r\n\r\n显示当前工作目录和暂存区的状态。它可以帮助你了解哪些文件被修改、哪些文件被添加到暂存区、哪些文件未被跟踪等信息。\r\n\r\n```sh\r\n🪟 ❯ git status\r\nOn branch main\r\nYour branch is up to date with 'origin/main'.\r\n\r\nnothing to commit, working tree clean\r\n```\r\n>[!note]\r\n> `On branch main` : 当前所在的分支是 `main` 分支<br/>\r\n> `Your branch is up to date with 'origin/main'` : 当前分支与远程分支 `origin/main` 是同步的，没有新的提交。<br/>\r\n> `nothing to commit, working tree clean` : 没有需要提交的更改，工作目录是干净的。<br/>\r\n> `Your branch` : 你的分支<br/>\r\n> `is up to date` : 是最新的<br/>\r\n> `up to date` : 最新的<br/>\r\n> `with 'origin/main'` : 和 `origin/main` 一起<br/>\r\n> `is up to date with ...` : \r\n",
    "toc": [
      {
        "depth": 2,
        "value": "cli",
        "slug": "cli"
      },
      {
        "depth": 3,
        "value": "git status",
        "slug": "git-status"
      }
    ]
  },
  {
    "title": "numberTheory",
    "description": "纯粹数学的分支之一，主要研究整数的性质。 整数可以是方程式的解（丢番图方程）。 有些解析函数（像黎曼ζ函数）中包括了一些整数、质数的性质，透过这些函数也可以了解一些数论的问题。 透过数论也可以建立实数和有理数之间的关系，并且用有理数来逼近实数（丢番图逼近）。",
    "url": "/blog/2012/09/16/numberTheory.mdx",
    "slug": "2012/09/16/numberTheory.mdx",
    "segments": [
      "2012",
      "09",
      "16",
      "numberTheory.mdx"
    ],
    "filePath": "2012/09/16/numberTheory.mdx",
    "meta": {
      "title": "numberTheory",
      "description": "纯粹数学的分支之一，主要研究整数的性质。 整数可以是方程式的解（丢番图方程）。 有些解析函数（像黎曼ζ函数）中包括了一些整数、质数的性质，透过这些函数也可以了解一些数论的问题。 透过数论也可以建立实数和有理数之间的关系，并且用有理数来逼近实数（丢番图逼近）。",
      "created_at": "2012-09-12T20:39:52.000Z",
      "updated_at": "2025-04-04T20:39:52.000Z",
      "tags": [
        "math",
        "numberTheory",
        "alg"
      ]
    },
    "content": "\n## base\n\n### 质数与因数分解\n\n因数也称为约数, 是指能整除一个整数的数\n- 例如: $6$ 的因数有 $1, 2, 3, 6$\n- 例如: $12$ 的因数有 $1, 2, 3, 4, 6, 12$\n\n#### 分解一个数的所有因数\n\n##### 枚举解空间\n\n复杂度为: $O(n)$\n\n```py\ndef divisor(n):\n    res = [1, n]\n    for i in range(1, n + 1):\n        if n % i == 0:\n            res.append(i)\n```\n##### 试除法求所有因数\n找到一个 约数 $d$, 那么 $n/d$ 也是一个约数\n\n复杂度为: $O(\\sqrt{n})$\n```py\ndef divisor(n):\n    res = [1, n]\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            res.append(i) # 添加 $d$\n            if i != n // i:\n                res.append(n // i) # 添加 $n/d$\n    return res\n```\n\n#### 分解质因数\n\n例如:\n- $12 = 2\\times 2 \\times 3 = 2^2 \\times 3^1$, 即 有 2 和 3 两个质因数\n- $60 = 2^2 \\times 3^1 \\times 5^1$, 即 有 2, 3 和 5 三个质因数\n\n```py\n# 试除法\ndef prime_factorization(n):\n    res = []\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            count = 0\n            while n % i == 0:\n                n //= i\n                count += 1\n            res.append((i, count))\n    if n > 1:\n        res.append((n, 1))\n    return res\nprint(prime_factorization(12))  # 输出: [(2, 2), (3, 1)]\n```\n\n",
    "toc": [
      {
        "depth": 2,
        "value": "base",
        "slug": "base"
      },
      {
        "depth": 3,
        "value": "质数与因数分解",
        "slug": "质数与因数分解"
      },
      {
        "depth": 4,
        "value": "分解一个数的所有因数",
        "slug": "分解一个数的所有因数"
      },
      {
        "depth": 5,
        "value": "枚举解空间",
        "slug": "枚举解空间"
      },
      {
        "depth": 5,
        "value": "试除法求所有因数",
        "slug": "试除法求所有因数"
      },
      {
        "depth": 4,
        "value": "分解质因数",
        "slug": "分解质因数"
      }
    ]
  },
  {
    "title": "IDLE",
    "description": "IDLE 是 Python 的集成开发环境 (IDE)，它是用 Python 编写的，提供了一个简单的图形用户界面 (GUI) 来编写和运行 Python 代码。",
    "url": "/blog/2023/06/12/IDLE.mdx",
    "slug": "2023/06/12/IDLE.mdx",
    "segments": [
      "2023",
      "06",
      "12",
      "IDLE.mdx"
    ],
    "filePath": "2023/06/12/IDLE.mdx",
    "meta": {
      "title": "IDLE",
      "description": "IDLE 是 Python 的集成开发环境 (IDE)，它是用 Python 编写的，提供了一个简单的图形用户界面 (GUI) 来编写和运行 Python 代码。",
      "created_at": "2023-06-12T23:35:44.000Z",
      "updated_at": "2025-03-31T23:35:44.000Z",
      "tags": [
        "python",
        "ide"
      ]
    },
    "content": "\r\n```sh\r\nwhere idle\r\n```\r\n\r\n## use\r\n\r\n- 新建文件: `Ctrl + N`\r\n- 代码补全: `Ctrl + Space` (在 Mac 上是 `Control + Space`)\r\n- 运行: `F5`\r\n- 打开文档: `F1`\r\n- 字体: Options -> Configure IDLE > Fonts/Tabs, 推荐 Consolas, size=18\r\n- 注释: `Alt + 3` (在 Mac 上是 `Option + 3`)\r\n- 取消注释: `Alt + 4` (在 Mac 上是 `Option + 4`)\r\n- 缩进: `Tab`,  取消缩进: `Ctrl + [` (在 Mac 上是 `Command + [`)\r\n",
    "toc": [
      {
        "depth": 2,
        "value": "use",
        "slug": "use"
      }
    ]
  },
  {
    "title": "python",
    "description": "Python 是一种广泛使用的高级编程语言，具有清晰的语法和强大的库支持。它适用于多种应用，包括数据分析、机器学习、Web 开发等。",
    "url": "/blog/2023/06/12/python.mdx",
    "slug": "2023/06/12/python.mdx",
    "segments": [
      "2023",
      "06",
      "12",
      "python.mdx"
    ],
    "filePath": "2023/06/12/python.mdx",
    "meta": {
      "title": "python",
      "description": "Python 是一种广泛使用的高级编程语言，具有清晰的语法和强大的库支持。它适用于多种应用，包括数据分析、机器学习、Web 开发等。",
      "created_at": "2023-06-12T23:35:17.000Z",
      "updated_at": "2025-03-31T23:35:17.000Z",
      "tags": [
        "python"
      ]
    },
    "content": "\r\n## install\r\n\r\n1. 是否已经安装 python\r\n    1. 回想自己是否安装过 python, 下面是误装 `python` 的一些例子\r\n        - 安装 nodejs 时选择了某些选项\r\n    2. 检查当前环境中是否有 python\r\n        ```sh title=\"这些命令会在当前环境中查找 python 的位置\"\r\n        # Windows\r\n        where python\r\n        # 注意在 windows 中 C:\\Users\\aa\\AppData\\Local\\Microsoft\\WindowsApps\\python.exe \r\n        # 这个位置有 python.exe 并不一定意味着你安装了 python, \r\n        # 你可以运行 python 查看有什么反应 可能会跳转到 Microsoft Store, \r\n        # 而不是进入 python 交互式命令行, 那么说明你没有安装 python\r\n        # Linux\r\n        which python\r\n        # MacOS\r\n        type python\r\n        ```\r\n    3. 如果你想的话可以 在所以文件中查找 python 的位置\r\n        ```sh title=\"这些命令会在所有文件中查找 python 的位置\"\r\n        # Windows `/s` 表示递归搜索子目录 `/b` 表示只显示文件名\r\n        dir C:\\python.exe /s /b # 在 C 盘中查找 python.exe\r\n        dir D:\\python.exe /s /b # 在 D 盘中查找 python.exe\r\n        # Linux\r\n        find / -name python\r\n        # MacOS\r\n        find / -name python\r\n        ```\r\n\r\n",
    "toc": [
      {
        "depth": 2,
        "value": "install",
        "slug": "install"
      }
    ]
  },
  {
    "title": "conda",
    "description": "Conda 是一个开源的包管理器和环境管理器，主要用于 Python 和 R 语言。它允许用户安装、更新和管理软件包及其依赖项，并创建和管理虚拟环境。",
    "url": "/blog/2023/06/18/conda.mdx",
    "slug": "2023/06/18/conda.mdx",
    "segments": [
      "2023",
      "06",
      "18",
      "conda.mdx"
    ],
    "filePath": "2023/06/18/conda.mdx",
    "meta": {
      "title": "conda",
      "description": "Conda 是一个开源的包管理器和环境管理器，主要用于 Python 和 R 语言。它允许用户安装、更新和管理软件包及其依赖项，并创建和管理虚拟环境。",
      "created_at": "2023-06-12T23:37:49.000Z",
      "updated_at": "2025-03-31T23:37:49.000Z",
      "tags": [
        "python",
        "env"
      ]
    },
    "content": "\r\n## install conda\r\n\r\nConda 支持多种安装方法\r\n\r\n- Anaconda 是一个包含 Conda 的完整数据科学工具包，适合需要大量预装库的用户\r\n  - 自带大量科学计算和数据分析库（如 NumPy、Pandas、Jupyter Notebook 等）\r\n  - 文件较大（约 500MB+），安装后占用较多磁盘空间\r\n- Miniconda 是一个轻量级的 Conda 版本，仅包含 Conda 和 Python，适合需要更灵活控制环境的用户\r\n  - 文件较小（约 50MB）\r\n\r\n### Anaconda\r\n\r\n\r\n### Miniconda\r\n\r\n#### use 系统包管理器安装\r\n\r\n##### winget (Windows)\r\n\r\n```sh\r\n# 搜索 Miniconda\r\nwinget search miniconda\r\nwinget install Anaconda.Miniconda3\r\n# or \r\nwinget install Miniconda3\r\n# 安装完成后会告诉你安装路径\r\n# 例如 C:\\Users\\aa\\Miniconda3 , 打开这个路径\r\n# dir C:\\Users\\aa\\Miniconda3 /b # 查看这个目录下的文件和文件夹\r\n# 查看是否有  bin/ Scripts/ 文件夹\r\n# 在环境变量中 创建 名为 CondaPath 的变量, 值为 \r\n# C:\\Users\\aa\\Miniconda3\r\n# C:\\Users\\aa\\Miniconda3\\bin\r\n# C:\\Users\\aa\\Miniconda3\\Scripts\r\n# 然后蒋在名为 PATH 的变量中添加 %CondaPath%\r\n```\r\n\r\n##### pacman (Arch Linux \\ Manjaro)\r\n\r\n##### apt (Debian\\Ubuntu)\r\n\r\n##### dnf (Fedora)\r\n\r\n##### yum (openSUSE\\CentOS\\RHEL)\r\n\r\n\r\n#### use src\r\n\r\n#### use docker\r\n\r\n## use\r\n\r\n### create env\r\n\r\n```sh\r\n# (optional) 列出所有可用的环境\r\nconda env list\r\n# (optional) 搜索可用的环境\r\nconda search python\r\n# 创建一个新的 Conda 环境，命名为 py38，使用 Python 3.8.16\r\nconda create -n py38 python=3.8.16\r\n# activate py38 环境\r\nconda activate py38\r\n```\r\n",
    "toc": [
      {
        "depth": 2,
        "value": "install conda",
        "slug": "install-conda"
      },
      {
        "depth": 3,
        "value": "Anaconda",
        "slug": "anaconda"
      },
      {
        "depth": 3,
        "value": "Miniconda",
        "slug": "miniconda"
      },
      {
        "depth": 4,
        "value": "use 系统包管理器安装",
        "slug": "use-系统包管理器安装"
      },
      {
        "depth": 5,
        "value": "winget (Windows)",
        "slug": "winget-(windows)"
      },
      {
        "depth": 5,
        "value": "pacman (Arch Linux \\ Manjaro)",
        "slug": "pacman-(arch-linux-\\-manjaro)"
      },
      {
        "depth": 5,
        "value": "apt (Debian\\Ubuntu)",
        "slug": "apt-(debian\\ubuntu)"
      },
      {
        "depth": 5,
        "value": "dnf (Fedora)",
        "slug": "dnf-(fedora)"
      },
      {
        "depth": 5,
        "value": "yum (openSUSE\\CentOS\\RHEL)",
        "slug": "yum-(opensuse\\centos\\rhel)"
      },
      {
        "depth": 4,
        "value": "use src",
        "slug": "use-src"
      },
      {
        "depth": 4,
        "value": "use docker",
        "slug": "use-docker"
      },
      {
        "depth": 2,
        "value": "use",
        "slug": "use"
      },
      {
        "depth": 3,
        "value": "create env",
        "slug": "create-env"
      }
    ]
  },
  {
    "title": "time",
    "description": "时间 (Time) 是一种度量, 用于表示事件发生的顺序和持续时间",
    "url": "/blog/2023/06/13/time.mdx",
    "slug": "2023/06/13/time.mdx",
    "segments": [
      "2023",
      "06",
      "13",
      "time.mdx"
    ],
    "filePath": "2023/06/13/time.mdx",
    "meta": {
      "title": "time",
      "description": "时间 (Time) 是一种度量, 用于表示事件发生的顺序和持续时间",
      "created_at": "2023-06-13T18:59:44.000Z",
      "updated_at": "2025-04-04T18:59:44.000Z",
      "tags": [
        "time",
        "python",
        "alg"
      ]
    },
    "content": "\n```py\nfrom datetime import date, timedelta\n# 计算两个日期之间的天数\nstart_date = date(2025, 4, 1)\nend_date = date(2025, 4, 17)\ndelta = end_date - start_date\nprint(delta)  # 输出: 16 days, 0:00:00\nprint(delta.days)  # 输出: 16\n```\n\n## 例题\n\n### 第几天\n2000年的1月1日, 是那一年的第1天\n\n那么, 2000年5月4日, 是那一年的第几天\n```py\nfrom datetime import date\nprint((date(2000, 5, 4)-date(2000, 1, 1)).days+1) # 输出: 125\n```\n\n### 星期一\n整个20世纪 (1901-01-01 ~ 2000-12-31) 中, 星期一的数量\n```py\nfrom datetime import date, timedelta\nt0 = date(1901, 1, 1)\nt1 = date(2000, 12, 31)\nres = 0\nwhile t0 <= t1:\n    if t0.weekday() == 0:  # 0=Monday, 1=Tuesday, ..., 6=Sunday\n        res += 1\n    t0 += timedelta(days=1)\nprint(res)  # 输出: 5217\n```\n\n### 含2天数\n小蓝特别喜欢2, 今年是公元2020年, 他特别高校, 因为每天都可以看到2\n\n如果日历中只显示年月日, 请问从公元 1900年1月1日 到公元 9999年12月31日, 一共有多少天日历上包含2\n```py\nfrom datetime import date, timedelta\nt0 = date(1900, 1, 1)\nt1 = date(9999, 12, 31)\ndelta = timedelta(days=1)\nres = 0\nwhile t0 < t1:\n    if '2' in str(t0):\n        res += 1\n    t0 += delta\nprint(res+1)  # 输出: 1994240\n```\n\nnumberTheory",
    "toc": [
      {
        "depth": 2,
        "value": "例题",
        "slug": "例题"
      },
      {
        "depth": 3,
        "value": "第几天",
        "slug": "第几天"
      },
      {
        "depth": 3,
        "value": "星期一",
        "slug": "星期一"
      },
      {
        "depth": 3,
        "value": "含2天数",
        "slug": "含2天数"
      }
    ]
  },
  {
    "title": "auth",
    "description": "...",
    "url": "/blog/2023/07/12/auth.mdx",
    "slug": "2023/07/12/auth.mdx",
    "segments": [
      "2023",
      "07",
      "12",
      "auth.mdx"
    ],
    "filePath": "2023/07/12/auth.mdx",
    "meta": {
      "title": "auth",
      "description": "...",
      "created_at": "2023-07-12T05:59:58.000Z",
      "updated_at": "2025-04-02T05:59:58.000Z",
      "tags": [
        "web",
        "auth"
      ]
    },
    "content": "",
    "toc": []
  },
  {
    "title": "dns",
    "description": "全称是 Domain Name System （域名系统），它是互联网的重要基础设施之一，用于将人类易于记忆的 域名（如 www.example.com) 转换为计算机可以识别的 IP 地址（如 192.168.1.1 或 2606:4700:4700::1111)",
    "url": "/blog/2023/07/13/dns.mdx",
    "slug": "2023/07/13/dns.mdx",
    "segments": [
      "2023",
      "07",
      "13",
      "dns.mdx"
    ],
    "filePath": "2023/07/13/dns.mdx",
    "meta": {
      "title": "dns",
      "description": "全称是 Domain Name System （域名系统），它是互联网的重要基础设施之一，用于将人类易于记忆的 域名（如 www.example.com) 转换为计算机可以识别的 IP 地址（如 192.168.1.1 或 2606:4700:4700::1111)",
      "created_at": "2023-07-13T16:23:48.000Z",
      "updated_at": "2025-04-02T16:23:48.000Z",
      "tags": [
        "web",
        "dns"
      ]
    },
    "content": "\n## bug\n\n### ERR_TOO_MANY_REDIRECTS\n\ncloudflare vercel\n\nfirefox: 检测到该服务器正在将指向此网址的 请求 无限循环 重定向\n\n在 **Vercel** 上部署并使用 **Cloudflare 提供的域名 (CNAME 记录)** 时，出现 **“无限循环重定向”** 的问题，通常是由于 **HTTPS 配置** 或 **Cloudflare 和 Vercel 的设置冲突** 导致的。以下是针对这种情况的分析和解决方法\n\n#### 问题原因分析\n\n##### HTTPS 重定向冲突\n\n- Vercel 默认会强制将所有 HTTP 请求重定向到 HTTPS\n- Cloudflare 也可能启用了 HTTPS 重定向（通过 \"Always Use HTTPS\" 或 \"Automatic HTTPS Rewrites\" 功能）\n- 如果两者都启用了 HTTPS 重定向，可能会导致循环重定向\n\n##### Cloudflare 的 SSL/TLS 配置问题\n\n- Cloudflare 提供了多种 SSL/TLS 模式 (如 Flexible, Full, Full (strict) )\n- 如果 Cloudflare 的 SSL 模式设置为 Flexible, Cloudflare 会尝试通过 HTTP 与 Vercel 通信，而 Vercel 强制 HTTPS, 这会导致循环重定向\n\n#### 解决方法\n1. 检查 Cloudflare 的 SSL/TLS 模式\n    1. 登陆 Cloudflare 控制面板\n    2. 选择你的域名\n    3. 点击 **SSL/TLS** 选项卡\n    4. 确保 SSL/TLS 模式设置为 **Full** 或 **Full (strict)**，而不是 **Flexible**\n\n## 参考\n\n- https://brume.top/p/solution-for-err-too-many-redirects-error/",
    "toc": [
      {
        "depth": 2,
        "value": "bug",
        "slug": "bug"
      },
      {
        "depth": 3,
        "value": "ERR_TOO_MANY_REDIRECTS",
        "slug": "err_too_many_redirects"
      },
      {
        "depth": 4,
        "value": "问题原因分析",
        "slug": "问题原因分析"
      },
      {
        "depth": 5,
        "value": "HTTPS 重定向冲突",
        "slug": "https-重定向冲突"
      },
      {
        "depth": 5,
        "value": "Cloudflare 的 SSL/TLS 配置问题",
        "slug": "cloudflare-的-ssl/tls-配置问题"
      },
      {
        "depth": 4,
        "value": "解决方法",
        "slug": "解决方法"
      },
      {
        "depth": 2,
        "value": "参考",
        "slug": "参考"
      }
    ]
  },
  {
    "title": "vscode",
    "description": "...",
    "url": "/blog/2023/08/01/vscode.mdx",
    "slug": "2023/08/01/vscode.mdx",
    "segments": [
      "2023",
      "08",
      "01",
      "vscode.mdx"
    ],
    "filePath": "2023/08/01/vscode.mdx",
    "meta": {
      "title": "vscode",
      "description": "...",
      "created_at": "2023-08-01T05:31:57.000Z",
      "updated_at": "2025-04-02T05:31:57.000Z",
      "tags": [
        "vscode"
      ]
    },
    "content": "\n```sh\ncode ~/repos/env_ls/dotfiles\n```\n",
    "toc": []
  },
  {
    "title": "css",
    "description": ":has()...",
    "url": "/blog/2023/08/02/css.mdx",
    "slug": "2023/08/02/css.mdx",
    "segments": [
      "2023",
      "08",
      "02",
      "css.mdx"
    ],
    "filePath": "2023/08/02/css.mdx",
    "meta": {
      "title": "css",
      "description": ":has()...",
      "created_at": "2023-08-02T10:35:32.000Z",
      "updated_at": "2025-03-30T10:35:32.000Z",
      "tags": [
        "css",
        "html"
      ]
    },
    "content": "\n## :has()\n```html\n<style>\n  div:has(.highlight) { /* 使用 :has() 选择包含 .highlight 的 div */\n    border: 2px solid red;\n    padding: 10px;\n    margin-bottom: 10px;\n  }\n  div { /* 普通 div 的样式 */\n    border: 2px solid gray;\n    padding: 10px;\n    margin-bottom: 10px;\n  }\n  .highlight { /* .highlight 的样式 */\n    background-color: yellow;\n    padding: 5px;\n  }\n</style>\n<div><!-- 不包含 .highlight 的 div -->\n  <p>这是一个普通的 div，没有 .highlight 元素。</p>\n</div>\n<div><!-- 包含 .highlight 的 div -->\n  <p>这是一个包含 <span class=\"highlight\">高亮内容</span> 的 div。</p>\n</div>\n<div><!-- 不包含 .highlight 的 div -->\n  <p>这是另一个普通的 div，没有 .highlight 元素。</p>\n</div>\n```\n",
    "toc": [
      {
        "depth": 2,
        "value": ":has()",
        "slug": ":has()"
      }
    ]
  },
  {
    "title": "package manager",
    "description": "包管理器是一种用于自动化安装、升级、配置和删除计算机程序的工具。主要可以分为两类：操作系统包管理器和编程语言包管理器。",
    "url": "/blog/2023/12/13/packManager.mdx",
    "slug": "2023/12/13/packManager.mdx",
    "segments": [
      "2023",
      "12",
      "13",
      "packManager.mdx"
    ],
    "filePath": "2023/12/13/packManager.mdx",
    "meta": {
      "title": "package manager",
      "description": "包管理器是一种用于自动化安装、升级、配置和删除计算机程序的工具。主要可以分为两类：操作系统包管理器和编程语言包管理器。",
      "created_at": "2023-12-13T00:34:27.000Z",
      "updated_at": "2025-04-01T00:34:27.000Z",
      "tags": [
        "package"
      ]
    },
    "content": "\r\n| 环境 | 包管理器 | 说明 |\r\n| --- | --- | --- |\r\n| windows | [winget](https://winget.run/) | Windows 10 和 Windows 11 的包管理器 |\r\n| macOS | [Homebrew](https://brew.sh/) | macOS 的包管理器 |\r\n| Ubuntu\\debian | [apt](https://packages.debian.org/) | Debian 和 Ubuntu 的包管理器 |\r\n| Arch Linux\\Manjaro | [pacman](https://archlinux.org/) | Arch Linux 和 Manjaro 的包管理器 |\r\n| Fedora | [dnf](https://dnf.readthedocs.io/en/latest/) | Fedora 的包管理器 |\r\n| openSUSE\\CentOS\\RHEL | [yum](https://yum.baseurl.org/) | openSUSE、CentOS 和 RHEL 的包管理器 |\r\n| Python | [pip](https://pypi.org/) | Python 的包管理器 |\r\n| Conda | [conda](https://docs.conda.io/en/latest/) | Python 的包管理器 |\r\n| Nodejs | [npm](https://www.npmjs.com/) | Node.js 的包管理器 |\r\n| Nodejs | [yarn](https://yarnpkg.com/) | Node.js 的包管理器 |\r\n| Nodejs | [pnpm](https://pnpm.io/) | Node.js 的包管理器 |\r\n| Deno | [deno](https://deno.land/) | Deno 的包管理器 |\r\n| Bun | [bun](https://bun.sh/) | Bun 的包管理器 |\r\n| Rust | [cargo](https://doc.rust-lang.org/cargo/) | Rust 的包管理器 |\r\n| Go | [go](https://golang.org/) | Go 的包管理器 |\r\n| C\\C++ |[conan](https://conan.io/) | C\\C++ 的包管理器 |\r\n| Ruby | [gem](https://rubygems.org/) | Ruby 的包管理器 |\r\n| Java | [maven](https://maven.apache.org/) | Java 的包管理器 |\r\n| Java | [gradle](https://gradle.org/) | Java 的包管理器 |\r\n| PHP | [composer](https://getcomposer.org/) | PHP 的包管理器 |\r\n| C# | [nuget](https://www.nuget.org/) | C# 的包管理器 |\r\n| Elixir | [hex](https://hex.pm/) | Elixir 的包管理器 |\r\n| Elixir | [mix](https://hexdocs.pm/mix/) | Elixir 的包管理器 |\r\n\r\n## winget (Windows)\r\n\r\n```terminal\r\nAdministrator in ~ took 50s\r\n🪟 ❯ winget search miniconda\r\nThe `msstore` source requires that you view the following agreements before using.\r\nTerms of Transaction: https://aka.ms/microsoft-store-terms-of-transaction\r\nThe source requires the current machine's 2-letter geographic region to be sent to the backend service to function properly (ex. \"US\").\r\n\r\nDo you agree to all the source agreements terms?\r\n[Y] Yes  [N] No: yes\r\nName       Id                  Version        Match          Source\r\n-------------------------------------------------------------------\r\nMiniconda3 Anaconda.Miniconda3 py312_25.1.1-2 Tag: miniconda winget\r\n\r\n🪟 ❯ winget install Miniconda3\r\n# or \r\n🪟 ❯ winget install Anaconda.Miniconda3\r\n```\r\n",
    "toc": [
      {
        "depth": 2,
        "value": "winget (Windows)",
        "slug": "winget-(windows)"
      }
    ]
  }
]