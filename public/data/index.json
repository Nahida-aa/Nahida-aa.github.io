[
  {
    "title": "alg",
    "description": "算法竞赛学习路线 算法竞赛是一个需要扎实的数学基础和编...",
    "url": "/blog/2025/03/25/alg.mdx",
    "slug": "2025/03/25/alg.mdx",
    "segments": [
      "2025",
      "03",
      "25",
      "alg.mdx"
    ],
    "filePath": "2025/03/25/alg.mdx",
    "meta": {
      "title": "alg",
      "description": null,
      "created_at": "2025-03-28T19:55:10.000Z",
      "updated_at": "2025-03-28T19:55:10.000Z",
      "tags": [
        "alg"
      ]
    },
    "content": "\n## 算法竞赛学习路线\n算法竞赛是一个需要扎实的数学基础和编程能力的领域。以下是一个系统的学习路线，帮助你在算法竞赛中取得更好的成绩。\n\n### 基础数据结构\n   - **数组与字符串**：基本操作、滑动窗口、双指针。\n   - **栈与队列**：单调栈、单调队列、优先队列。\n   - **链表**：单链表、双向链表、环形链表。\n   - **哈希表**：哈希映射、哈希集合。\n   - **树与图**：二叉树、二叉搜索树、并查集（如你当前的文档）、图的表示方法（邻接表、邻接矩阵）。\n\n### 算法基础\n   - **排序与搜索**：快速排序、归并排序、二分查找。\n   - **递归与分治**：递归思想、分治法的应用。\n   - **动态规划 (DP)**：背包问题、区间 DP、状态压缩 DP。\n   - **贪心算法**：常见贪心策略及其应用。\n   - **图论算法**：\n     - 最短路径：Dijkstra、Floyd-Warshall、Bellman-Ford。\n     - 最小生成树：Prim、Kruskal。\n     - 拓扑排序、强连通分量 (Tarjan 算法)。\n   - **数学相关算法**：\n     - 数论：快速幂、欧几里得算法、线性筛、模运算。\n     - 组合数学：排列组合、容斥原理、生成函数。\n     - 博弈论：Nim 博弈、SG 函数。\n\n### 高级数据结构\n   - **线段树**：区间查询与修改。\n   - **树状数组**：高效处理前缀和问题。\n   - **字典树 (Trie)**：字符串处理。\n   - **堆**：优先队列的实现。\n   - **并查集**：路径压缩与按秩合并（如你当前文档提到的内容）。\n   - **平衡树**：如 AVL 树、红黑树、Treap。\n\n### 算法竞赛技巧\n   - **代码能力**：熟练掌握 C++ 或 Python 等语言，尤其是 STL（C++）或内置函数（Python）。\n   - **模板积累**：常用算法和数据结构的代码模板。\n   - **题型分类**：熟悉常见题型，如模拟、搜索、动态规划、数学题。\n   - **时间与空间优化**：掌握复杂度分析，避免超时或超内存。\n\n### 学习资源\n   - **书籍**：\n     - 《算法竞赛入门经典》（刘汝佳，《算法竞赛入门经典（第2版）》）。\n     - 《算法导论》（Introduction to Algorithms）。\n     - 《挑战程序设计竞赛》（日文版/中文版）。\n   - **在线平台**：\n     - [LeetCode](https://leetcode.com/)：刷题平台，适合练习算法和数据结构。\n     - [Codeforces](https://codeforces.com/)：算法竞赛平台，适合参加比赛。\n     - [AtCoder](https://atcoder.jp/)：日本的算法竞赛平台。\n     - [洛谷](https://www.luogu.com.cn/)：中文算法竞赛平台。\n   - **视频课程**：\n     - B 站上的算法竞赛课程（如《算法竞赛基础》系列）。\n\n### 训练计划\n   - **初期**：每天刷 2-3 道简单题，熟悉基础数据结构和算法。\n   - **中期**：每天刷 1-2 道中等题，尝试解决动态规划和图论问题。\n   - **后期**：参加虚拟比赛，模拟真实竞赛环境，提升解题速度和准确率。\n\n### 数学与算法结合\n   - 你的数学背景可以帮助你在以下领域更快上手：\n     - 数学建模：动态规划、图论问题。\n     - 数论：快速幂、模运算、线性代数在图论中的应用。\n     - 组合数学：排列组合、概率问题。\n\n通过系统学习和不断练习，你可以快速提升算法竞赛能力！",
    "toc": [
      {
        "depth": 2,
        "value": "算法竞赛学习路线",
        "slug": "算法竞赛学习路线"
      },
      {
        "depth": 3,
        "value": "基础数据结构",
        "slug": "基础数据结构"
      },
      {
        "depth": 3,
        "value": "算法基础",
        "slug": "算法基础"
      },
      {
        "depth": 3,
        "value": "高级数据结构",
        "slug": "高级数据结构"
      },
      {
        "depth": 3,
        "value": "算法竞赛技巧",
        "slug": "算法竞赛技巧"
      },
      {
        "depth": 3,
        "value": "学习资源",
        "slug": "学习资源"
      },
      {
        "depth": 3,
        "value": "训练计划",
        "slug": "训练计划"
      },
      {
        "depth": 3,
        "value": "数学与算法结合",
        "slug": "数学与算法结合"
      }
    ]
  },
  {
    "title": "api",
    "description": "fastApi vs hono",
    "url": "/blog/2025/03/27/api.mdx",
    "slug": "2025/03/27/api.mdx",
    "segments": [
      "2025",
      "03",
      "27",
      "api.mdx"
    ],
    "filePath": "2025/03/27/api.mdx",
    "meta": {
      "title": "api",
      "description": "fastApi vs hono",
      "created_at": "2025-03-27T23:15:42.000Z",
      "updated_at": "2025-03-27T23:15:42.000Z",
      "tags": [
        "web",
        "api"
      ]
    },
    "content": "",
    "toc": []
  },
  {
    "title": "dfs",
    "description": "最大数字 lanqiao 2193 https://w...",
    "url": "/blog/2025/03/27/dfs.mdx",
    "slug": "2025/03/27/dfs.mdx",
    "segments": [
      "2025",
      "03",
      "27",
      "dfs.mdx"
    ],
    "filePath": "2025/03/27/dfs.mdx",
    "meta": {
      "title": "dfs",
      "description": null,
      "created_at": "2025-03-27T20:41:55.000Z",
      "updated_at": "2025-03-27T20:41:55.000Z",
      "tags": [
        "alg",
        "dfs"
      ]
    },
    "content": "\n## 最大数字 lanqiao 2193\nhttps://www.lanqiao.cn/problems/2193/learning/?page=1&first_category_id=1&name=%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97\n\n**问题描述**\n\n给定一个正整数 N 。你可以对 N 的任意一位数字执行任意次以下 2 种操 作：\n\n1. 将该位数字加 1 。如果该位数字已经是 9 , 加 1 之后变成 0 。\n\n2. 将该位数字减 1 。如果该位数字已经是 0 , 减 1 之后变成 9 。\n\n你现在总共可以执行 1 号操作不超过 A 次, 2 号操作不超过 B 次。 请问你最大可以将 N 变成多少?\n**输入格式**\n\n第一行包含 3 个整数: N,A,B\n**输出格式**\n\n一个整数代表答案。\n**样例输入**\n```\n123 1 2\n```\n**样例输出**\n```\n933\n```\n**样例说明**\n\n对百位数字执行 2 次 2 号操作, 对十位数字执行 1 次 1 号操作。\n**评测用例规模与约定**\n\n对于 30%30% 的数据, 1≤N≤100; 0≤A,B≤10\n\n对于 100%100% 的数据, 1≤N≤10^17;0≤A,B≤100\n**运行限制**\n\n- 最大运行时间: 1s\n- 最大运行内存: 512M\n\n**思路**: \n1. 贪心: 从左到右, 近可能构造9\n\n```py\nN, A, B = map(int, input().split())\nsN = str(N)\nlenN = len(sN)\nres = 0\n# 当前的贪心策略虽然高效, 但在某些情况下可能无法找到全局最优解\nfor i in range(len(sN)):\n    base = 10 ** (lenN - i - 1)\n    x = int(sN[i])\n    if x != 9:\n        need_add = 9 - x\n        need_sub = x+1\n        if need_add<= A  and (need_add <= need_sub or B < need_sub):\n            A -= need_add\n            res += 9 * base\n        elif need_sub <= B:\n            B -= need_sub\n            res += 9 * base\n        elif 0 < A:\n            res += (x + A) * base\n            A = 0\n        else:\n          res += x * base\n    else:\n        res += x * base\nprint(res)\n```\n\n```py\ndef dfs(i, curr, a, b):\n    global res\n    if  i == lenN:\n        res = max(res, curr)\n        return\n    x = int(sN[i])\n    d = min(9-x, a)\n    dfs(i+1, curr*10+(x+d), a-d, b)\n    if x+1<=b:\n        dfs(i+1, curr*10+9, a, b-(x+1))\ndfs(0, 0, A, B)\n```\n\n## 小朋友崇拜圈 lanqiao 182\n\nhttps://www.lanqiao.cn/problems/182/learning/?page=1&first_category_id=1&name=%E5%B0%8F%E6%9C%8B%E5%8F%8B%E5%B4%87%E6%8B%9C%E5%9C%88\n\n**题目描述**\n\n班里 N 个小朋友，每个人都有自己最崇拜的一个小朋友（也可以是自己）。\n\n在一个游戏中，需要小朋友坐一个圈，每个小朋友都有自己最崇拜的小朋友在他的右手边。\n\n求满足条件的圈最大多少人？\n\n小朋友编号为 1,2,3,⋯N\n**输入描述**\n\n输入第一行，一个整数 `N (3<N<10^5)`\n\n接下来一行 N 个整数，由空格分开。\n**输出描述**\n\n要求输出一个整数，表示满足条件的最大圈的人数。\n**输入输出样例**\n\n示例\n\n>输入\n```\n9\n3 4 2 5 3 8 4 6 9\n```\n\n>输出\n\n```\n4\n```\n\n>样例解释\n\n如下图所示，崇拜关系用箭头表示，红色表示不在圈中。\n\n显然，最大圈是[2 4 5 3] 构成的圈。\n```mermaid\ngraph LR\n    1((1))-->3\n    2((2))-->4\n    3((3))-->2\n    4((4))-->5\n    5((5))-->3\n    6((6))-->8\n    7((7))-->4\n    8((8))-->6\n    9((9))-->9\n```\n运行限制\n\n- 最大运行时间: 1s\n- 最大运行内存: 256M\n\n**分析**\n- 每个节点 `u` 有且仅有一条出边 `u->v`, 给定数组 `g`, `g[u]==v` 表示这条出边\n\n```py showLineNumbers\nimport sys\nsys.setrecursionlimit(10**5)\nn = int(input())\ng = [0]+ list(map(int, input().split()))\nres = 0 \ndct = {}\ndef dfs(u, idx):\n    global res\n    if u in dct:\n        res = max(res, idx - dct[u])\n        return\n    dct[u] = idx\n    dfs(g[u], idx+1)\nfor u in range(1, n+1):\n    dfs(u, 0)\nprint(res)\n```\n",
    "toc": [
      {
        "depth": 2,
        "value": "最大数字 lanqiao 2193",
        "slug": "最大数字-lanqiao-2193"
      },
      {
        "depth": 2,
        "value": "小朋友崇拜圈 lanqiao 182",
        "slug": "小朋友崇拜圈-lanqiao-182"
      }
    ]
  },
  {
    "title": "bfs",
    "description": "通常是指 广度优先搜索 (Breadth-First Search)，一种经典的图算法，用于遍历或搜索树或图的数据结构",
    "url": "/blog/2025/03/26/bfs.mdx",
    "slug": "2025/03/26/bfs.mdx",
    "segments": [
      "2025",
      "03",
      "26",
      "bfs.mdx"
    ],
    "filePath": "2025/03/26/bfs.mdx",
    "meta": {
      "title": "bfs",
      "description": "通常是指 广度优先搜索 (Breadth-First Search)，一种经典的图算法，用于遍历或搜索树或图的数据结构",
      "created_at": "2025-03-26T22:29:10.000Z",
      "updated_at": "2025-03-27T20:40:13.000Z",
      "tags": [
        "alg",
        "bfs"
      ]
    },
    "content": "\n## BFS 思想\n\nBFS 通常是指 广度优先搜索 (Breadth-First Search)，一种经典的图算法，用于遍历或搜索树或图的数据结构。\n\nBFS 的核心是逐层扩展，使用队列存储待访问的节点\n1. 遍历所有相邻节点（如岛屿问题）。\n2. 模拟扩散过程。\n3. 求最短路径。\n\n## leetCode 695. 岛屿的最大面积\n\n[695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)\n\n给你一个大小为 `m x n` 的二进制矩阵 `grid` 。\n\n岛屿 是由一些相邻的 `1` (代表土地) 构成的组合，这里的「相邻」要求两个 `1` 必须在 水平或者竖直的四个方向上 相邻。你可以假设 `grid` 的四个边缘都被 `0` （代表水）包围着。\n\n岛屿的面积是岛上值为 `1` 的单元格的数目。\n\n计算并返回 `grid` 中最大的岛屿面积。如果没有岛屿，则返回面积为 `0` \n\n**示例 1:**\n![1](https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg)\n> **输入:** \n> ```py\n> grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],\n>         [0,0,0,0,0,0,0,1,1,1,0,0,0],\n>         [0,1,1,0,1,0,0,0,0,0,0,0,0],\n>         [0,1,0,0,1,1,0,0,1,0,1,0,0],\n>         [0,1,0,0,1,1,0,0,1,1,1,0,0],\n>         [0,0,0,0,0,0,0,0,0,0,1,0,0],\n>         [0,0,0,0,0,0,0,1,1,1,0,0,0],\n>         [0,0,0,0,0,0,0,1,1,0,0,0,0]]\n> ```\n> **输出:** 6 <br/>\n> **解释:** 答案不应该是 `11` ，因为岛屿只能包含水平或垂直这四个方向上的 `1` 。\n\n**示例 2:**\n> **输入:** `grid = [[0,0,0,0,0,0,0,0]]{:py}` <br/>\n> **输出:** 0\n\n**提示:**\n- `m == grid.length`\n- `n == grid[i].length`\n- `1 <= m, n <= 50`\n- `grid[i][j]` 为 `0` 或 `1`\n\n```py showLineNumbers\ndef maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    # 维护一个结果变量\n    res = 0\n    # 定义一个方向数组\n    d1 = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    # 遍历每个点\n    for i in range(m):\n        for j in range(n):\n        # 如果当前点是陆地\n        if grid[i][j] == 1:\n            # 将当前点加入队列\n            q = [(i, j)]\n            # 维护当前岛屿的面积\n            area = 1\n            # 将当前点置为 0\n            grid[i][j] = 0\n            # 遍历队列\n            while q:\n                # 取出队列的第一个元素\n                x, y = q.pop(0)\n                # 遍历四个方向\n                for dx, dy in d1:\n                    # 计算新的坐标\n                    nx, ny = x + dx, y + dy\n                    # 如果新的坐标合法\n                    if 0 <= nx < m and 0 <= ny < n and grid[nx][ny]:\n                    # 将新的坐标加入队列\n                    q.append((nx, ny))\n                    # 将新的坐标置为 0\n                    grid[nx][ny] = 0\n                    # 面积加一\n                    area += 1\n            # 更新结果\n            res = max(res, area)\n    return res\n```\n\n## lanqiao 长草\n\nhttps://www.lanqiao.cn/problems/149/learning/?page=1&first_category_id=1&tags=BFS&tag_relation=intersection&difficulty=20\n\n**题目描述**\n\n小明有一块空地，他将这块空地划分为 n 行 m 列的小块，每行和每列的长度都为 1。\n\n小明选了其中的一些小块空地，种上了草，其他小块仍然保持是空地。\n\n这些草长得很快，每个月，草都会向外长出一些，如果一个小块种了草，则它将向自己的上、下、左、右四小块空地扩展，\n\n这四小块空地都将变为有草的小块。请告诉小明, k 个月后空地上哪些地方有草。\n**输入描述**\n\n输入的第一行包含两个整数 n,m。\n\n接下来 n 行，每行包含 m 个字母，表示初始的空地状态，字母之间没有空格。如果为小数点，表示为空地，如果字母为 g, 表示种了草。\n\n接下来包含一个整数 k。 其中, 2≤n,m≤1000, 1≤k≤1000\n**输出描述**\n\n输出 n 行，每行包含 m 个字母，表示 k 个月后空地的状态。如果为小数点，表示为空地，如果字母为 g, 表示长了草。\n**输入输出样例**\n**示例**\n\n>输入\n```\n4 5\n.g...\n.....\n..g..\n.....\n2\n```\n>输出\n```\ngggg.\ngggg.\nggggg\n.ggg.\n```\n**运行限制**\n\n- 最大运行时间: 1s\n- 最大运行内存: 256M\n\n```py showLineNumbers\nimport sys\nfrom collections import deque\ninput = lambda: sys.stdin.readline().strip()\ndef grass_growth(n, m, grid, k):\n    # 定义方向数组（上下左右）\n    d1 = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # 初始化队列，找到所有初始种草的格子\n    q = deque()\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == 1:\n                print(\"aq\")\n                q.append((y, x))\n    \n    # 模拟 k 个月的扩展\n    for _ in range(k):\n        print('k')\n        for _ in range(len(q)):\n            print('q', len(q))\n            y, x = q.popleft()\n            for dy, dx in d1:\n                ny, nx = y + dy, x + dx\n                # 检查边界条件和是否为空地\n                if 0 <= ny < n and 0 <= nx < m and grid[ny][nx] == 0:\n                    grid[ny][nx] = 1  # 将空地变为草\n                    q.append((ny, nx))\n    \n    # 返回最终的状态\n    return grid\n\nn, m = map(int, input().split())\ngrid = [[0]*m for _ in range(n)]\nprint(grid)\nfor y in range(n):\n    r = input()\n    print(r)\n    for x in range(m):\n        if r[x] == 'g':\n            print('rx==g')\n            grid[y][x] = 1\nprint(grid)\nk = int(input())\nres = grass_growth(n, m, grid, k)\nfor row in res:\n    print(''.join(['g' if x == 1 else '.' for x in row]))\n```\n",
    "toc": [
      {
        "depth": 2,
        "value": "BFS 思想",
        "slug": "bfs-思想"
      },
      {
        "depth": 2,
        "value": "leetCode 695. 岛屿的最大面积",
        "slug": "leetcode-695.-岛屿的最大面积"
      },
      {
        "depth": 2,
        "value": "lanqiao 长草",
        "slug": "lanqiao-长草"
      }
    ]
  },
  {
    "title": "export",
    "description": "当想要将next.js项目导出为静态网站时, 可以使用next export命令。",
    "url": "/blog/2025/03/26/export.mdx",
    "slug": "2025/03/26/export.mdx",
    "segments": [
      "2025",
      "03",
      "26",
      "export.mdx"
    ],
    "filePath": "2025/03/26/export.mdx",
    "meta": {
      "title": "export",
      "description": "当想要将next.js项目导出为静态网站时, 可以使用next export命令。",
      "created_at": "2025-03-26T03:42:29.000Z",
      "updated_at": "2025-03-26T03:42:29.000Z",
      "tags": [
        "next",
        "export",
        "html"
      ]
    },
    "content": "\n## Unsupported feature\n> 不支持的功能\n\nhttps://nextjs.org/docs/app/building-your-application/deploying/static-exports#unsupported-features\n\nFeatures that require a Node.js server, or dynamic logic that cannot be computed during the build process, are **not** supported:\n> 需要Node.js服务器的功能, 或者在构建过程中无法计算的动态逻辑，**不**支持：\n- Dynamic Routes with `dynamicParams: true`\n- Dynamic Routes without `generateStaticParams()`\n- ...\n\n## 注意\n\n可能不会识别 next.config.ts 导致变成默认配置, 尽量写 next.config.js 或者 next.config.mjs",
    "toc": [
      {
        "depth": 2,
        "value": "Unsupported feature",
        "slug": "unsupported-feature"
      },
      {
        "depth": 2,
        "value": "注意",
        "slug": "注意"
      }
    ]
  },
  {
    "title": "Next PWA",
    "description": "偶然发现 nextjs15 版本中内置了对 PWA 的...",
    "url": "/blog/2025/03/26/nextPwa.mdx",
    "slug": "2025/03/26/nextPwa.mdx",
    "segments": [
      "2025",
      "03",
      "26",
      "nextPwa.mdx"
    ],
    "filePath": "2025/03/26/nextPwa.mdx",
    "meta": {
      "title": "Next PWA",
      "description": null,
      "created_at": "2025-03-29T05:13:17.000Z",
      "updated_at": "2025-03-29T05:13:17.000Z",
      "tags": [
        "nextjs",
        "pwa"
      ]
    },
    "content": "偶然发现 nextjs15 版本中内置了对 PWA 的支持, https://nextjs.org/docs/app/building-your-application/configuring/progressive-web-apps\n",
    "toc": []
  },
  {
    "title": "Union-Find",
    "description": "并查集 (Disjoint Set Union, 简称 DSU 或 Union-Find) 并查集通常实现为一个森林，其中每棵树表示一个集合 是一种用于处理动态连通性问题的数据结构。",
    "url": "/blog/2025/03/28/Union-Find.mdx",
    "slug": "2025/03/28/Union-Find.mdx",
    "segments": [
      "2025",
      "03",
      "28",
      "Union-Find.mdx"
    ],
    "filePath": "2025/03/28/Union-Find.mdx",
    "meta": {
      "title": "Union-Find",
      "description": "并查集 (Disjoint Set Union, 简称 DSU 或 Union-Find) 并查集通常实现为一个森林，其中每棵树表示一个集合 是一种用于处理动态连通性问题的数据结构。",
      "created_at": "2025-03-28T19:28:35.000Z",
      "updated_at": "2025-03-30T02:10:58.000Z",
      "tags": [
        "alg",
        "tree"
      ]
    },
    "content": "\n```mermaid\ngraph BT\n    2((2)) --\"fa[2]\"-->  1((1))\n    3((3)) --\"fa[3]\"-->  1\n    4((4)) --\"fa[4]\"-->  3\n    5((5)) --\"fa[5]\"-->  3\n    8((8)) -->  7((7))\n    7 -->  6((6))\n```\n\n## overview\n\n它可以高效地解决以下问题: \n1. 合并 (Union) ：将两个集合合并为一个集合 (合并对应的树)。\n2. 查询 (Find) ：查询某个元素属于哪个集合 (通常通过找到集合的代表元素, 即根节点)。 \n\n并查集的核心思想是用一个数组表示集合，通过路径压缩和按秩合并优化，使得查询和合并操作的时间复杂度接近常数 (摊还时间复杂度为 $O(\\alpha(n))$，其中 $\\alpha(n)$ 是反阿克曼函数，增长极慢) \n\n### find\n\n```math\n\\begin{align}\n& find(x) = x 所在集合的根节点的值 \\\\\n& if\\quad fa[x] = x : 表示 x 是根节点 \\\\\n& else : find(fa[x]) 递归调用, 沿着树向上找\n\\end{align}\n```\n通常在判断是否可达, 连通性问题时 进行查询, 如需要判断 u, v 是否属于同一个集合, 则可以判断 find(u) == find(v)\n```py\n# 例如 fa[4] = 3 -> fa[3] = 1 -> fa[1] = 1\ndef find(x):\n    if fa[x] != x:\n        fa[x] = find(fa[x]) # 路径压缩\n    return fa[x]\n```\n```py\n# or 如下写法\ndef find(x):\n    return x if fa[x] == x else find(fa[x])\n\nfind = lambda x: x if fa[x] == x else find(fa[x])\n```\n\n### union\n有时需要将两个集合合并(例如两个家庭结婚), 例如将 u, v 合并为同一个集合, 则可以将 u 的根节点的父节点设为 v 的根节点\n```math\n```\n> [!info]- python 的 `=` 操作是 **引用模型** (Reference Model)\n> `a = b{:py}` 是将 a 指向 b\n>```py\n> # 赋值语法: 变量 = 字面量; 实际上是\n> b = [1, 2, 3]\n> # 引用语法: 变量 = 变量\n> a = b\n> a[0] = 4\n> print(b) # [4, 2, 3]\n> ```\n",
    "toc": [
      {
        "depth": 2,
        "value": "overview",
        "slug": "overview"
      },
      {
        "depth": 3,
        "value": "find",
        "slug": "find"
      },
      {
        "depth": 3,
        "value": "union",
        "slug": "union"
      }
    ]
  },
  {
    "title": "css",
    "description": ":has()...",
    "url": "/blog/2023/08/02/css.mdx",
    "slug": "2023/08/02/css.mdx",
    "segments": [
      "2023",
      "08",
      "02",
      "css.mdx"
    ],
    "filePath": "2023/08/02/css.mdx",
    "meta": {
      "title": "css",
      "description": null,
      "created_at": "2023-08-02T10:35:32.000Z",
      "updated_at": "2025-03-30T10:35:32.000Z",
      "tags": [
        "css",
        "html"
      ]
    },
    "content": "\n## :has()\n```html\n<style>\n  div:has(.highlight) { /* 使用 :has() 选择包含 .highlight 的 div */\n    border: 2px solid red;\n    padding: 10px;\n    margin-bottom: 10px;\n  }\n  div { /* 普通 div 的样式 */\n    border: 2px solid gray;\n    padding: 10px;\n    margin-bottom: 10px;\n  }\n  .highlight { /* .highlight 的样式 */\n    background-color: yellow;\n    padding: 5px;\n  }\n</style>\n<div><!-- 不包含 .highlight 的 div -->\n  <p>这是一个普通的 div，没有 .highlight 元素。</p>\n</div>\n<div><!-- 包含 .highlight 的 div -->\n  <p>这是一个包含 <span class=\"highlight\">高亮内容</span> 的 div。</p>\n</div>\n<div><!-- 不包含 .highlight 的 div -->\n  <p>这是另一个普通的 div，没有 .highlight 元素。</p>\n</div>\n```\n",
    "toc": [
      {
        "depth": 2,
        "value": ":has()",
        "slug": ":has()"
      }
    ]
  },
  {
    "title": "微积分",
    "description": "...",
    "url": "/blog/2021/11/11/calculus.mdx",
    "slug": "2021/11/11/calculus.mdx",
    "segments": [
      "2021",
      "11",
      "11",
      "calculus.mdx"
    ],
    "filePath": "2021/11/11/calculus.mdx",
    "meta": {
      "title": "微积分",
      "description": null,
      "created_at": "2021-11-11T10:13:16.000Z",
      "updated_at": "2025-03-30T10:13:16.000Z",
      "tags": [
        "math"
      ]
    },
    "content": "",
    "toc": []
  },
  {
    "title": "var",
    "description": "赋值 (Assignment) 引用 (Referen...",
    "url": "/blog/2021/12/11/var.mdx",
    "slug": "2021/12/11/var.mdx",
    "segments": [
      "2021",
      "12",
      "11",
      "var.mdx"
    ],
    "filePath": "2021/12/11/var.mdx",
    "meta": {
      "title": "var",
      "description": null,
      "created_at": "2021-12-11T10:11:52.000Z",
      "updated_at": "2025-03-30T10:11:52.000Z",
      "tags": [
        "c"
      ]
    },
    "content": "\n## 赋值 (Assignment)\n\n### 引用 (Reference)\n\n引用是一个变量的别名，它本质上是一个绑定到已有变量的“标签”，并不是直接的“取地址”\n\n示例:\n```c title=\"c\" \nint a = 10;\nint &b = a;  // b 是 a 的引用\nb = 20;      // 修改 b 等同于修改 a\nstd::cout << a;  // 输出: 20\n```\n\n#### 解引用 (Dereference)\n解引用是通过指针访问指针所指向的内存地址中的值。解引用操作需要显式使用 `*` 运算符\n\n```c title=\"c\"\nint a = 10;\nint *ptr = &a;  // ptr 是指向 a 的指针\n*ptr = 20;      // 解引用 ptr，修改 a 的值\nstd::cout << a;  // 输出: 20\n```\n",
    "toc": [
      {
        "depth": 2,
        "value": "赋值 (Assignment)",
        "slug": "赋值-(assignment)"
      },
      {
        "depth": 3,
        "value": "引用 (Reference)",
        "slug": "引用-(reference)"
      },
      {
        "depth": 4,
        "value": "解引用 (Dereference)",
        "slug": "解引用-(dereference)"
      }
    ]
  },
  {
    "title": "Latex",
    "description": "LaTeX 是一种基于排版的文档准备系统，广泛用于学术论文、书籍和演示文稿的编写。它以其强大的数学公式支持和高质量的排版效果而闻名。",
    "url": "/blog/2024/05/19/latex.mdx",
    "slug": "2024/05/19/latex.mdx",
    "segments": [
      "2024",
      "05",
      "19",
      "latex.mdx"
    ],
    "filePath": "2024/05/19/latex.mdx",
    "meta": {
      "title": "Latex",
      "description": "LaTeX 是一种基于排版的文档准备系统，广泛用于学术论文、书籍和演示文稿的编写。它以其强大的数学公式支持和高质量的排版效果而闻名。",
      "created_at": "2024-05-19T19:35:46.000Z",
      "updated_at": "2025-03-28T19:35:46.000Z",
      "tags": []
    },
    "content": "\n## 基本结构\n\n一个简单的 LaTeX 文档通常包含以下结构：\n\n```latex\n\\documentclass{article} % 文档类型\n\\usepackage{amsmath}    % 数学公式支持\n\\begin{document}\n\n\\section{引言}\n这是一个简单的 LaTeX 示例。\n\n\\subsection{数学公式}\n以下是一个数学公式示例：\n\\[\nE = mc^2\n\\]\n\n\\end{document}\n```\n\n## 数学公式\n\nLaTeX 对数学公式的支持非常强大。以下是一些常见的公式示例：\n\n行内公式：\n```latex\n这是一个行内公式 $a^2 + b^2 = c^2$。\n```\n\n块级公式：\n```latex\n\\[\n\\int_a^b f(x) \\, dx = F(b) - F(a)\n\\]\n```\n\n### 希腊字母\n```latex\n\\alpha, \\beta, \\gamma, \\delta, \\epsilon, \\pi, \\sigma\n```\n```math\n\\begin{align}\n&\\alpha \\quad A \\quad  \\text{希腊字母 alpha} \\quad   \\\\\n&\\beta \\quad B  \\text{希腊字母 beta} \\\\\n&\\gamma \\quad \\Gamma \\quad  \\text{希腊字母 gamma} \\\\\n&\\delta \\quad \\Delta \\quad  \\text{希腊字母 delta} \\\\\n&\\epsilon \\quad E  \\text{希腊字母 epsilon} \\\\\n&\\zeta \\quad Z \\quad  \\text{希腊字母 zeta} \\\\\n&\\eta \\quad H \\quad  \\text{希腊字母 eta} \\\\\n&\\theta \\quad \\Theta \\quad  \\text{希腊字母 theta} \\\\\n&\\iota \\quad I \\quad  \\text{希腊字母 iota} \\\\\n&\\kappa \\quad K \\quad  \\text{希腊字母 kappa} \\\\\n&\\lambda \\quad \\Lambda \\quad  \\text{希腊字母 lambda} \\\\\n&\\mu \\quad M \\quad  \\text{希腊字母 mu} \\\\\n&\\nu \\quad N \\quad  \\text{希腊字母 nu} \\\\\n&\\xi \\quad \\Xi \\quad  \\text{希腊字母 xi} \\\\\n&\\omicron \\quad O \\quad  \\text{希腊字母 omicron} \\\\\n&\\pi \\quad \\Pi \\quad  \\text{希腊字母 pi} \\\\\n&\\rho \\quad P  \\quad \\text{希腊字母 rho} \\\\\n&\\sigma \\quad \\Sigma \\quad  \\text{希腊字母 sigma}\\\\\n&\\tau \\quad T \\quad  \\text{希腊字母 tau} \\\\\n&\\upsilon \\quad \\Upsilon \\quad  \\text{希腊字母 upsilon} \\\\\n&\\phi \\quad \\Phi \\quad  \\text{希腊字母 phi} \\\\\n&\\chi \\quad X \\quad  \\text{希腊字母 chi} \\\\\n&\\psi \\quad \\Psi \\quad  \\text{希腊字母 psi} \\\\\n&\\omega \\quad \\Omega  \\quad  \\text{希腊字母 omega} \\\\\n&\\varepsilon \\ :varepsilon,\\ \\vartheta\\ :vartheta,\\ \\varpi\\ :varpi,\\ \\varrho\\ :varrho,\\ \\varsigma\\ :varsigma, \\varphi\\ :varphi \\\\\n\\end{align}\n```\n\n## 表格\n\n使用 `tabular` 环境可以创建表格：\n\n```latex\n\\begin{tabular}{|c|c|c|}\n\\hline\n列1 & 列2 & 列3 \\\\\n\\hline\n数据1 & 数据2 & 数据3 \\\\\n\\hline\n\\end{tabular}\n```\n\n## 插入图片\n\n使用 `graphicx` 包可以插入图片：\n\n```latex\n\\usepackage{graphicx}\n\n\\begin{figure}[h]\n\\centering\n\\includegraphics[width=0.5\\textwidth]{example.png}\n\\caption{示例图片}\n\\end{figure}\n```",
    "toc": [
      {
        "depth": 2,
        "value": "基本结构",
        "slug": "基本结构"
      },
      {
        "depth": 2,
        "value": "数学公式",
        "slug": "数学公式"
      },
      {
        "depth": 3,
        "value": "希腊字母",
        "slug": "希腊字母"
      },
      {
        "depth": 2,
        "value": "表格",
        "slug": "表格"
      },
      {
        "depth": 2,
        "value": "插入图片",
        "slug": "插入图片"
      }
    ]
  },
  {
    "title": "Java",
    "description": "东西都被删除了吗 runtime function 重...",
    "url": "/blog/2024/10/12/java.mdx",
    "slug": "2024/10/12/java.mdx",
    "segments": [
      "2024",
      "10",
      "12",
      "java.mdx"
    ],
    "filePath": "2024/10/12/java.mdx",
    "meta": {
      "title": "Java",
      "description": null,
      "created_at": "2024-10-12T15:55:11.000Z",
      "updated_at": "2025-03-30T15:55:11.000Z",
      "tags": [
        "java"
      ]
    },
    "content": "\n东西都被删除了吗\n\n## runtime\n\n## function\n\n### 重写 (Override)\n\n### 重载 (Overload)\n\n",
    "toc": [
      {
        "depth": 2,
        "value": "runtime",
        "slug": "runtime"
      },
      {
        "depth": 2,
        "value": "function",
        "slug": "function"
      },
      {
        "depth": 3,
        "value": "重写 (Override)",
        "slug": "重写-(override)"
      },
      {
        "depth": 3,
        "value": "重载 (Overload)",
        "slug": "重载-(overload)"
      }
    ]
  }
]